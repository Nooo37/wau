-- Auto generated by the wau-scanner v0

--- wayland
-- @module wayland

-- Copyright © 2008-2011 Kristian Høgsberg
-- Copyright © 2010-2011 Intel Corporation
-- Copyright © 2012-2013 Collabora, Ltd.
-- Permission is hereby granted, free of charge, to any person
-- obtaining a copy of this software and associated documentation files
-- (the "Software"), to deal in the Software without restriction,
-- including without limitation the rights to use, copy, modify, merge,
-- publish, distribute, sublicense, and/or sell copies of the Software,
-- and to permit persons to whom the Software is furnished to do so,
-- subject to the following conditions:
-- The above copyright notice and this permission notice (including the
-- next paragraph) shall be included in all copies or substantial
-- portions of the Software.
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-- NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
-- BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
-- ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-- CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
return function(wau)

local interfaces = {
    "wl_display",
    "wl_registry",
    "wl_callback",
    "wl_compositor",
    "wl_shm_pool",
    "wl_shm",
    "wl_buffer",
    "wl_data_offer",
    "wl_data_source",
    "wl_data_device",
    "wl_data_device_manager",
    "wl_shell",
    "wl_shell_surface",
    "wl_surface",
    "wl_seat",
    "wl_pointer",
    "wl_keyboard",
    "wl_touch",
    "wl_output",
    "wl_region",
    "wl_subcompositor",
    "wl_subsurface",
}

for _, iface in ipairs(interfaces) do
    wau[iface] = wau.wl_interface.new()
end

--- core global object
--
-- The core global object.  This is a special singleton object.  It
-- is used for internal Wayland protocol features.
-- @type wl_display
wau.wl_display:init {
    name = "wl_display",
    version = 1,
    methods = {
        --- asynchronous roundtrip
        --
        -- The sync request asks the server to emit the 'done' event
        -- on the returned wl_callback object.  Since requests are
        -- handled in-order and events are delivered in-order, this can
        -- be used as a barrier to ensure all previous requests and the
        -- resulting events have been handled.
        -- The object returned by this request will be destroyed by the
        -- compositor after the callback is fired and as such the client must not
        -- attempt to use it after that point.
        -- The callback_data passed in the callback is the event serial.
        -- @function wl_display:sync
        -- @treturn wl_callback
        {
            name = "sync",
            signature = "n",
            types = { wau.wl_callback, },
        },
        --- get global registry object
        --
        -- This request creates a registry object that allows the client
        -- to list and bind the global objects available from the
        -- compositor.
        -- It should be noted that the server side resources consumed in
        -- response to a get_registry request can only be released when the
        -- client disconnects, not when the client side proxy is destroyed.
        -- Therefore, clients should invoke get_registry as infrequently as
        -- possible to avoid wasting memory.
        -- @function wl_display:get_registry
        -- @treturn wl_registry
        {
            name = "get_registry",
            signature = "n",
            types = { wau.wl_registry, },
        },
    },
    events = {
        --- fatal error event
        --
        -- The error event is sent out when a fatal (non-recoverable)
        -- error has occurred.  The object_id argument is the object
        -- where the error occurred, most often in response to a request
        -- to that object.  The code identifies the error and is defined
        -- by the object interface.  As such, each interface defines its
        -- own set of error codes.  The message is a brief description
        -- of the error, for (debugging) convenience.
        -- @event wl_display:error
        -- @tparam object object_id object where the error occurred
        -- @tparam uint code error code
        -- @tparam string message error description
        {
            name = "error",
            signature = "ous",
            types = { 0, 0, 0, },
        },
        --- acknowledge object ID deletion
        --
        -- This event is used internally by the object ID management
        -- logic. When a client deletes an object that it had created,
        -- the server will send this event to acknowledge that it has
        -- seen the delete request. When the client receives this event,
        -- it will know that it can safely reuse the object ID.
        -- @event wl_display:delete_id
        -- @tparam uint id deleted object ID
        {
            name = "delete_id",
            signature = "u",
            types = { 0, },
        },
    },
    enums = {
        --- global error values
        --
        -- These errors are global and can be emitted in response to any
        -- server request.
        -- @enum wl_display.Error
        -- @param INVALID_OBJECT 0 server couldn't find object
        -- @param INVALID_METHOD 1 method doesn't exist on the specified interface or malformed request
        -- @param NO_MEMORY 2 server is out of memory
        -- @param IMPLEMENTATION 3 implementation error in compositor
        ["error"] = {
            ["invalid_object"] = 0,
            ["invalid_method"] = 1,
            ["no_memory"] = 2,
            ["implementation"] = 3,
        },
    },
    methods_opcode = {
        ["sync"] = 0,
        ["get_registry"] = 1,
    },
}

--- global registry object
--
-- The singleton global registry object.  The server has a number of
-- global objects that are available to all clients.  These objects
-- typically represent an actual object in the server (for example,
-- an input device) or they are singleton objects that provide
-- extension functionality.
-- When a client creates a registry object, the registry object
-- will emit a global event for each global currently in the
-- registry.  Globals come and go as a result of device or
-- monitor hotplugs, reconfiguration or other events, and the
-- registry will send out global and global_remove events to
-- keep the client up to date with the changes.  To mark the end
-- of the initial burst of events, the client can use the
-- wl_display.sync request immediately after calling
-- wl_display.get_registry.
-- A client can bind to a global object by using the bind
-- request.  This creates a client-side handle that lets the object
-- emit events to the client and lets the client invoke requests on
-- the object.
-- @type wl_registry
wau.wl_registry:init {
    name = "wl_registry",
    version = 1,
    methods = {
        --- bind an object to the display
        --
        -- Binds a new, client-created object to the server using the
        -- specified name as the identifier.
        -- @function wl_registry:bind
        -- @tparam uint name unique numeric name of the object
        -- @treturn object
        {
            name = "bind",
            signature = "usun",
            types = { 0, 0, },
        },
    },
    events = {
        --- announce global object
        --
        -- Notify the client of global objects.
        -- The event notifies the client that a global object with
        -- the given name is now available, and it implements the
        -- given version of the given interface.
        -- @event wl_registry:global
        -- @tparam uint name numeric name of the global object
        -- @tparam string interface interface implemented by the object
        -- @tparam uint version interface version
        {
            name = "global",
            signature = "usu",
            types = { 0, 0, 0, },
        },
        --- announce removal of global object
        --
        -- Notify the client of removed global objects.
        -- This event notifies the client that the global identified
        -- by name is no longer available.  If the client bound to
        -- the global using the bind request, the client should now
        -- destroy that object.
        -- The object remains valid and requests to the object will be
        -- ignored until the client destroys it, to avoid races between
        -- the global going away and a client sending a request to it.
        -- @event wl_registry:global_remove
        -- @tparam uint name numeric name of the global object
        {
            name = "global_remove",
            signature = "u",
            types = { 0, },
        },
    },
    enums = {
    },
    methods_opcode = {
        ["bind"] = 0,
    },
}

--- callback object
--
-- Clients can handle the 'done' event to get notified when
-- the related request is done.
-- Note, because wl_callback objects are created from multiple independent
-- factory interfaces, the wl_callback interface is frozen at version 1.
-- @type wl_callback
wau.wl_callback:init {
    name = "wl_callback",
    version = 1,
    methods = {
    },
    events = {
        --- done event
        --
        -- Notify the client when the related request is done.
        -- @event wl_callback:done
        -- @tparam uint callback_data request-specific data for the callback
        {
            name = "done",
            signature = "u",
            types = { 0, },
            type = "destructor"
        },
    },
    enums = {
    },
    methods_opcode = {
    },
}

--- the compositor singleton
--
-- A compositor.  This object is a singleton global.  The
-- compositor is in charge of combining the contents of multiple
-- surfaces into one displayable output.
-- @type wl_compositor
wau.wl_compositor:init {
    name = "wl_compositor",
    version = 6,
    methods = {
        --- create new surface
        --
        -- Ask the compositor to create a new surface.
        -- @function wl_compositor:create_surface
        -- @treturn wl_surface
        {
            name = "create_surface",
            signature = "n",
            types = { wau.wl_surface, },
        },
        --- create new region
        --
        -- Ask the compositor to create a new region.
        -- @function wl_compositor:create_region
        -- @treturn wl_region
        {
            name = "create_region",
            signature = "n",
            types = { wau.wl_region, },
        },
    },
    events = {
    },
    enums = {
    },
    methods_opcode = {
        ["create_surface"] = 0,
        ["create_region"] = 1,
    },
}

--- a shared memory pool
--
-- The wl_shm_pool object encapsulates a piece of memory shared
-- between the compositor and client.  Through the wl_shm_pool
-- object, the client can allocate shared memory wl_buffer objects.
-- All objects created through the same pool share the same
-- underlying mapped memory. Reusing the mapped memory avoids the
-- setup/teardown overhead and is useful when interactively resizing
-- a surface or for many small buffers.
-- @type wl_shm_pool
wau.wl_shm_pool:init {
    name = "wl_shm_pool",
    version = 1,
    methods = {
        --- create a buffer from the pool
        --
        -- Create a wl_buffer object from the pool.
        -- The buffer is created offset bytes into the pool and has
        -- width and height as specified.  The stride argument specifies
        -- the number of bytes from the beginning of one row to the beginning
        -- of the next.  The format is the pixel format of the buffer and
        -- must be one of those advertised through the wl_shm.format event.
        -- A buffer will keep a reference to the pool it was created from
        -- so it is valid to destroy the pool immediately after creating
        -- a buffer from it.
        -- @function wl_shm_pool:create_buffer
        -- @treturn wl_buffer
        -- @tparam int offset buffer byte offset within the pool
        -- @tparam int width buffer width, in pixels
        -- @tparam int height buffer height, in pixels
        -- @tparam int stride number of bytes from the beginning of one row to the beginning of the next row
        -- @tparam uint format buffer pixel format
        {
            name = "create_buffer",
            signature = "niiiiu",
            types = { wau.wl_buffer, 0, 0, 0, 0, 0, },
        },
        --- destroy the pool
        --
        -- Destroy the shared memory pool.
        -- The mmapped memory will be released when all
        -- buffers that have been created from this pool
        -- are gone.
        -- @function wl_shm_pool:destroy
        -- @treturn wl_shm_pool self
        {
            name = "destroy",
            signature = "",
            types = { },
            type = "destructor"
        },
        --- change the size of the pool mapping
        --
        -- This request will cause the server to remap the backing memory
        -- for the pool from the file descriptor passed when the pool was
        -- created, but using the new size.  This request can only be
        -- used to make the pool bigger.
        -- This request only changes the amount of bytes that are mmapped
        -- by the server and does not touch the file corresponding to the
        -- file descriptor passed at creation time. It is the client's
        -- responsibility to ensure that the file is at least as big as
        -- the new pool size.
        -- @function wl_shm_pool:resize
        -- @tparam int size new size of the pool, in bytes
        -- @treturn wl_shm_pool self
        {
            name = "resize",
            signature = "i",
            types = { 0, },
        },
    },
    events = {
    },
    enums = {
    },
    methods_opcode = {
        ["create_buffer"] = 0,
        ["destroy"] = 1,
        ["resize"] = 2,
    },
}

--- shared memory support
--
-- A singleton global object that provides support for shared
-- memory.
-- Clients can create wl_shm_pool objects using the create_pool
-- request.
-- On binding the wl_shm object one or more format events
-- are emitted to inform clients about the valid pixel formats
-- that can be used for buffers.
-- @type wl_shm
wau.wl_shm:init {
    name = "wl_shm",
    version = 1,
    methods = {
        --- create a shm pool
        --
        -- Create a new wl_shm_pool object.
        -- The pool can be used to create shared memory based buffer
        -- objects.  The server will mmap size bytes of the passed file
        -- descriptor, to use as backing memory for the pool.
        -- @function wl_shm:create_pool
        -- @treturn wl_shm_pool
        -- @tparam fd fd file descriptor for the pool
        -- @tparam int size pool size, in bytes
        {
            name = "create_pool",
            signature = "nhi",
            types = { wau.wl_shm_pool, 0, 0, },
        },
    },
    events = {
        --- pixel format description
        --
        -- Informs the client about a valid pixel format that
        -- can be used for buffers. Known formats include
        -- argb8888 and xrgb8888.
        -- @event wl_shm:format
        -- @tparam uint format buffer pixel format
        {
            name = "format",
            signature = "u",
            types = { 0, },
        },
    },
    enums = {
        --- wl_shm error values
        --
        -- These errors can be emitted in response to wl_shm requests.
        -- @enum wl_shm.Error
        -- @param INVALID_FORMAT 0 buffer format is not known
        -- @param INVALID_STRIDE 1 invalid size or stride during pool or buffer creation
        -- @param INVALID_FD 2 mmapping the file descriptor failed
        ["error"] = {
            ["invalid_format"] = 0,
            ["invalid_stride"] = 1,
            ["invalid_fd"] = 2,
        },
        --- pixel formats
        --
        -- This describes the memory layout of an individual pixel.
        -- All renderers should support argb8888 and xrgb8888 but any other
        -- formats are optional and may not be supported by the particular
        -- renderer in use.
        -- The drm format codes match the macros defined in drm_fourcc.h, except
        -- argb8888 and xrgb8888. The formats actually supported by the compositor
        -- will be reported by the format event.
        -- For all wl_shm formats and unless specified in another protocol
        -- extension, pre-multiplied alpha is used for pixel values.
        -- @enum wl_shm.Format
        -- @param ARGB8888 0 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
        -- @param XRGB8888 1 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
        -- @param C8 0x20203843 8-bit color index format, [7:0] C
        -- @param RGB332 0x38424752 8-bit RGB format, [7:0] R:G:B 3:3:2
        -- @param BGR233 0x38524742 8-bit BGR format, [7:0] B:G:R 2:3:3
        -- @param XRGB4444 0x32315258 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
        -- @param XBGR4444 0x32314258 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
        -- @param RGBX4444 0x32315852 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
        -- @param BGRX4444 0x32315842 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
        -- @param ARGB4444 0x32315241 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
        -- @param ABGR4444 0x32314241 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
        -- @param RGBA4444 0x32314152 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
        -- @param BGRA4444 0x32314142 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
        -- @param XRGB1555 0x35315258 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
        -- @param XBGR1555 0x35314258 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
        -- @param RGBX5551 0x35315852 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
        -- @param BGRX5551 0x35315842 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
        -- @param ARGB1555 0x35315241 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
        -- @param ABGR1555 0x35314241 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
        -- @param RGBA5551 0x35314152 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
        -- @param BGRA5551 0x35314142 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
        -- @param RGB565 0x36314752 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
        -- @param BGR565 0x36314742 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
        -- @param RGB888 0x34324752 24-bit RGB format, [23:0] R:G:B little endian
        -- @param BGR888 0x34324742 24-bit BGR format, [23:0] B:G:R little endian
        -- @param XBGR8888 0x34324258 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
        -- @param RGBX8888 0x34325852 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
        -- @param BGRX8888 0x34325842 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
        -- @param ABGR8888 0x34324241 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
        -- @param RGBA8888 0x34324152 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
        -- @param BGRA8888 0x34324142 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
        -- @param XRGB2101010 0x30335258 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
        -- @param XBGR2101010 0x30334258 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
        -- @param RGBX1010102 0x30335852 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
        -- @param BGRX1010102 0x30335842 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
        -- @param ARGB2101010 0x30335241 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
        -- @param ABGR2101010 0x30334241 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
        -- @param RGBA1010102 0x30334152 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
        -- @param BGRA1010102 0x30334142 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
        -- @param YUYV 0x56595559 packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
        -- @param YVYU 0x55595659 packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
        -- @param UYVY 0x59565955 packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
        -- @param VYUY 0x59555956 packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
        -- @param AYUV 0x56555941 packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
        -- @param NV12 0x3231564e 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
        -- @param NV21 0x3132564e 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
        -- @param NV16 0x3631564e 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
        -- @param NV61 0x3136564e 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
        -- @param YUV410 0x39565559 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
        -- @param YVU410 0x39555659 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
        -- @param YUV411 0x31315559 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
        -- @param YVU411 0x31315659 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
        -- @param YUV420 0x32315559 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
        -- @param YVU420 0x32315659 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
        -- @param YUV422 0x36315559 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
        -- @param YVU422 0x36315659 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
        -- @param YUV444 0x34325559 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
        -- @param YVU444 0x34325659 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
        -- @param R8 0x20203852 [7:0] R
        -- @param R16 0x20363152 [15:0] R little endian
        -- @param RG88 0x38384752 [15:0] R:G 8:8 little endian
        -- @param GR88 0x38385247 [15:0] G:R 8:8 little endian
        -- @param RG1616 0x32334752 [31:0] R:G 16:16 little endian
        -- @param GR1616 0x32335247 [31:0] G:R 16:16 little endian
        -- @param XRGB16161616F 0x48345258 [63:0] x:R:G:B 16:16:16:16 little endian
        -- @param XBGR16161616F 0x48344258 [63:0] x:B:G:R 16:16:16:16 little endian
        -- @param ARGB16161616F 0x48345241 [63:0] A:R:G:B 16:16:16:16 little endian
        -- @param ABGR16161616F 0x48344241 [63:0] A:B:G:R 16:16:16:16 little endian
        -- @param XYUV8888 0x56555958 [31:0] X:Y:Cb:Cr 8:8:8:8 little endian
        -- @param VUY888 0x34325556 [23:0] Cr:Cb:Y 8:8:8 little endian
        -- @param VUY101010 0x30335556 Y followed by U then V, 10:10:10. Non-linear modifier only
        -- @param Y210 0x30313259 [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels
        -- @param Y212 0x32313259 [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels
        -- @param Y216 0x36313259 [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels
        -- @param Y410 0x30313459 [31:0] A:Cr:Y:Cb 2:10:10:10 little endian
        -- @param Y412 0x32313459 [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
        -- @param Y416 0x36313459 [63:0] A:Cr:Y:Cb 16:16:16:16 little endian
        -- @param XVYU2101010 0x30335658 [31:0] X:Cr:Y:Cb 2:10:10:10 little endian
        -- @param XVYU12_16161616 0x36335658 [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
        -- @param XVYU16161616 0x38345658 [63:0] X:Cr:Y:Cb 16:16:16:16 little endian
        -- @param Y0L0 0x304c3059 [63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
        -- @param X0L0 0x304c3058 [63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
        -- @param Y0L2 0x324c3059 [63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
        -- @param X0L2 0x324c3058 [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
        -- @param YUV420_8BIT 0x38305559
        -- @param YUV420_10BIT 0x30315559
        -- @param XRGB8888_A8 0x38415258
        -- @param XBGR8888_A8 0x38414258
        -- @param RGBX8888_A8 0x38415852
        -- @param BGRX8888_A8 0x38415842
        -- @param RGB888_A8 0x38413852
        -- @param BGR888_A8 0x38413842
        -- @param RGB565_A8 0x38413552
        -- @param BGR565_A8 0x38413542
        -- @param NV24 0x3432564e non-subsampled Cr:Cb plane
        -- @param NV42 0x3234564e non-subsampled Cb:Cr plane
        -- @param P210 0x30313250 2x1 subsampled Cr:Cb plane, 10 bit per channel
        -- @param P010 0x30313050 2x2 subsampled Cr:Cb plane 10 bits per channel
        -- @param P012 0x32313050 2x2 subsampled Cr:Cb plane 12 bits per channel
        -- @param P016 0x36313050 2x2 subsampled Cr:Cb plane 16 bits per channel
        -- @param AXBXGXRX106106106106 0x30314241 [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian
        -- @param NV15 0x3531564e 2x2 subsampled Cr:Cb plane
        -- @param Q410 0x30313451
        -- @param Q401 0x31303451
        -- @param XRGB16161616 0x38345258 [63:0] x:R:G:B 16:16:16:16 little endian
        -- @param XBGR16161616 0x38344258 [63:0] x:B:G:R 16:16:16:16 little endian
        -- @param ARGB16161616 0x38345241 [63:0] A:R:G:B 16:16:16:16 little endian
        -- @param ABGR16161616 0x38344241 [63:0] A:B:G:R 16:16:16:16 little endian
        -- @param C1 0x20203143 [7:0] C0:C1:C2:C3:C4:C5:C6:C7 1:1:1:1:1:1:1:1 eight pixels/byte
        -- @param C2 0x20203243 [7:0] C0:C1:C2:C3 2:2:2:2 four pixels/byte
        -- @param C4 0x20203443 [7:0] C0:C1 4:4 two pixels/byte
        -- @param D1 0x20203144 [7:0] D0:D1:D2:D3:D4:D5:D6:D7 1:1:1:1:1:1:1:1 eight pixels/byte
        -- @param D2 0x20203244 [7:0] D0:D1:D2:D3 2:2:2:2 four pixels/byte
        -- @param D4 0x20203444 [7:0] D0:D1 4:4 two pixels/byte
        -- @param D8 0x20203844 [7:0] D
        -- @param R1 0x20203152 [7:0] R0:R1:R2:R3:R4:R5:R6:R7 1:1:1:1:1:1:1:1 eight pixels/byte
        -- @param R2 0x20203252 [7:0] R0:R1:R2:R3 2:2:2:2 four pixels/byte
        -- @param R4 0x20203452 [7:0] R0:R1 4:4 two pixels/byte
        -- @param R10 0x20303152 [15:0] x:R 6:10 little endian
        -- @param R12 0x20323152 [15:0] x:R 4:12 little endian
        -- @param AVUY8888 0x59555641 [31:0] A:Cr:Cb:Y 8:8:8:8 little endian
        -- @param XVUY8888 0x59555658 [31:0] X:Cr:Cb:Y 8:8:8:8 little endian
        -- @param P030 0x30333050 2x2 subsampled Cr:Cb plane 10 bits per channel packed
        ["format"] = {
            ["argb8888"] = 0,
            ["xrgb8888"] = 1,
            ["c8"] = 0x20203843,
            ["rgb332"] = 0x38424752,
            ["bgr233"] = 0x38524742,
            ["xrgb4444"] = 0x32315258,
            ["xbgr4444"] = 0x32314258,
            ["rgbx4444"] = 0x32315852,
            ["bgrx4444"] = 0x32315842,
            ["argb4444"] = 0x32315241,
            ["abgr4444"] = 0x32314241,
            ["rgba4444"] = 0x32314152,
            ["bgra4444"] = 0x32314142,
            ["xrgb1555"] = 0x35315258,
            ["xbgr1555"] = 0x35314258,
            ["rgbx5551"] = 0x35315852,
            ["bgrx5551"] = 0x35315842,
            ["argb1555"] = 0x35315241,
            ["abgr1555"] = 0x35314241,
            ["rgba5551"] = 0x35314152,
            ["bgra5551"] = 0x35314142,
            ["rgb565"] = 0x36314752,
            ["bgr565"] = 0x36314742,
            ["rgb888"] = 0x34324752,
            ["bgr888"] = 0x34324742,
            ["xbgr8888"] = 0x34324258,
            ["rgbx8888"] = 0x34325852,
            ["bgrx8888"] = 0x34325842,
            ["abgr8888"] = 0x34324241,
            ["rgba8888"] = 0x34324152,
            ["bgra8888"] = 0x34324142,
            ["xrgb2101010"] = 0x30335258,
            ["xbgr2101010"] = 0x30334258,
            ["rgbx1010102"] = 0x30335852,
            ["bgrx1010102"] = 0x30335842,
            ["argb2101010"] = 0x30335241,
            ["abgr2101010"] = 0x30334241,
            ["rgba1010102"] = 0x30334152,
            ["bgra1010102"] = 0x30334142,
            ["yuyv"] = 0x56595559,
            ["yvyu"] = 0x55595659,
            ["uyvy"] = 0x59565955,
            ["vyuy"] = 0x59555956,
            ["ayuv"] = 0x56555941,
            ["nv12"] = 0x3231564e,
            ["nv21"] = 0x3132564e,
            ["nv16"] = 0x3631564e,
            ["nv61"] = 0x3136564e,
            ["yuv410"] = 0x39565559,
            ["yvu410"] = 0x39555659,
            ["yuv411"] = 0x31315559,
            ["yvu411"] = 0x31315659,
            ["yuv420"] = 0x32315559,
            ["yvu420"] = 0x32315659,
            ["yuv422"] = 0x36315559,
            ["yvu422"] = 0x36315659,
            ["yuv444"] = 0x34325559,
            ["yvu444"] = 0x34325659,
            ["r8"] = 0x20203852,
            ["r16"] = 0x20363152,
            ["rg88"] = 0x38384752,
            ["gr88"] = 0x38385247,
            ["rg1616"] = 0x32334752,
            ["gr1616"] = 0x32335247,
            ["xrgb16161616f"] = 0x48345258,
            ["xbgr16161616f"] = 0x48344258,
            ["argb16161616f"] = 0x48345241,
            ["abgr16161616f"] = 0x48344241,
            ["xyuv8888"] = 0x56555958,
            ["vuy888"] = 0x34325556,
            ["vuy101010"] = 0x30335556,
            ["y210"] = 0x30313259,
            ["y212"] = 0x32313259,
            ["y216"] = 0x36313259,
            ["y410"] = 0x30313459,
            ["y412"] = 0x32313459,
            ["y416"] = 0x36313459,
            ["xvyu2101010"] = 0x30335658,
            ["xvyu12_16161616"] = 0x36335658,
            ["xvyu16161616"] = 0x38345658,
            ["y0l0"] = 0x304c3059,
            ["x0l0"] = 0x304c3058,
            ["y0l2"] = 0x324c3059,
            ["x0l2"] = 0x324c3058,
            ["yuv420_8bit"] = 0x38305559,
            ["yuv420_10bit"] = 0x30315559,
            ["xrgb8888_a8"] = 0x38415258,
            ["xbgr8888_a8"] = 0x38414258,
            ["rgbx8888_a8"] = 0x38415852,
            ["bgrx8888_a8"] = 0x38415842,
            ["rgb888_a8"] = 0x38413852,
            ["bgr888_a8"] = 0x38413842,
            ["rgb565_a8"] = 0x38413552,
            ["bgr565_a8"] = 0x38413542,
            ["nv24"] = 0x3432564e,
            ["nv42"] = 0x3234564e,
            ["p210"] = 0x30313250,
            ["p010"] = 0x30313050,
            ["p012"] = 0x32313050,
            ["p016"] = 0x36313050,
            ["axbxgxrx106106106106"] = 0x30314241,
            ["nv15"] = 0x3531564e,
            ["q410"] = 0x30313451,
            ["q401"] = 0x31303451,
            ["xrgb16161616"] = 0x38345258,
            ["xbgr16161616"] = 0x38344258,
            ["argb16161616"] = 0x38345241,
            ["abgr16161616"] = 0x38344241,
            ["c1"] = 0x20203143,
            ["c2"] = 0x20203243,
            ["c4"] = 0x20203443,
            ["d1"] = 0x20203144,
            ["d2"] = 0x20203244,
            ["d4"] = 0x20203444,
            ["d8"] = 0x20203844,
            ["r1"] = 0x20203152,
            ["r2"] = 0x20203252,
            ["r4"] = 0x20203452,
            ["r10"] = 0x20303152,
            ["r12"] = 0x20323152,
            ["avuy8888"] = 0x59555641,
            ["xvuy8888"] = 0x59555658,
            ["p030"] = 0x30333050,
        },
    },
    methods_opcode = {
        ["create_pool"] = 0,
    },
}

--- content for a wl_surface
--
-- A buffer provides the content for a wl_surface. Buffers are
-- created through factory interfaces such as wl_shm, wp_linux_buffer_params
-- (from the linux-dmabuf protocol extension) or similar. It has a width and
-- a height and can be attached to a wl_surface, but the mechanism by which a
-- client provides and updates the contents is defined by the buffer factory
-- interface.
-- If the buffer uses a format that has an alpha channel, the alpha channel
-- is assumed to be premultiplied in the color channels unless otherwise
-- specified.
-- Note, because wl_buffer objects are created from multiple independent
-- factory interfaces, the wl_buffer interface is frozen at version 1.
-- @type wl_buffer
wau.wl_buffer:init {
    name = "wl_buffer",
    version = 1,
    methods = {
        --- destroy a buffer
        --
        -- Destroy a buffer. If and how you need to release the backing
        -- storage is defined by the buffer factory interface.
        -- For possible side-effects to a surface, see wl_surface.attach.
        -- @function wl_buffer:destroy
        -- @treturn wl_buffer self
        {
            name = "destroy",
            signature = "",
            types = { },
            type = "destructor"
        },
    },
    events = {
        --- compositor releases buffer
        --
        -- Sent when this wl_buffer is no longer used by the compositor.
        -- The client is now free to reuse or destroy this buffer and its
        -- backing storage.
        -- If a client receives a release event before the frame callback
        -- requested in the same wl_surface.commit that attaches this
        -- wl_buffer to a surface, then the client is immediately free to
        -- reuse the buffer and its backing storage, and does not need a
        -- second buffer for the next surface content update. Typically
        -- this is possible, when the compositor maintains a copy of the
        -- wl_surface contents, e.g. as a GL texture. This is an important
        -- optimization for GL(ES) compositors with wl_shm clients.
        -- @event wl_buffer:release
        {
            name = "release",
            signature = "",
            types = { },
        },
    },
    enums = {
    },
    methods_opcode = {
        ["destroy"] = 0,
    },
}

--- offer to transfer data
--
-- A wl_data_offer represents a piece of data offered for transfer
-- by another client (the source client).  It is used by the
-- copy-and-paste and drag-and-drop mechanisms.  The offer
-- describes the different mime types that the data can be
-- converted to and provides the mechanism for transferring the
-- data directly from the source client.
-- @type wl_data_offer
wau.wl_data_offer:init {
    name = "wl_data_offer",
    version = 3,
    methods = {
        --- accept one of the offered mime types
        --
        -- Indicate that the client can accept the given mime type, or
        -- NULL for not accepted.
        -- For objects of version 2 or older, this request is used by the
        -- client to give feedback whether the client can receive the given
        -- mime type, or NULL if none is accepted; the feedback does not
        -- determine whether the drag-and-drop operation succeeds or not.
        -- For objects of version 3 or newer, this request determines the
        -- final result of the drag-and-drop operation. If the end result
        -- is that no mime types were accepted, the drag-and-drop operation
        -- will be cancelled and the corresponding drag source will receive
        -- wl_data_source.cancelled. Clients may still use this event in
        -- conjunction with wl_data_source.action for feedback.
        -- @function wl_data_offer:accept
        -- @tparam uint serial serial number of the accept request
        -- @tparam string mime_type mime type accepted by the client
        -- @treturn wl_data_offer self
        {
            name = "accept",
            signature = "u?s",
            types = { 0, 0, },
        },
        --- request that the data is transferred
        --
        -- To transfer the offered data, the client issues this request
        -- and indicates the mime type it wants to receive.  The transfer
        -- happens through the passed file descriptor (typically created
        -- with the pipe system call).  The source client writes the data
        -- in the mime type representation requested and then closes the
        -- file descriptor.
        -- The receiving client reads from the read end of the pipe until
        -- EOF and then closes its end, at which point the transfer is
        -- complete.
        -- This request may happen multiple times for different mime types,
        -- both before and after wl_data_device.drop. Drag-and-drop destination
        -- clients may preemptively fetch data or examine it more closely to
        -- determine acceptance.
        -- @function wl_data_offer:receive
        -- @tparam string mime_type mime type desired by receiver
        -- @tparam fd fd file descriptor for data transfer
        -- @treturn wl_data_offer self
        {
            name = "receive",
            signature = "sh",
            types = { 0, 0, },
        },
        --- destroy data offer
        --
        -- Destroy the data offer.
        -- @function wl_data_offer:destroy
        -- @treturn wl_data_offer self
        {
            name = "destroy",
            signature = "",
            types = { },
            type = "destructor"
        },
        --- the offer will no longer be used
        --
        -- Notifies the compositor that the drag destination successfully
        -- finished the drag-and-drop operation.
        -- Upon receiving this request, the compositor will emit
        -- wl_data_source.dnd_finished on the drag source client.
        -- It is a client error to perform other requests than
        -- wl_data_offer.destroy after this one. It is also an error to perform
        -- this request after a NULL mime type has been set in
        -- wl_data_offer.accept or no action was received through
        -- wl_data_offer.action.
        -- If wl_data_offer.finish request is received for a non drag and drop
        -- operation, the invalid_finish protocol error is raised.
        -- @function wl_data_offer:finish
        -- @treturn wl_data_offer self
        {
            name = "finish",
            signature = "3",
            types = { },
        },
        --- set the available/preferred drag-and-drop actions
        --
        -- Sets the actions that the destination side client supports for
        -- this operation. This request may trigger the emission of
        -- wl_data_source.action and wl_data_offer.action events if the compositor
        -- needs to change the selected action.
        -- This request can be called multiple times throughout the
        -- drag-and-drop operation, typically in response to wl_data_device.enter
        -- or wl_data_device.motion events.
        -- This request determines the final result of the drag-and-drop
        -- operation. If the end result is that no action is accepted,
        -- the drag source will receive wl_data_source.cancelled.
        -- The dnd_actions argument must contain only values expressed in the
        -- wl_data_device_manager.dnd_actions enum, and the preferred_action
        -- argument must only contain one of those values set, otherwise it
        -- will result in a protocol error.
        -- While managing an "ask" action, the destination drag-and-drop client
        -- may perform further wl_data_offer.receive requests, and is expected
        -- to perform one last wl_data_offer.set_actions request with a preferred
        -- action other than "ask" (and optionally wl_data_offer.accept) before
        -- requesting wl_data_offer.finish, in order to convey the action selected
        -- by the user. If the preferred action is not in the
        -- wl_data_offer.source_actions mask, an error will be raised.
        -- If the "ask" action is dismissed (e.g. user cancellation), the client
        -- is expected to perform wl_data_offer.destroy right away.
        -- This request can only be made on drag-and-drop offers, a protocol error
        -- will be raised otherwise.
        -- @function wl_data_offer:set_actions
        -- @tparam uint dnd_actions actions supported by the destination client
        -- @tparam uint preferred_action action preferred by the destination client
        -- @treturn wl_data_offer self
        {
            name = "set_actions",
            signature = "3uu",
            types = { 0, 0, },
        },
    },
    events = {
        --- advertise offered mime type
        --
        -- Sent immediately after creating the wl_data_offer object.  One
        -- event per offered mime type.
        -- @event wl_data_offer:offer
        -- @tparam string mime_type offered mime type
        {
            name = "offer",
            signature = "s",
            types = { 0, },
        },
        --- notify the source-side available actions
        --
        -- This event indicates the actions offered by the data source. It
        -- will be sent immediately after creating the wl_data_offer object,
        -- or anytime the source side changes its offered actions through
        -- wl_data_source.set_actions.
        -- @event wl_data_offer:source_actions
        -- @tparam uint source_actions actions offered by the data source
        {
            name = "source_actions",
            signature = "3u",
            types = { 0, },
        },
        --- notify the selected action
        --
        -- This event indicates the action selected by the compositor after
        -- matching the source/destination side actions. Only one action (or
        -- none) will be offered here.
        -- This event can be emitted multiple times during the drag-and-drop
        -- operation in response to destination side action changes through
        -- wl_data_offer.set_actions.
        -- This event will no longer be emitted after wl_data_device.drop
        -- happened on the drag-and-drop destination, the client must
        -- honor the last action received, or the last preferred one set
        -- through wl_data_offer.set_actions when handling an "ask" action.
        -- Compositors may also change the selected action on the fly, mainly
        -- in response to keyboard modifier changes during the drag-and-drop
        -- operation.
        -- The most recent action received is always the valid one. Prior to
        -- receiving wl_data_device.drop, the chosen action may change (e.g.
        -- due to keyboard modifiers being pressed). At the time of receiving
        -- wl_data_device.drop the drag-and-drop destination must honor the
        -- last action received.
        -- Action changes may still happen after wl_data_device.drop,
        -- especially on "ask" actions, where the drag-and-drop destination
        -- may choose another action afterwards. Action changes happening
        -- at this stage are always the result of inter-client negotiation, the
        -- compositor shall no longer be able to induce a different action.
        -- Upon "ask" actions, it is expected that the drag-and-drop destination
        -- may potentially choose a different action and/or mime type,
        -- based on wl_data_offer.source_actions and finally chosen by the
        -- user (e.g. popping up a menu with the available options). The
        -- final wl_data_offer.set_actions and wl_data_offer.accept requests
        -- must happen before the call to wl_data_offer.finish.
        -- @event wl_data_offer:action
        -- @tparam uint dnd_action action selected by the compositor
        {
            name = "action",
            signature = "3u",
            types = { 0, },
        },
    },
    enums = {
        --- error
        -- @enum wl_data_offer.Error
        -- @param INVALID_FINISH 0 finish request was called untimely
        -- @param INVALID_ACTION_MASK 1 action mask contains invalid values
        -- @param INVALID_ACTION 2 action argument has an invalid value
        -- @param INVALID_OFFER 3 offer doesn't accept this request
        ["error"] = {
            ["invalid_finish"] = 0,
            ["invalid_action_mask"] = 1,
            ["invalid_action"] = 2,
            ["invalid_offer"] = 3,
        },
    },
    methods_opcode = {
        ["accept"] = 0,
        ["receive"] = 1,
        ["destroy"] = 2,
        ["finish"] = 3,
        ["set_actions"] = 4,
    },
}

--- offer to transfer data
--
-- The wl_data_source object is the source side of a wl_data_offer.
-- It is created by the source client in a data transfer and
-- provides a way to describe the offered data and a way to respond
-- to requests to transfer the data.
-- @type wl_data_source
wau.wl_data_source:init {
    name = "wl_data_source",
    version = 3,
    methods = {
        --- add an offered mime type
        --
        -- This request adds a mime type to the set of mime types
        -- advertised to targets.  Can be called several times to offer
        -- multiple types.
        -- @function wl_data_source:offer
        -- @tparam string mime_type mime type offered by the data source
        -- @treturn wl_data_source self
        {
            name = "offer",
            signature = "s",
            types = { 0, },
        },
        --- destroy the data source
        --
        -- Destroy the data source.
        -- @function wl_data_source:destroy
        -- @treturn wl_data_source self
        {
            name = "destroy",
            signature = "",
            types = { },
            type = "destructor"
        },
        --- set the available drag-and-drop actions
        --
        -- Sets the actions that the source side client supports for this
        -- operation. This request may trigger wl_data_source.action and
        -- wl_data_offer.action events if the compositor needs to change the
        -- selected action.
        -- The dnd_actions argument must contain only values expressed in the
        -- wl_data_device_manager.dnd_actions enum, otherwise it will result
        -- in a protocol error.
        -- This request must be made once only, and can only be made on sources
        -- used in drag-and-drop, so it must be performed before
        -- wl_data_device.start_drag. Attempting to use the source other than
        -- for drag-and-drop will raise a protocol error.
        -- @function wl_data_source:set_actions
        -- @tparam uint dnd_actions actions supported by the data source
        -- @treturn wl_data_source self
        {
            name = "set_actions",
            signature = "3u",
            types = { 0, },
        },
    },
    events = {
        --- a target accepts an offered mime type
        --
        -- Sent when a target accepts pointer_focus or motion events.  If
        -- a target does not accept any of the offered types, type is NULL.
        -- Used for feedback during drag-and-drop.
        -- @event wl_data_source:target
        -- @tparam string mime_type mime type accepted by the target
        {
            name = "target",
            signature = "?s",
            types = { 0, },
        },
        --- send the data
        --
        -- Request for data from the client.  Send the data as the
        -- specified mime type over the passed file descriptor, then
        -- close it.
        -- @event wl_data_source:send
        -- @tparam string mime_type mime type for the data
        -- @tparam fd fd file descriptor for the data
        {
            name = "send",
            signature = "sh",
            types = { 0, 0, },
        },
        --- selection was cancelled
        --
        -- This data source is no longer valid. There are several reasons why
        -- this could happen:
        -- - The data source has been replaced by another data source.
        -- - The drag-and-drop operation was performed, but the drop destination
        -- did not accept any of the mime types offered through
        -- wl_data_source.target.
        -- - The drag-and-drop operation was performed, but the drop destination
        -- did not select any of the actions present in the mask offered through
        -- wl_data_source.action.
        -- - The drag-and-drop operation was performed but didn't happen over a
        -- surface.
        -- - The compositor cancelled the drag-and-drop operation (e.g. compositor
        -- dependent timeouts to avoid stale drag-and-drop transfers).
        -- The client should clean up and destroy this data source.
        -- For objects of version 2 or older, wl_data_source.cancelled will
        -- only be emitted if the data source was replaced by another data
        -- source.
        -- @event wl_data_source:cancelled
        {
            name = "cancelled",
            signature = "",
            types = { },
        },
        --- the drag-and-drop operation physically finished
        --
        -- The user performed the drop action. This event does not indicate
        -- acceptance, wl_data_source.cancelled may still be emitted afterwards
        -- if the drop destination does not accept any mime type.
        -- However, this event might however not be received if the compositor
        -- cancelled the drag-and-drop operation before this event could happen.
        -- Note that the data_source may still be used in the future and should
        -- not be destroyed here.
        -- @event wl_data_source:dnd_drop_performed
        {
            name = "dnd_drop_performed",
            signature = "3",
            types = { },
        },
        --- the drag-and-drop operation concluded
        --
        -- The drop destination finished interoperating with this data
        -- source, so the client is now free to destroy this data source and
        -- free all associated data.
        -- If the action used to perform the operation was "move", the
        -- source can now delete the transferred data.
        -- @event wl_data_source:dnd_finished
        {
            name = "dnd_finished",
            signature = "3",
            types = { },
        },
        --- notify the selected action
        --
        -- This event indicates the action selected by the compositor after
        -- matching the source/destination side actions. Only one action (or
        -- none) will be offered here.
        -- This event can be emitted multiple times during the drag-and-drop
        -- operation, mainly in response to destination side changes through
        -- wl_data_offer.set_actions, and as the data device enters/leaves
        -- surfaces.
        -- It is only possible to receive this event after
        -- wl_data_source.dnd_drop_performed if the drag-and-drop operation
        -- ended in an "ask" action, in which case the final wl_data_source.action
        -- event will happen immediately before wl_data_source.dnd_finished.
        -- Compositors may also change the selected action on the fly, mainly
        -- in response to keyboard modifier changes during the drag-and-drop
        -- operation.
        -- The most recent action received is always the valid one. The chosen
        -- action may change alongside negotiation (e.g. an "ask" action can turn
        -- into a "move" operation), so the effects of the final action must
        -- always be applied in wl_data_offer.dnd_finished.
        -- Clients can trigger cursor surface changes from this point, so
        -- they reflect the current action.
        -- @event wl_data_source:action
        -- @tparam uint dnd_action action selected by the compositor
        {
            name = "action",
            signature = "3u",
            types = { 0, },
        },
    },
    enums = {
        --- error
        -- @enum wl_data_source.Error
        -- @param INVALID_ACTION_MASK 0 action mask contains invalid values
        -- @param INVALID_SOURCE 1 source doesn't accept this request
        ["error"] = {
            ["invalid_action_mask"] = 0,
            ["invalid_source"] = 1,
        },
    },
    methods_opcode = {
        ["offer"] = 0,
        ["destroy"] = 1,
        ["set_actions"] = 2,
    },
}

--- data transfer device
--
-- There is one wl_data_device per seat which can be obtained
-- from the global wl_data_device_manager singleton.
-- A wl_data_device provides access to inter-client data transfer
-- mechanisms such as copy-and-paste and drag-and-drop.
-- @type wl_data_device
wau.wl_data_device:init {
    name = "wl_data_device",
    version = 3,
    methods = {
        --- start drag-and-drop operation
        --
        -- This request asks the compositor to start a drag-and-drop
        -- operation on behalf of the client.
        -- The source argument is the data source that provides the data
        -- for the eventual data transfer. If source is NULL, enter, leave
        -- and motion events are sent only to the client that initiated the
        -- drag and the client is expected to handle the data passing
        -- internally. If source is destroyed, the drag-and-drop session will be
        -- cancelled.
        -- The origin surface is the surface where the drag originates and
        -- the client must have an active implicit grab that matches the
        -- serial.
        -- The icon surface is an optional (can be NULL) surface that
        -- provides an icon to be moved around with the cursor.  Initially,
        -- the top-left corner of the icon surface is placed at the cursor
        -- hotspot, but subsequent wl_surface.attach request can move the
        -- relative position. Attach requests must be confirmed with
        -- wl_surface.commit as usual. The icon surface is given the role of
        -- a drag-and-drop icon. If the icon surface already has another role,
        -- it raises a protocol error.
        -- The input region is ignored for wl_surfaces with the role of a
        -- drag-and-drop icon.
        -- The given source may not be used in any further set_selection or
        -- start_drag requests. Attempting to reuse a previously-used source
        -- may send a used_source error.
        -- @function wl_data_device:start_drag
        -- @tparam wl_data_source source data source for the eventual transfer
        -- @tparam wl_surface origin surface where the drag originates
        -- @tparam wl_surface icon drag-and-drop icon surface
        -- @tparam uint serial serial number of the implicit grab on the origin
        -- @treturn wl_data_device self
        {
            name = "start_drag",
            signature = "?oo?ou",
            types = { wau.wl_data_source, wau.wl_surface, wau.wl_surface, 0, },
        },
        --- copy data to the selection
        --
        -- This request asks the compositor to set the selection
        -- to the data from the source on behalf of the client.
        -- To unset the selection, set the source to NULL.
        -- The given source may not be used in any further set_selection or
        -- start_drag requests. Attempting to reuse a previously-used source
        -- may send a used_source error.
        -- @function wl_data_device:set_selection
        -- @tparam wl_data_source source data source for the selection
        -- @tparam uint serial serial number of the event that triggered this request
        -- @treturn wl_data_device self
        {
            name = "set_selection",
            signature = "?ou",
            types = { wau.wl_data_source, 0, },
        },
        --- destroy data device
        --
        -- This request destroys the data device.
        -- @function wl_data_device:release
        -- @treturn wl_data_device self
        {
            name = "release",
            signature = "2",
            types = { },
            type = "destructor"
        },
    },
    events = {
        --- introduce a new wl_data_offer
        --
        -- The data_offer event introduces a new wl_data_offer object,
        -- which will subsequently be used in either the
        -- data_device.enter event (for drag-and-drop) or the
        -- data_device.selection event (for selections).  Immediately
        -- following the data_device.data_offer event, the new data_offer
        -- object will send out data_offer.offer events to describe the
        -- mime types it offers.
        -- @event wl_data_device:data_offer
        -- @tparam wl_data_offer id the new data_offer object
        {
            name = "data_offer",
            signature = "n",
            types = { wau.wl_data_offer, },
        },
        --- initiate drag-and-drop session
        --
        -- This event is sent when an active drag-and-drop pointer enters
        -- a surface owned by the client.  The position of the pointer at
        -- enter time is provided by the x and y arguments, in surface-local
        -- coordinates.
        -- @event wl_data_device:enter
        -- @tparam uint serial serial number of the enter event
        -- @tparam wl_surface surface client surface entered
        -- @tparam fixed x surface-local x coordinate
        -- @tparam fixed y surface-local y coordinate
        -- @tparam wl_data_offer id source data_offer object
        {
            name = "enter",
            signature = "uoff?o",
            types = { 0, wau.wl_surface, 0, 0, wau.wl_data_offer, },
        },
        --- end drag-and-drop session
        --
        -- This event is sent when the drag-and-drop pointer leaves the
        -- surface and the session ends.  The client must destroy the
        -- wl_data_offer introduced at enter time at this point.
        -- @event wl_data_device:leave
        {
            name = "leave",
            signature = "",
            types = { },
        },
        --- drag-and-drop session motion
        --
        -- This event is sent when the drag-and-drop pointer moves within
        -- the currently focused surface. The new position of the pointer
        -- is provided by the x and y arguments, in surface-local
        -- coordinates.
        -- @event wl_data_device:motion
        -- @tparam uint time timestamp with millisecond granularity
        -- @tparam fixed x surface-local x coordinate
        -- @tparam fixed y surface-local y coordinate
        {
            name = "motion",
            signature = "uff",
            types = { 0, 0, 0, },
        },
        --- end drag-and-drop session successfully
        --
        -- The event is sent when a drag-and-drop operation is ended
        -- because the implicit grab is removed.
        -- The drag-and-drop destination is expected to honor the last action
        -- received through wl_data_offer.action, if the resulting action is
        -- "copy" or "move", the destination can still perform
        -- wl_data_offer.receive requests, and is expected to end all
        -- transfers with a wl_data_offer.finish request.
        -- If the resulting action is "ask", the action will not be considered
        -- final. The drag-and-drop destination is expected to perform one last
        -- wl_data_offer.set_actions request, or wl_data_offer.destroy in order
        -- to cancel the operation.
        -- @event wl_data_device:drop
        {
            name = "drop",
            signature = "",
            types = { },
        },
        --- advertise new selection
        --
        -- The selection event is sent out to notify the client of a new
        -- wl_data_offer for the selection for this device.  The
        -- data_device.data_offer and the data_offer.offer events are
        -- sent out immediately before this event to introduce the data
        -- offer object.  The selection event is sent to a client
        -- immediately before receiving keyboard focus and when a new
        -- selection is set while the client has keyboard focus.  The
        -- data_offer is valid until a new data_offer or NULL is received
        -- or until the client loses keyboard focus.  Switching surface with
        -- keyboard focus within the same client doesn't mean a new selection
        -- will be sent.  The client must destroy the previous selection
        -- data_offer, if any, upon receiving this event.
        -- @event wl_data_device:selection
        -- @tparam wl_data_offer id selection data_offer object
        {
            name = "selection",
            signature = "?o",
            types = { wau.wl_data_offer, },
        },
    },
    enums = {
        --- error
        -- @enum wl_data_device.Error
        -- @param ROLE 0 given wl_surface has another role
        -- @param USED_SOURCE 1 source has already been used
        ["error"] = {
            ["role"] = 0,
            ["used_source"] = 1,
        },
    },
    methods_opcode = {
        ["start_drag"] = 0,
        ["set_selection"] = 1,
        ["release"] = 2,
    },
}

--- data transfer interface
--
-- The wl_data_device_manager is a singleton global object that
-- provides access to inter-client data transfer mechanisms such as
-- copy-and-paste and drag-and-drop.  These mechanisms are tied to
-- a wl_seat and this interface lets a client get a wl_data_device
-- corresponding to a wl_seat.
-- Depending on the version bound, the objects created from the bound
-- wl_data_device_manager object will have different requirements for
-- functioning properly. See wl_data_source.set_actions,
-- wl_data_offer.accept and wl_data_offer.finish for details.
-- @type wl_data_device_manager
wau.wl_data_device_manager:init {
    name = "wl_data_device_manager",
    version = 3,
    methods = {
        --- create a new data source
        --
        -- Create a new data source.
        -- @function wl_data_device_manager:create_data_source
        -- @treturn wl_data_source
        {
            name = "create_data_source",
            signature = "n",
            types = { wau.wl_data_source, },
        },
        --- create a new data device
        --
        -- Create a new data device for a given seat.
        -- @function wl_data_device_manager:get_data_device
        -- @treturn wl_data_device
        -- @tparam wl_seat seat seat associated with the data device
        {
            name = "get_data_device",
            signature = "no",
            types = { wau.wl_data_device, wau.wl_seat, },
        },
    },
    events = {
    },
    enums = {
        --- drag and drop actions
        --
        -- This is a bitmask of the available/preferred actions in a
        -- drag-and-drop operation.
        -- In the compositor, the selected action is a result of matching the
        -- actions offered by the source and destination sides.  "action" events
        -- with a "none" action will be sent to both source and destination if
        -- there is no match. All further checks will effectively happen on
        -- (source actions ∩ destination actions).
        -- In addition, compositors may also pick different actions in
        -- reaction to key modifiers being pressed. One common design that
        -- is used in major toolkits (and the behavior recommended for
        -- compositors) is:
        -- - If no modifiers are pressed, the first match (in bit order)
        -- will be used.
        -- - Pressing Shift selects "move", if enabled in the mask.
        -- - Pressing Control selects "copy", if enabled in the mask.
        -- Behavior beyond that is considered implementation-dependent.
        -- Compositors may for example bind other modifiers (like Alt/Meta)
        -- or drags initiated with other buttons than BTN_LEFT to specific
        -- actions (e.g. "ask").
        -- @enum wl_data_device_manager.DndAction
        -- @param NONE 0 no action
        -- @param COPY 1 copy action
        -- @param MOVE 2 move action
        -- @param ASK 4 ask action
        ["dnd_action"] = {
            ["none"] = 0,
            ["copy"] = 1,
            ["move"] = 2,
            ["ask"] = 4,
        },
    },
    methods_opcode = {
        ["create_data_source"] = 0,
        ["get_data_device"] = 1,
    },
}

--- create desktop-style surfaces
--
-- This interface is implemented by servers that provide
-- desktop-style user interfaces.
-- It allows clients to associate a wl_shell_surface with
-- a basic surface.
-- Note! This protocol is deprecated and not intended for production use.
-- For desktop-style user interfaces, use xdg_shell. Compositors and clients
-- should not implement this interface.
-- @type wl_shell
wau.wl_shell:init {
    name = "wl_shell",
    version = 1,
    methods = {
        --- create a shell surface from a surface
        --
        -- Create a shell surface for an existing surface. This gives
        -- the wl_surface the role of a shell surface. If the wl_surface
        -- already has another role, it raises a protocol error.
        -- Only one shell surface can be associated with a given surface.
        -- @function wl_shell:get_shell_surface
        -- @treturn wl_shell_surface
        -- @tparam wl_surface surface surface to be given the shell surface role
        {
            name = "get_shell_surface",
            signature = "no",
            types = { wau.wl_shell_surface, wau.wl_surface, },
        },
    },
    events = {
    },
    enums = {
        --- error
        -- @enum wl_shell.Error
        -- @param ROLE 0 given wl_surface has another role
        ["error"] = {
            ["role"] = 0,
        },
    },
    methods_opcode = {
        ["get_shell_surface"] = 0,
    },
}

--- desktop-style metadata interface
--
-- An interface that may be implemented by a wl_surface, for
-- implementations that provide a desktop-style user interface.
-- It provides requests to treat surfaces like toplevel, fullscreen
-- or popup windows, move, resize or maximize them, associate
-- metadata like title and class, etc.
-- On the server side the object is automatically destroyed when
-- the related wl_surface is destroyed. On the client side,
-- wl_shell_surface_destroy() must be called before destroying
-- the wl_surface object.
-- @type wl_shell_surface
wau.wl_shell_surface:init {
    name = "wl_shell_surface",
    version = 1,
    methods = {
        --- respond to a ping event
        --
        -- A client must respond to a ping event with a pong request or
        -- the client may be deemed unresponsive.
        -- @function wl_shell_surface:pong
        -- @tparam uint serial serial number of the ping event
        -- @treturn wl_shell_surface self
        {
            name = "pong",
            signature = "u",
            types = { 0, },
        },
        --- start an interactive move
        --
        -- Start a pointer-driven move of the surface.
        -- This request must be used in response to a button press event.
        -- The server may ignore move requests depending on the state of
        -- the surface (e.g. fullscreen or maximized).
        -- @function wl_shell_surface:move
        -- @tparam wl_seat seat seat whose pointer is used
        -- @tparam uint serial serial number of the implicit grab on the pointer
        -- @treturn wl_shell_surface self
        {
            name = "move",
            signature = "ou",
            types = { wau.wl_seat, 0, },
        },
        --- start an interactive resize
        --
        -- Start a pointer-driven resizing of the surface.
        -- This request must be used in response to a button press event.
        -- The server may ignore resize requests depending on the state of
        -- the surface (e.g. fullscreen or maximized).
        -- @function wl_shell_surface:resize
        -- @tparam wl_seat seat seat whose pointer is used
        -- @tparam uint serial serial number of the implicit grab on the pointer
        -- @tparam uint edges which edge or corner is being dragged
        -- @treturn wl_shell_surface self
        {
            name = "resize",
            signature = "ouu",
            types = { wau.wl_seat, 0, 0, },
        },
        --- make the surface a toplevel surface
        --
        -- Map the surface as a toplevel surface.
        -- A toplevel surface is not fullscreen, maximized or transient.
        -- @function wl_shell_surface:set_toplevel
        -- @treturn wl_shell_surface self
        {
            name = "set_toplevel",
            signature = "",
            types = { },
        },
        --- make the surface a transient surface
        --
        -- Map the surface relative to an existing surface.
        -- The x and y arguments specify the location of the upper left
        -- corner of the surface relative to the upper left corner of the
        -- parent surface, in surface-local coordinates.
        -- The flags argument controls details of the transient behaviour.
        -- @function wl_shell_surface:set_transient
        -- @tparam wl_surface parent parent surface
        -- @tparam int x surface-local x coordinate
        -- @tparam int y surface-local y coordinate
        -- @tparam uint flags transient surface behavior
        -- @treturn wl_shell_surface self
        {
            name = "set_transient",
            signature = "oiiu",
            types = { wau.wl_surface, 0, 0, 0, },
        },
        --- make the surface a fullscreen surface
        --
        -- Map the surface as a fullscreen surface.
        -- If an output parameter is given then the surface will be made
        -- fullscreen on that output. If the client does not specify the
        -- output then the compositor will apply its policy - usually
        -- choosing the output on which the surface has the biggest surface
        -- area.
        -- The client may specify a method to resolve a size conflict
        -- between the output size and the surface size - this is provided
        -- through the method parameter.
        -- The framerate parameter is used only when the method is set
        -- to "driver", to indicate the preferred framerate. A value of 0
        -- indicates that the client does not care about framerate.  The
        -- framerate is specified in mHz, that is framerate of 60000 is 60Hz.
        -- A method of "scale" or "driver" implies a scaling operation of
        -- the surface, either via a direct scaling operation or a change of
        -- the output mode. This will override any kind of output scaling, so
        -- that mapping a surface with a buffer size equal to the mode can
        -- fill the screen independent of buffer_scale.
        -- A method of "fill" means we don't scale up the buffer, however
        -- any output scale is applied. This means that you may run into
        -- an edge case where the application maps a buffer with the same
        -- size of the output mode but buffer_scale 1 (thus making a
        -- surface larger than the output). In this case it is allowed to
        -- downscale the results to fit the screen.
        -- The compositor must reply to this request with a configure event
        -- with the dimensions for the output on which the surface will
        -- be made fullscreen.
        -- @function wl_shell_surface:set_fullscreen
        -- @tparam uint method method for resolving size conflict
        -- @tparam uint framerate framerate in mHz
        -- @tparam wl_output output output on which the surface is to be fullscreen
        -- @treturn wl_shell_surface self
        {
            name = "set_fullscreen",
            signature = "uu?o",
            types = { 0, 0, wau.wl_output, },
        },
        --- make the surface a popup surface
        --
        -- Map the surface as a popup.
        -- A popup surface is a transient surface with an added pointer
        -- grab.
        -- An existing implicit grab will be changed to owner-events mode,
        -- and the popup grab will continue after the implicit grab ends
        -- (i.e. releasing the mouse button does not cause the popup to
        -- be unmapped).
        -- The popup grab continues until the window is destroyed or a
        -- mouse button is pressed in any other client's window. A click
        -- in any of the client's surfaces is reported as normal, however,
        -- clicks in other clients' surfaces will be discarded and trigger
        -- the callback.
        -- The x and y arguments specify the location of the upper left
        -- corner of the surface relative to the upper left corner of the
        -- parent surface, in surface-local coordinates.
        -- @function wl_shell_surface:set_popup
        -- @tparam wl_seat seat seat whose pointer is used
        -- @tparam uint serial serial number of the implicit grab on the pointer
        -- @tparam wl_surface parent parent surface
        -- @tparam int x surface-local x coordinate
        -- @tparam int y surface-local y coordinate
        -- @tparam uint flags transient surface behavior
        -- @treturn wl_shell_surface self
        {
            name = "set_popup",
            signature = "ouoiiu",
            types = { wau.wl_seat, 0, wau.wl_surface, 0, 0, 0, },
        },
        --- make the surface a maximized surface
        --
        -- Map the surface as a maximized surface.
        -- If an output parameter is given then the surface will be
        -- maximized on that output. If the client does not specify the
        -- output then the compositor will apply its policy - usually
        -- choosing the output on which the surface has the biggest surface
        -- area.
        -- The compositor will reply with a configure event telling
        -- the expected new surface size. The operation is completed
        -- on the next buffer attach to this surface.
        -- A maximized surface typically fills the entire output it is
        -- bound to, except for desktop elements such as panels. This is
        -- the main difference between a maximized shell surface and a
        -- fullscreen shell surface.
        -- The details depend on the compositor implementation.
        -- @function wl_shell_surface:set_maximized
        -- @tparam wl_output output output on which the surface is to be maximized
        -- @treturn wl_shell_surface self
        {
            name = "set_maximized",
            signature = "?o",
            types = { wau.wl_output, },
        },
        --- set surface title
        --
        -- Set a short title for the surface.
        -- This string may be used to identify the surface in a task bar,
        -- window list, or other user interface elements provided by the
        -- compositor.
        -- The string must be encoded in UTF-8.
        -- @function wl_shell_surface:set_title
        -- @tparam string title surface title
        -- @treturn wl_shell_surface self
        {
            name = "set_title",
            signature = "s",
            types = { 0, },
        },
        --- set surface class
        --
        -- Set a class for the surface.
        -- The surface class identifies the general class of applications
        -- to which the surface belongs. A common convention is to use the
        -- file name (or the full path if it is a non-standard location) of
        -- the application's .desktop file as the class.
        -- @function wl_shell_surface:set_class
        -- @tparam string class_ surface class
        -- @treturn wl_shell_surface self
        {
            name = "set_class",
            signature = "s",
            types = { 0, },
        },
    },
    events = {
        --- ping client
        --
        -- Ping a client to check if it is receiving events and sending
        -- requests. A client is expected to reply with a pong request.
        -- @event wl_shell_surface:ping
        -- @tparam uint serial serial number of the ping
        {
            name = "ping",
            signature = "u",
            types = { 0, },
        },
        --- suggest resize
        --
        -- The configure event asks the client to resize its surface.
        -- The size is a hint, in the sense that the client is free to
        -- ignore it if it doesn't resize, pick a smaller size (to
        -- satisfy aspect ratio or resize in steps of NxM pixels).
        -- The edges parameter provides a hint about how the surface
        -- was resized. The client may use this information to decide
        -- how to adjust its content to the new size (e.g. a scrolling
        -- area might adjust its content position to leave the viewable
        -- content unmoved).
        -- The client is free to dismiss all but the last configure
        -- event it received.
        -- The width and height arguments specify the size of the window
        -- in surface-local coordinates.
        -- @event wl_shell_surface:configure
        -- @tparam uint edges how the surface was resized
        -- @tparam int width new width of the surface
        -- @tparam int height new height of the surface
        {
            name = "configure",
            signature = "uii",
            types = { 0, 0, 0, },
        },
        --- popup interaction is done
        --
        -- The popup_done event is sent out when a popup grab is broken,
        -- that is, when the user clicks a surface that doesn't belong
        -- to the client owning the popup surface.
        -- @event wl_shell_surface:popup_done
        {
            name = "popup_done",
            signature = "",
            types = { },
        },
    },
    enums = {
        --- edge values for resizing
        --
        -- These values are used to indicate which edge of a surface
        -- is being dragged in a resize operation. The server may
        -- use this information to adapt its behavior, e.g. choose
        -- an appropriate cursor image.
        -- @enum wl_shell_surface.Resize
        -- @param NONE 0 no edge
        -- @param TOP 1 top edge
        -- @param BOTTOM 2 bottom edge
        -- @param LEFT 4 left edge
        -- @param TOP_LEFT 5 top and left edges
        -- @param BOTTOM_LEFT 6 bottom and left edges
        -- @param RIGHT 8 right edge
        -- @param TOP_RIGHT 9 top and right edges
        -- @param BOTTOM_RIGHT 10 bottom and right edges
        ["resize"] = {
            ["none"] = 0,
            ["top"] = 1,
            ["bottom"] = 2,
            ["left"] = 4,
            ["top_left"] = 5,
            ["bottom_left"] = 6,
            ["right"] = 8,
            ["top_right"] = 9,
            ["bottom_right"] = 10,
        },
        --- details of transient behaviour
        --
        -- These flags specify details of the expected behaviour
        -- of transient surfaces. Used in the set_transient request.
        -- @enum wl_shell_surface.Transient
        -- @param INACTIVE 0x1 do not set keyboard focus
        ["transient"] = {
            ["inactive"] = 0x1,
        },
        --- different method to set the surface fullscreen
        --
        -- Hints to indicate to the compositor how to deal with a conflict
        -- between the dimensions of the surface and the dimensions of the
        -- output. The compositor is free to ignore this parameter.
        -- @enum wl_shell_surface.FullscreenMethod
        -- @param DEFAULT 0 no preference, apply default policy
        -- @param SCALE 1 scale, preserve the surface's aspect ratio and center on output
        -- @param DRIVER 2 switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
        -- @param FILL 3 no upscaling, center on output and add black borders to compensate size mismatch
        ["fullscreen_method"] = {
            ["default"] = 0,
            ["scale"] = 1,
            ["driver"] = 2,
            ["fill"] = 3,
        },
    },
    methods_opcode = {
        ["pong"] = 0,
        ["move"] = 1,
        ["resize"] = 2,
        ["set_toplevel"] = 3,
        ["set_transient"] = 4,
        ["set_fullscreen"] = 5,
        ["set_popup"] = 6,
        ["set_maximized"] = 7,
        ["set_title"] = 8,
        ["set_class"] = 9,
    },
}

--- an onscreen surface
--
-- A surface is a rectangular area that may be displayed on zero
-- or more outputs, and shown any number of times at the compositor's
-- discretion. They can present wl_buffers, receive user input, and
-- define a local coordinate system.
-- The size of a surface (and relative positions on it) is described
-- in surface-local coordinates, which may differ from the buffer
-- coordinates of the pixel content, in case a buffer_transform
-- or a buffer_scale is used.
-- A surface without a "role" is fairly useless: a compositor does
-- not know where, when or how to present it. The role is the
-- purpose of a wl_surface. Examples of roles are a cursor for a
-- pointer (as set by wl_pointer.set_cursor), a drag icon
-- (wl_data_device.start_drag), a sub-surface
-- (wl_subcompositor.get_subsurface), and a window as defined by a
-- shell protocol (e.g. wl_shell.get_shell_surface).
-- A surface can have only one role at a time. Initially a
-- wl_surface does not have a role. Once a wl_surface is given a
-- role, it is set permanently for the whole lifetime of the
-- wl_surface object. Giving the current role again is allowed,
-- unless explicitly forbidden by the relevant interface
-- specification.
-- Surface roles are given by requests in other interfaces such as
-- wl_pointer.set_cursor. The request should explicitly mention
-- that this request gives a role to a wl_surface. Often, this
-- request also creates a new protocol object that represents the
-- role and adds additional functionality to wl_surface. When a
-- client wants to destroy a wl_surface, they must destroy this role
-- object before the wl_surface, otherwise a defunct_role_object error is
-- sent.
-- Destroying the role object does not remove the role from the
-- wl_surface, but it may stop the wl_surface from "playing the role".
-- For instance, if a wl_subsurface object is destroyed, the wl_surface
-- it was created for will be unmapped and forget its position and
-- z-order. It is allowed to create a wl_subsurface for the same
-- wl_surface again, but it is not allowed to use the wl_surface as
-- a cursor (cursor is a different role than sub-surface, and role
-- switching is not allowed).
-- @type wl_surface
wau.wl_surface:init {
    name = "wl_surface",
    version = 6,
    methods = {
        --- delete surface
        --
        -- Deletes the surface and invalidates its object ID.
        -- @function wl_surface:destroy
        -- @treturn wl_surface self
        {
            name = "destroy",
            signature = "",
            types = { },
            type = "destructor"
        },
        --- set the surface contents
        --
        -- Set a buffer as the content of this surface.
        -- The new size of the surface is calculated based on the buffer
        -- size transformed by the inverse buffer_transform and the
        -- inverse buffer_scale. This means that at commit time the supplied
        -- buffer size must be an integer multiple of the buffer_scale. If
        -- that's not the case, an invalid_size error is sent.
        -- The x and y arguments specify the location of the new pending
        -- buffer's upper left corner, relative to the current buffer's upper
        -- left corner, in surface-local coordinates. In other words, the
        -- x and y, combined with the new surface size define in which
        -- directions the surface's size changes. Setting anything other than 0
        -- as x and y arguments is discouraged, and should instead be replaced
        -- with using the separate wl_surface.offset request.
        -- When the bound wl_surface version is 5 or higher, passing any
        -- non-zero x or y is a protocol violation, and will result in an
        -- 'invalid_offset' error being raised. The x and y arguments are ignored
        -- and do not change the pending state. To achieve equivalent semantics,
        -- use wl_surface.offset.
        -- Surface contents are double-buffered state, see wl_surface.commit.
        -- The initial surface contents are void; there is no content.
        -- wl_surface.attach assigns the given wl_buffer as the pending
        -- wl_buffer. wl_surface.commit makes the pending wl_buffer the new
        -- surface contents, and the size of the surface becomes the size
        -- calculated from the wl_buffer, as described above. After commit,
        -- there is no pending buffer until the next attach.
        -- Committing a pending wl_buffer allows the compositor to read the
        -- pixels in the wl_buffer. The compositor may access the pixels at
        -- any time after the wl_surface.commit request. When the compositor
        -- will not access the pixels anymore, it will send the
        -- wl_buffer.release event. Only after receiving wl_buffer.release,
        -- the client may reuse the wl_buffer. A wl_buffer that has been
        -- attached and then replaced by another attach instead of committed
        -- will not receive a release event, and is not used by the
        -- compositor.
        -- If a pending wl_buffer has been committed to more than one wl_surface,
        -- the delivery of wl_buffer.release events becomes undefined. A well
        -- behaved client should not rely on wl_buffer.release events in this
        -- case. Alternatively, a client could create multiple wl_buffer objects
        -- from the same backing storage or use wp_linux_buffer_release.
        -- Destroying the wl_buffer after wl_buffer.release does not change
        -- the surface contents. Destroying the wl_buffer before wl_buffer.release
        -- is allowed as long as the underlying buffer storage isn't re-used (this
        -- can happen e.g. on client process termination). However, if the client
        -- destroys the wl_buffer before receiving the wl_buffer.release event and
        -- mutates the underlying buffer storage, the surface contents become
        -- undefined immediately.
        -- If wl_surface.attach is sent with a NULL wl_buffer, the
        -- following wl_surface.commit will remove the surface content.
        -- @function wl_surface:attach
        -- @tparam wl_buffer buffer buffer of surface contents
        -- @tparam int x surface-local x coordinate
        -- @tparam int y surface-local y coordinate
        -- @treturn wl_surface self
        {
            name = "attach",
            signature = "?oii",
            types = { wau.wl_buffer, 0, 0, },
        },
        --- mark part of the surface damaged
        --
        -- This request is used to describe the regions where the pending
        -- buffer is different from the current surface contents, and where
        -- the surface therefore needs to be repainted. The compositor
        -- ignores the parts of the damage that fall outside of the surface.
        -- Damage is double-buffered state, see wl_surface.commit.
        -- The damage rectangle is specified in surface-local coordinates,
        -- where x and y specify the upper left corner of the damage rectangle.
        -- The initial value for pending damage is empty: no damage.
        -- wl_surface.damage adds pending damage: the new pending damage
        -- is the union of old pending damage and the given rectangle.
        -- wl_surface.commit assigns pending damage as the current damage,
        -- and clears pending damage. The server will clear the current
        -- damage as it repaints the surface.
        -- Note! New clients should not use this request. Instead damage can be
        -- posted with wl_surface.damage_buffer which uses buffer coordinates
        -- instead of surface coordinates.
        -- @function wl_surface:damage
        -- @tparam int x surface-local x coordinate
        -- @tparam int y surface-local y coordinate
        -- @tparam int width width of damage rectangle
        -- @tparam int height height of damage rectangle
        -- @treturn wl_surface self
        {
            name = "damage",
            signature = "iiii",
            types = { 0, 0, 0, 0, },
        },
        --- request a frame throttling hint
        --
        -- Request a notification when it is a good time to start drawing a new
        -- frame, by creating a frame callback. This is useful for throttling
        -- redrawing operations, and driving animations.
        -- When a client is animating on a wl_surface, it can use the 'frame'
        -- request to get notified when it is a good time to draw and commit the
        -- next frame of animation. If the client commits an update earlier than
        -- that, it is likely that some updates will not make it to the display,
        -- and the client is wasting resources by drawing too often.
        -- The frame request will take effect on the next wl_surface.commit.
        -- The notification will only be posted for one frame unless
        -- requested again. For a wl_surface, the notifications are posted in
        -- the order the frame requests were committed.
        -- The server must send the notifications so that a client
        -- will not send excessive updates, while still allowing
        -- the highest possible update rate for clients that wait for the reply
        -- before drawing again. The server should give some time for the client
        -- to draw and commit after sending the frame callback events to let it
        -- hit the next output refresh.
        -- A server should avoid signaling the frame callbacks if the
        -- surface is not visible in any way, e.g. the surface is off-screen,
        -- or completely obscured by other opaque surfaces.
        -- The object returned by this request will be destroyed by the
        -- compositor after the callback is fired and as such the client must not
        -- attempt to use it after that point.
        -- The callback_data passed in the callback is the current time, in
        -- milliseconds, with an undefined base.
        -- @function wl_surface:frame
        -- @treturn wl_callback
        {
            name = "frame",
            signature = "n",
            types = { wau.wl_callback, },
        },
        --- set opaque region
        --
        -- This request sets the region of the surface that contains
        -- opaque content.
        -- The opaque region is an optimization hint for the compositor
        -- that lets it optimize the redrawing of content behind opaque
        -- regions.  Setting an opaque region is not required for correct
        -- behaviour, but marking transparent content as opaque will result
        -- in repaint artifacts.
        -- The opaque region is specified in surface-local coordinates.
        -- The compositor ignores the parts of the opaque region that fall
        -- outside of the surface.
        -- Opaque region is double-buffered state, see wl_surface.commit.
        -- wl_surface.set_opaque_region changes the pending opaque region.
        -- wl_surface.commit copies the pending region to the current region.
        -- Otherwise, the pending and current regions are never changed.
        -- The initial value for an opaque region is empty. Setting the pending
        -- opaque region has copy semantics, and the wl_region object can be
        -- destroyed immediately. A NULL wl_region causes the pending opaque
        -- region to be set to empty.
        -- @function wl_surface:set_opaque_region
        -- @tparam wl_region region opaque region of the surface
        -- @treturn wl_surface self
        {
            name = "set_opaque_region",
            signature = "?o",
            types = { wau.wl_region, },
        },
        --- set input region
        --
        -- This request sets the region of the surface that can receive
        -- pointer and touch events.
        -- Input events happening outside of this region will try the next
        -- surface in the server surface stack. The compositor ignores the
        -- parts of the input region that fall outside of the surface.
        -- The input region is specified in surface-local coordinates.
        -- Input region is double-buffered state, see wl_surface.commit.
        -- wl_surface.set_input_region changes the pending input region.
        -- wl_surface.commit copies the pending region to the current region.
        -- Otherwise the pending and current regions are never changed,
        -- except cursor and icon surfaces are special cases, see
        -- wl_pointer.set_cursor and wl_data_device.start_drag.
        -- The initial value for an input region is infinite. That means the
        -- whole surface will accept input. Setting the pending input region
        -- has copy semantics, and the wl_region object can be destroyed
        -- immediately. A NULL wl_region causes the input region to be set
        -- to infinite.
        -- @function wl_surface:set_input_region
        -- @tparam wl_region region input region of the surface
        -- @treturn wl_surface self
        {
            name = "set_input_region",
            signature = "?o",
            types = { wau.wl_region, },
        },
        --- commit pending surface state
        --
        -- Surface state (input, opaque, and damage regions, attached buffers,
        -- etc.) is double-buffered. Protocol requests modify the pending state,
        -- as opposed to the current state in use by the compositor. A commit
        -- request atomically applies all pending state, replacing the current
        -- state. After commit, the new pending state is as documented for each
        -- related request.
        -- On commit, a pending wl_buffer is applied first, and all other state
        -- second. This means that all coordinates in double-buffered state are
        -- relative to the new wl_buffer coming into use, except for
        -- wl_surface.attach itself. If there is no pending wl_buffer, the
        -- coordinates are relative to the current surface contents.
        -- All requests that need a commit to become effective are documented
        -- to affect double-buffered state.
        -- Other interfaces may add further double-buffered surface state.
        -- @function wl_surface:commit
        -- @treturn wl_surface self
        {
            name = "commit",
            signature = "",
            types = { },
        },
        --- sets the buffer transformation
        --
        -- This request sets an optional transformation on how the compositor
        -- interprets the contents of the buffer attached to the surface. The
        -- accepted values for the transform parameter are the values for
        -- wl_output.transform.
        -- Buffer transform is double-buffered state, see wl_surface.commit.
        -- A newly created surface has its buffer transformation set to normal.
        -- wl_surface.set_buffer_transform changes the pending buffer
        -- transformation. wl_surface.commit copies the pending buffer
        -- transformation to the current one. Otherwise, the pending and current
        -- values are never changed.
        -- The purpose of this request is to allow clients to render content
        -- according to the output transform, thus permitting the compositor to
        -- use certain optimizations even if the display is rotated. Using
        -- hardware overlays and scanning out a client buffer for fullscreen
        -- surfaces are examples of such optimizations. Those optimizations are
        -- highly dependent on the compositor implementation, so the use of this
        -- request should be considered on a case-by-case basis.
        -- Note that if the transform value includes 90 or 270 degree rotation,
        -- the width of the buffer will become the surface height and the height
        -- of the buffer will become the surface width.
        -- If transform is not one of the values from the
        -- wl_output.transform enum the invalid_transform protocol error
        -- is raised.
        -- @function wl_surface:set_buffer_transform
        -- @tparam int transform transform for interpreting buffer contents
        -- @treturn wl_surface self
        {
            name = "set_buffer_transform",
            signature = "2i",
            types = { 0, },
        },
        --- sets the buffer scaling factor
        --
        -- This request sets an optional scaling factor on how the compositor
        -- interprets the contents of the buffer attached to the window.
        -- Buffer scale is double-buffered state, see wl_surface.commit.
        -- A newly created surface has its buffer scale set to 1.
        -- wl_surface.set_buffer_scale changes the pending buffer scale.
        -- wl_surface.commit copies the pending buffer scale to the current one.
        -- Otherwise, the pending and current values are never changed.
        -- The purpose of this request is to allow clients to supply higher
        -- resolution buffer data for use on high resolution outputs. It is
        -- intended that you pick the same buffer scale as the scale of the
        -- output that the surface is displayed on. This means the compositor
        -- can avoid scaling when rendering the surface on that output.
        -- Note that if the scale is larger than 1, then you have to attach
        -- a buffer that is larger (by a factor of scale in each dimension)
        -- than the desired surface size.
        -- If scale is not positive the invalid_scale protocol error is
        -- raised.
        -- @function wl_surface:set_buffer_scale
        -- @tparam int scale positive scale for interpreting buffer contents
        -- @treturn wl_surface self
        {
            name = "set_buffer_scale",
            signature = "3i",
            types = { 0, },
        },
        --- mark part of the surface damaged using buffer coordinates
        --
        -- This request is used to describe the regions where the pending
        -- buffer is different from the current surface contents, and where
        -- the surface therefore needs to be repainted. The compositor
        -- ignores the parts of the damage that fall outside of the surface.
        -- Damage is double-buffered state, see wl_surface.commit.
        -- The damage rectangle is specified in buffer coordinates,
        -- where x and y specify the upper left corner of the damage rectangle.
        -- The initial value for pending damage is empty: no damage.
        -- wl_surface.damage_buffer adds pending damage: the new pending
        -- damage is the union of old pending damage and the given rectangle.
        -- wl_surface.commit assigns pending damage as the current damage,
        -- and clears pending damage. The server will clear the current
        -- damage as it repaints the surface.
        -- This request differs from wl_surface.damage in only one way - it
        -- takes damage in buffer coordinates instead of surface-local
        -- coordinates. While this generally is more intuitive than surface
        -- coordinates, it is especially desirable when using wp_viewport
        -- or when a drawing library (like EGL) is unaware of buffer scale
        -- and buffer transform.
        -- Note: Because buffer transformation changes and damage requests may
        -- be interleaved in the protocol stream, it is impossible to determine
        -- the actual mapping between surface and buffer damage until
        -- wl_surface.commit time. Therefore, compositors wishing to take both
        -- kinds of damage into account will have to accumulate damage from the
        -- two requests separately and only transform from one to the other
        -- after receiving the wl_surface.commit.
        -- @function wl_surface:damage_buffer
        -- @tparam int x buffer-local x coordinate
        -- @tparam int y buffer-local y coordinate
        -- @tparam int width width of damage rectangle
        -- @tparam int height height of damage rectangle
        -- @treturn wl_surface self
        {
            name = "damage_buffer",
            signature = "4iiii",
            types = { 0, 0, 0, 0, },
        },
        --- set the surface contents offset
        --
        -- The x and y arguments specify the location of the new pending
        -- buffer's upper left corner, relative to the current buffer's upper
        -- left corner, in surface-local coordinates. In other words, the
        -- x and y, combined with the new surface size define in which
        -- directions the surface's size changes.
        -- Surface location offset is double-buffered state, see
        -- wl_surface.commit.
        -- This request is semantically equivalent to and the replaces the x and y
        -- arguments in the wl_surface.attach request in wl_surface versions prior
        -- to 5. See wl_surface.attach for details.
        -- @function wl_surface:offset
        -- @tparam int x surface-local x coordinate
        -- @tparam int y surface-local y coordinate
        -- @treturn wl_surface self
        {
            name = "offset",
            signature = "5ii",
            types = { 0, 0, },
        },
    },
    events = {
        --- surface enters an output
        --
        -- This is emitted whenever a surface's creation, movement, or resizing
        -- results in some part of it being within the scanout region of an
        -- output.
        -- Note that a surface may be overlapping with zero or more outputs.
        -- @event wl_surface:enter
        -- @tparam wl_output output output entered by the surface
        {
            name = "enter",
            signature = "o",
            types = { wau.wl_output, },
        },
        --- surface leaves an output
        --
        -- This is emitted whenever a surface's creation, movement, or resizing
        -- results in it no longer having any part of it within the scanout region
        -- of an output.
        -- Clients should not use the number of outputs the surface is on for frame
        -- throttling purposes. The surface might be hidden even if no leave event
        -- has been sent, and the compositor might expect new surface content
        -- updates even if no enter event has been sent. The frame event should be
        -- used instead.
        -- @event wl_surface:leave
        -- @tparam wl_output output output left by the surface
        {
            name = "leave",
            signature = "o",
            types = { wau.wl_output, },
        },
        --- preferred buffer scale for the surface
        --
        -- This event indicates the preferred buffer scale for this surface. It is
        -- sent whenever the compositor's preference changes.
        -- It is intended that scaling aware clients use this event to scale their
        -- content and use wl_surface.set_buffer_scale to indicate the scale they
        -- have rendered with. This allows clients to supply a higher detail
        -- buffer.
        -- @event wl_surface:preferred_buffer_scale
        -- @tparam int factor preferred scaling factor
        {
            name = "preferred_buffer_scale",
            signature = "6i",
            types = { 0, },
        },
        --- preferred buffer transform for the surface
        --
        -- This event indicates the preferred buffer transform for this surface.
        -- It is sent whenever the compositor's preference changes.
        -- It is intended that transform aware clients use this event to apply the
        -- transform to their content and use wl_surface.set_buffer_transform to
        -- indicate the transform they have rendered with.
        -- @event wl_surface:preferred_buffer_transform
        -- @tparam uint transform preferred transform
        {
            name = "preferred_buffer_transform",
            signature = "6u",
            types = { 0, },
        },
    },
    enums = {
        --- wl_surface error values
        --
        -- These errors can be emitted in response to wl_surface requests.
        -- @enum wl_surface.Error
        -- @param INVALID_SCALE 0 buffer scale value is invalid
        -- @param INVALID_TRANSFORM 1 buffer transform value is invalid
        -- @param INVALID_SIZE 2 buffer size is invalid
        -- @param INVALID_OFFSET 3 buffer offset is invalid
        -- @param DEFUNCT_ROLE_OBJECT 4 surface was destroyed before its role object
        ["error"] = {
            ["invalid_scale"] = 0,
            ["invalid_transform"] = 1,
            ["invalid_size"] = 2,
            ["invalid_offset"] = 3,
            ["defunct_role_object"] = 4,
        },
    },
    methods_opcode = {
        ["destroy"] = 0,
        ["attach"] = 1,
        ["damage"] = 2,
        ["frame"] = 3,
        ["set_opaque_region"] = 4,
        ["set_input_region"] = 5,
        ["commit"] = 6,
        ["set_buffer_transform"] = 7,
        ["set_buffer_scale"] = 8,
        ["damage_buffer"] = 9,
        ["offset"] = 10,
    },
}

--- group of input devices
--
-- A seat is a group of keyboards, pointer and touch devices. This
-- object is published as a global during start up, or when such a
-- device is hot plugged.  A seat typically has a pointer and
-- maintains a keyboard focus and a pointer focus.
-- @type wl_seat
wau.wl_seat:init {
    name = "wl_seat",
    version = 9,
    methods = {
        --- return pointer object
        --
        -- The ID provided will be initialized to the wl_pointer interface
        -- for this seat.
        -- This request only takes effect if the seat has the pointer
        -- capability, or has had the pointer capability in the past.
        -- It is a protocol violation to issue this request on a seat that has
        -- never had the pointer capability. The missing_capability error will
        -- be sent in this case.
        -- @function wl_seat:get_pointer
        -- @treturn wl_pointer
        {
            name = "get_pointer",
            signature = "n",
            types = { wau.wl_pointer, },
        },
        --- return keyboard object
        --
        -- The ID provided will be initialized to the wl_keyboard interface
        -- for this seat.
        -- This request only takes effect if the seat has the keyboard
        -- capability, or has had the keyboard capability in the past.
        -- It is a protocol violation to issue this request on a seat that has
        -- never had the keyboard capability. The missing_capability error will
        -- be sent in this case.
        -- @function wl_seat:get_keyboard
        -- @treturn wl_keyboard
        {
            name = "get_keyboard",
            signature = "n",
            types = { wau.wl_keyboard, },
        },
        --- return touch object
        --
        -- The ID provided will be initialized to the wl_touch interface
        -- for this seat.
        -- This request only takes effect if the seat has the touch
        -- capability, or has had the touch capability in the past.
        -- It is a protocol violation to issue this request on a seat that has
        -- never had the touch capability. The missing_capability error will
        -- be sent in this case.
        -- @function wl_seat:get_touch
        -- @treturn wl_touch
        {
            name = "get_touch",
            signature = "n",
            types = { wau.wl_touch, },
        },
        --- release the seat object
        --
        -- Using this request a client can tell the server that it is not going to
        -- use the seat object anymore.
        -- @function wl_seat:release
        -- @treturn wl_seat self
        {
            name = "release",
            signature = "5",
            types = { },
            type = "destructor"
        },
    },
    events = {
        --- seat capabilities changed
        --
        -- This is emitted whenever a seat gains or loses the pointer,
        -- keyboard or touch capabilities.  The argument is a capability
        -- enum containing the complete set of capabilities this seat has.
        -- When the pointer capability is added, a client may create a
        -- wl_pointer object using the wl_seat.get_pointer request. This object
        -- will receive pointer events until the capability is removed in the
        -- future.
        -- When the pointer capability is removed, a client should destroy the
        -- wl_pointer objects associated with the seat where the capability was
        -- removed, using the wl_pointer.release request. No further pointer
        -- events will be received on these objects.
        -- In some compositors, if a seat regains the pointer capability and a
        -- client has a previously obtained wl_pointer object of version 4 or
        -- less, that object may start sending pointer events again. This
        -- behavior is considered a misinterpretation of the intended behavior
        -- and must not be relied upon by the client. wl_pointer objects of
        -- version 5 or later must not send events if created before the most
        -- recent event notifying the client of an added pointer capability.
        -- The above behavior also applies to wl_keyboard and wl_touch with the
        -- keyboard and touch capabilities, respectively.
        -- @event wl_seat:capabilities
        -- @tparam uint capabilities capabilities of the seat
        {
            name = "capabilities",
            signature = "u",
            types = { 0, },
        },
        --- unique identifier for this seat
        --
        -- In a multi-seat configuration the seat name can be used by clients to
        -- help identify which physical devices the seat represents.
        -- The seat name is a UTF-8 string with no convention defined for its
        -- contents. Each name is unique among all wl_seat globals. The name is
        -- only guaranteed to be unique for the current compositor instance.
        -- The same seat names are used for all clients. Thus, the name can be
        -- shared across processes to refer to a specific wl_seat global.
        -- The name event is sent after binding to the seat global. This event is
        -- only sent once per seat object, and the name does not change over the
        -- lifetime of the wl_seat global.
        -- Compositors may re-use the same seat name if the wl_seat global is
        -- destroyed and re-created later.
        -- @event wl_seat:name
        -- @tparam string name seat identifier
        {
            name = "name",
            signature = "2s",
            types = { 0, },
        },
    },
    enums = {
        --- seat capability bitmask
        --
        -- This is a bitmask of capabilities this seat has; if a member is
        -- set, then it is present on the seat.
        -- @enum wl_seat.Capability
        -- @param POINTER 1 the seat has pointer devices
        -- @param KEYBOARD 2 the seat has one or more keyboards
        -- @param TOUCH 4 the seat has touch devices
        ["capability"] = {
            ["pointer"] = 1,
            ["keyboard"] = 2,
            ["touch"] = 4,
        },
        --- wl_seat error values
        --
        -- These errors can be emitted in response to wl_seat requests.
        -- @enum wl_seat.Error
        -- @param MISSING_CAPABILITY 0 get_pointer, get_keyboard or get_touch called on seat without the matching capability
        ["error"] = {
            ["missing_capability"] = 0,
        },
    },
    methods_opcode = {
        ["get_pointer"] = 0,
        ["get_keyboard"] = 1,
        ["get_touch"] = 2,
        ["release"] = 3,
    },
}

--- pointer input device
--
-- The wl_pointer interface represents one or more input devices,
-- such as mice, which control the pointer location and pointer_focus
-- of a seat.
-- The wl_pointer interface generates motion, enter and leave
-- events for the surfaces that the pointer is located over,
-- and button and axis events for button presses, button releases
-- and scrolling.
-- @type wl_pointer
wau.wl_pointer:init {
    name = "wl_pointer",
    version = 9,
    methods = {
        --- set the pointer surface
        --
        -- Set the pointer surface, i.e., the surface that contains the
        -- pointer image (cursor). This request gives the surface the role
        -- of a cursor. If the surface already has another role, it raises
        -- a protocol error.
        -- The cursor actually changes only if the pointer
        -- focus for this device is one of the requesting client's surfaces
        -- or the surface parameter is the current pointer surface. If
        -- there was a previous surface set with this request it is
        -- replaced. If surface is NULL, the pointer image is hidden.
        -- The parameters hotspot_x and hotspot_y define the position of
        -- the pointer surface relative to the pointer location. Its
        -- top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
        -- where (x, y) are the coordinates of the pointer location, in
        -- surface-local coordinates.
        -- On surface.attach requests to the pointer surface, hotspot_x
        -- and hotspot_y are decremented by the x and y parameters
        -- passed to the request. Attach must be confirmed by
        -- wl_surface.commit as usual.
        -- The hotspot can also be updated by passing the currently set
        -- pointer surface to this request with new values for hotspot_x
        -- and hotspot_y.
        -- The input region is ignored for wl_surfaces with the role of
        -- a cursor. When the use as a cursor ends, the wl_surface is
        -- unmapped.
        -- The serial parameter must match the latest wl_pointer.enter
        -- serial number sent to the client. Otherwise the request will be
        -- ignored.
        -- @function wl_pointer:set_cursor
        -- @tparam uint serial serial number of the enter event
        -- @tparam wl_surface surface pointer surface
        -- @tparam int hotspot_x surface-local x coordinate
        -- @tparam int hotspot_y surface-local y coordinate
        -- @treturn wl_pointer self
        {
            name = "set_cursor",
            signature = "u?oii",
            types = { 0, wau.wl_surface, 0, 0, },
        },
        --- release the pointer object
        --
        -- Using this request a client can tell the server that it is not going to
        -- use the pointer object anymore.
        -- This request destroys the pointer proxy object, so clients must not call
        -- wl_pointer_destroy() after using this request.
        -- @function wl_pointer:release
        -- @treturn wl_pointer self
        {
            name = "release",
            signature = "3",
            types = { },
            type = "destructor"
        },
    },
    events = {
        --- enter event
        --
        -- Notification that this seat's pointer is focused on a certain
        -- surface.
        -- When a seat's focus enters a surface, the pointer image
        -- is undefined and a client should respond to this event by setting
        -- an appropriate pointer image with the set_cursor request.
        -- @event wl_pointer:enter
        -- @tparam uint serial serial number of the enter event
        -- @tparam wl_surface surface surface entered by the pointer
        -- @tparam fixed surface_x surface-local x coordinate
        -- @tparam fixed surface_y surface-local y coordinate
        {
            name = "enter",
            signature = "uoff",
            types = { 0, wau.wl_surface, 0, 0, },
        },
        --- leave event
        --
        -- Notification that this seat's pointer is no longer focused on
        -- a certain surface.
        -- The leave notification is sent before the enter notification
        -- for the new focus.
        -- @event wl_pointer:leave
        -- @tparam uint serial serial number of the leave event
        -- @tparam wl_surface surface surface left by the pointer
        {
            name = "leave",
            signature = "uo",
            types = { 0, wau.wl_surface, },
        },
        --- pointer motion event
        --
        -- Notification of pointer location change. The arguments
        -- surface_x and surface_y are the location relative to the
        -- focused surface.
        -- @event wl_pointer:motion
        -- @tparam uint time timestamp with millisecond granularity
        -- @tparam fixed surface_x surface-local x coordinate
        -- @tparam fixed surface_y surface-local y coordinate
        {
            name = "motion",
            signature = "uff",
            types = { 0, 0, 0, },
        },
        --- pointer button event
        --
        -- Mouse button click and release notifications.
        -- The location of the click is given by the last motion or
        -- enter event.
        -- The time argument is a timestamp with millisecond
        -- granularity, with an undefined base.
        -- The button is a button code as defined in the Linux kernel's
        -- linux/input-event-codes.h header file, e.g. BTN_LEFT.
        -- Any 16-bit button code value is reserved for future additions to the
        -- kernel's event code list. All other button codes above 0xFFFF are
        -- currently undefined but may be used in future versions of this
        -- protocol.
        -- @event wl_pointer:button
        -- @tparam uint serial serial number of the button event
        -- @tparam uint time timestamp with millisecond granularity
        -- @tparam uint button button that produced the event
        -- @tparam uint state physical state of the button
        {
            name = "button",
            signature = "uuuu",
            types = { 0, 0, 0, 0, },
        },
        --- axis event
        --
        -- Scroll and other axis notifications.
        -- For scroll events (vertical and horizontal scroll axes), the
        -- value parameter is the length of a vector along the specified
        -- axis in a coordinate space identical to those of motion events,
        -- representing a relative movement along the specified axis.
        -- For devices that support movements non-parallel to axes multiple
        -- axis events will be emitted.
        -- When applicable, for example for touch pads, the server can
        -- choose to emit scroll events where the motion vector is
        -- equivalent to a motion event vector.
        -- When applicable, a client can transform its content relative to the
        -- scroll distance.
        -- @event wl_pointer:axis
        -- @tparam uint time timestamp with millisecond granularity
        -- @tparam uint axis axis type
        -- @tparam fixed value length of vector in surface-local coordinate space
        {
            name = "axis",
            signature = "uuf",
            types = { 0, 0, 0, },
        },
        --- end of a pointer event sequence
        --
        -- Indicates the end of a set of events that logically belong together.
        -- A client is expected to accumulate the data in all events within the
        -- frame before proceeding.
        -- All wl_pointer events before a wl_pointer.frame event belong
        -- logically together. For example, in a diagonal scroll motion the
        -- compositor will send an optional wl_pointer.axis_source event, two
        -- wl_pointer.axis events (horizontal and vertical) and finally a
        -- wl_pointer.frame event. The client may use this information to
        -- calculate a diagonal vector for scrolling.
        -- When multiple wl_pointer.axis events occur within the same frame,
        -- the motion vector is the combined motion of all events.
        -- When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
        -- the same frame, this indicates that axis movement in one axis has
        -- stopped but continues in the other axis.
        -- When multiple wl_pointer.axis_stop events occur within the same
        -- frame, this indicates that these axes stopped in the same instance.
        -- A wl_pointer.frame event is sent for every logical event group,
        -- even if the group only contains a single wl_pointer event.
        -- Specifically, a client may get a sequence: motion, frame, button,
        -- frame, axis, frame, axis_stop, frame.
        -- The wl_pointer.enter and wl_pointer.leave events are logical events
        -- generated by the compositor and not the hardware. These events are
        -- also grouped by a wl_pointer.frame. When a pointer moves from one
        -- surface to another, a compositor should group the
        -- wl_pointer.leave event within the same wl_pointer.frame.
        -- However, a client must not rely on wl_pointer.leave and
        -- wl_pointer.enter being in the same wl_pointer.frame.
        -- Compositor-specific policies may require the wl_pointer.leave and
        -- wl_pointer.enter event being split across multiple wl_pointer.frame
        -- groups.
        -- @event wl_pointer:frame
        {
            name = "frame",
            signature = "5",
            types = { },
        },
        --- axis source event
        --
        -- Source information for scroll and other axes.
        -- This event does not occur on its own. It is sent before a
        -- wl_pointer.frame event and carries the source information for
        -- all events within that frame.
        -- The source specifies how this event was generated. If the source is
        -- wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
        -- sent when the user lifts the finger off the device.
        -- If the source is wl_pointer.axis_source.wheel,
        -- wl_pointer.axis_source.wheel_tilt or
        -- wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
        -- or may not be sent. Whether a compositor sends an axis_stop event
        -- for these sources is hardware-specific and implementation-dependent;
        -- clients must not rely on receiving an axis_stop event for these
        -- scroll sources and should treat scroll sequences from these scroll
        -- sources as unterminated by default.
        -- This event is optional. If the source is unknown for a particular
        -- axis event sequence, no event is sent.
        -- Only one wl_pointer.axis_source event is permitted per frame.
        -- The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
        -- not guaranteed.
        -- @event wl_pointer:axis_source
        -- @tparam uint axis_source source of the axis event
        {
            name = "axis_source",
            signature = "5u",
            types = { 0, },
        },
        --- axis stop event
        --
        -- Stop notification for scroll and other axes.
        -- For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
        -- is sent to notify a client that the axis sequence has terminated.
        -- This enables the client to implement kinetic scrolling.
        -- See the wl_pointer.axis_source documentation for information on when
        -- this event may be generated.
        -- Any wl_pointer.axis events with the same axis_source after this
        -- event should be considered as the start of a new axis motion.
        -- The timestamp is to be interpreted identical to the timestamp in the
        -- wl_pointer.axis event. The timestamp value may be the same as a
        -- preceding wl_pointer.axis event.
        -- @event wl_pointer:axis_stop
        -- @tparam uint time timestamp with millisecond granularity
        -- @tparam uint axis the axis stopped with this event
        {
            name = "axis_stop",
            signature = "5uu",
            types = { 0, 0, },
        },
        --- axis click event
        --
        -- Discrete step information for scroll and other axes.
        -- This event carries the axis value of the wl_pointer.axis event in
        -- discrete steps (e.g. mouse wheel clicks).
        -- This event is deprecated with wl_pointer version 8 - this event is not
        -- sent to clients supporting version 8 or later.
        -- This event does not occur on its own, it is coupled with a
        -- wl_pointer.axis event that represents this axis value on a
        -- continuous scale. The protocol guarantees that each axis_discrete
        -- event is always followed by exactly one axis event with the same
        -- axis number within the same wl_pointer.frame. Note that the protocol
        -- allows for other events to occur between the axis_discrete and
        -- its coupled axis event, including other axis_discrete or axis
        -- events. A wl_pointer.frame must not contain more than one axis_discrete
        -- event per axis type.
        -- This event is optional; continuous scrolling devices
        -- like two-finger scrolling on touchpads do not have discrete
        -- steps and do not generate this event.
        -- The discrete value carries the directional information. e.g. a value
        -- of -2 is two steps towards the negative direction of this axis.
        -- The axis number is identical to the axis number in the associated
        -- axis event.
        -- The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
        -- not guaranteed.
        -- @event wl_pointer:axis_discrete
        -- @tparam uint axis axis type
        -- @tparam int discrete number of steps
        {
            name = "axis_discrete",
            signature = "5ui",
            types = { 0, 0, },
        },
        --- axis high-resolution scroll event
        --
        -- Discrete high-resolution scroll information.
        -- This event carries high-resolution wheel scroll information,
        -- with each multiple of 120 representing one logical scroll step
        -- (a wheel detent). For example, an axis_value120 of 30 is one quarter of
        -- a logical scroll step in the positive direction, a value120 of
        -- -240 are two logical scroll steps in the negative direction within the
        -- same hardware event.
        -- Clients that rely on discrete scrolling should accumulate the
        -- value120 to multiples of 120 before processing the event.
        -- The value120 must not be zero.
        -- This event replaces the wl_pointer.axis_discrete event in clients
        -- supporting wl_pointer version 8 or later.
        -- Where a wl_pointer.axis_source event occurs in the same
        -- wl_pointer.frame, the axis source applies to this event.
        -- The order of wl_pointer.axis_value120 and wl_pointer.axis_source is
        -- not guaranteed.
        -- @event wl_pointer:axis_value120
        -- @tparam uint axis axis type
        -- @tparam int value120 scroll distance as fraction of 120
        {
            name = "axis_value120",
            signature = "8ui",
            types = { 0, 0, },
        },
        --- axis relative physical direction event
        --
        -- Relative directional information of the entity causing the axis
        -- motion.
        -- For a wl_pointer.axis event, the wl_pointer.axis_relative_direction
        -- event specifies the movement direction of the entity causing the
        -- wl_pointer.axis event. For example:
        -- - if a user's fingers on a touchpad move down and this
        -- causes a wl_pointer.axis vertical_scroll down event, the physical
        -- direction is 'identical'
        -- - if a user's fingers on a touchpad move down and this causes a
        -- wl_pointer.axis vertical_scroll up scroll up event ('natural
        -- scrolling'), the physical direction is 'inverted'.
        -- A client may use this information to adjust scroll motion of
        -- components. Specifically, enabling natural scrolling causes the
        -- content to change direction compared to traditional scrolling.
        -- Some widgets like volume control sliders should usually match the
        -- physical direction regardless of whether natural scrolling is
        -- active. This event enables clients to match the scroll direction of
        -- a widget to the physical direction.
        -- This event does not occur on its own, it is coupled with a
        -- wl_pointer.axis event that represents this axis value.
        -- The protocol guarantees that each axis_relative_direction event is
        -- always followed by exactly one axis event with the same
        -- axis number within the same wl_pointer.frame. Note that the protocol
        -- allows for other events to occur between the axis_relative_direction
        -- and its coupled axis event.
        -- The axis number is identical to the axis number in the associated
        -- axis event.
        -- The order of wl_pointer.axis_relative_direction,
        -- wl_pointer.axis_discrete and wl_pointer.axis_source is not
        -- guaranteed.
        -- @event wl_pointer:axis_relative_direction
        -- @tparam uint axis axis type
        -- @tparam uint direction physical direction relative to axis motion
        {
            name = "axis_relative_direction",
            signature = "9uu",
            types = { 0, 0, },
        },
    },
    enums = {
        --- error
        -- @enum wl_pointer.Error
        -- @param ROLE 0 given wl_surface has another role
        ["error"] = {
            ["role"] = 0,
        },
        --- physical button state
        --
        -- Describes the physical state of a button that produced the button
        -- event.
        -- @enum wl_pointer.ButtonState
        -- @param RELEASED 0 the button is not pressed
        -- @param PRESSED 1 the button is pressed
        ["button_state"] = {
            ["released"] = 0,
            ["pressed"] = 1,
        },
        --- axis types
        --
        -- Describes the axis types of scroll events.
        -- @enum wl_pointer.Axis
        -- @param VERTICAL_SCROLL 0 vertical axis
        -- @param HORIZONTAL_SCROLL 1 horizontal axis
        ["axis"] = {
            ["vertical_scroll"] = 0,
            ["horizontal_scroll"] = 1,
        },
        --- axis source types
        --
        -- Describes the source types for axis events. This indicates to the
        -- client how an axis event was physically generated; a client may
        -- adjust the user interface accordingly. For example, scroll events
        -- from a "finger" source may be in a smooth coordinate space with
        -- kinetic scrolling whereas a "wheel" source may be in discrete steps
        -- of a number of lines.
        -- The "continuous" axis source is a device generating events in a
        -- continuous coordinate space, but using something other than a
        -- finger. One example for this source is button-based scrolling where
        -- the vertical motion of a device is converted to scroll events while
        -- a button is held down.
        -- The "wheel tilt" axis source indicates that the actual device is a
        -- wheel but the scroll event is not caused by a rotation but a
        -- (usually sideways) tilt of the wheel.
        -- @enum wl_pointer.AxisSource
        -- @param WHEEL 0 a physical wheel rotation
        -- @param FINGER 1 finger on a touch surface
        -- @param CONTINUOUS 2 continuous coordinate space
        -- @param WHEEL_TILT 3 a physical wheel tilt
        ["axis_source"] = {
            ["wheel"] = 0,
            ["finger"] = 1,
            ["continuous"] = 2,
            ["wheel_tilt"] = 3,
        },
        --- axis relative direction
        --
        -- This specifies the direction of the physical motion that caused a
        -- wl_pointer.axis event, relative to the wl_pointer.axis direction.
        -- @enum wl_pointer.AxisRelativeDirection
        -- @param IDENTICAL 0 physical motion matches axis direction
        -- @param INVERTED 1 physical motion is the inverse of the axis direction
        ["axis_relative_direction"] = {
            ["identical"] = 0,
            ["inverted"] = 1,
        },
    },
    methods_opcode = {
        ["set_cursor"] = 0,
        ["release"] = 1,
    },
}

--- keyboard input device
--
-- The wl_keyboard interface represents one or more keyboards
-- associated with a seat.
-- @type wl_keyboard
wau.wl_keyboard:init {
    name = "wl_keyboard",
    version = 9,
    methods = {
        --- release the keyboard object
        -- @function wl_keyboard:release
        -- @treturn wl_keyboard self
        {
            name = "release",
            signature = "3",
            types = { },
            type = "destructor"
        },
    },
    events = {
        --- keyboard mapping
        --
        -- This event provides a file descriptor to the client which can be
        -- memory-mapped in read-only mode to provide a keyboard mapping
        -- description.
        -- From version 7 onwards, the fd must be mapped with MAP_PRIVATE by
        -- the recipient, as MAP_SHARED may fail.
        -- @event wl_keyboard:keymap
        -- @tparam uint format keymap format
        -- @tparam fd fd keymap file descriptor
        -- @tparam uint size keymap size, in bytes
        {
            name = "keymap",
            signature = "uhu",
            types = { 0, 0, 0, },
        },
        --- enter event
        --
        -- Notification that this seat's keyboard focus is on a certain
        -- surface.
        -- The compositor must send the wl_keyboard.modifiers event after this
        -- event.
        -- @event wl_keyboard:enter
        -- @tparam uint serial serial number of the enter event
        -- @tparam wl_surface surface surface gaining keyboard focus
        -- @tparam array keys the currently pressed keys
        {
            name = "enter",
            signature = "uoa",
            types = { 0, wau.wl_surface, 0, },
        },
        --- leave event
        --
        -- Notification that this seat's keyboard focus is no longer on
        -- a certain surface.
        -- The leave notification is sent before the enter notification
        -- for the new focus.
        -- After this event client must assume that no keys are pressed,
        -- it must stop key repeating if there's some going on and until
        -- it receives the next wl_keyboard.modifiers event, the client
        -- must also assume no modifiers are active.
        -- @event wl_keyboard:leave
        -- @tparam uint serial serial number of the leave event
        -- @tparam wl_surface surface surface that lost keyboard focus
        {
            name = "leave",
            signature = "uo",
            types = { 0, wau.wl_surface, },
        },
        --- key event
        --
        -- A key was pressed or released.
        -- The time argument is a timestamp with millisecond
        -- granularity, with an undefined base.
        -- The key is a platform-specific key code that can be interpreted
        -- by feeding it to the keyboard mapping (see the keymap event).
        -- If this event produces a change in modifiers, then the resulting
        -- wl_keyboard.modifiers event must be sent after this event.
        -- The compositor must not send this event without a surface of the client
        -- having keyboard focus.
        -- @event wl_keyboard:key
        -- @tparam uint serial serial number of the key event
        -- @tparam uint time timestamp with millisecond granularity
        -- @tparam uint key key that produced the event
        -- @tparam uint state physical state of the key
        {
            name = "key",
            signature = "uuuu",
            types = { 0, 0, 0, 0, },
        },
        --- modifier and group state
        --
        -- Notifies clients that the modifier and/or group state has
        -- changed, and it should update its local state.
        -- The compositor may send this event without a surface of the client
        -- having keyboard focus, for example to tie modifier information to
        -- pointer focus instead. If a modifier event with pressed modifiers is sent
        -- without a prior enter event, the client can assume the modifier state is
        -- valid until it receives the next wl_keyboard.modifiers event. In order to
        -- reset the modifier state again, the compositor can send a
        -- wl_keyboard.modifiers event with no pressed modifiers.
        -- @event wl_keyboard:modifiers
        -- @tparam uint serial serial number of the modifiers event
        -- @tparam uint mods_depressed depressed modifiers
        -- @tparam uint mods_latched latched modifiers
        -- @tparam uint mods_locked locked modifiers
        -- @tparam uint group keyboard layout
        {
            name = "modifiers",
            signature = "uuuuu",
            types = { 0, 0, 0, 0, 0, },
        },
        --- repeat rate and delay
        --
        -- Informs the client about the keyboard's repeat rate and delay.
        -- This event is sent as soon as the wl_keyboard object has been created,
        -- and is guaranteed to be received by the client before any key press
        -- event.
        -- Negative values for either rate or delay are illegal. A rate of zero
        -- will disable any repeating (regardless of the value of delay).
        -- This event can be sent later on as well with a new value if necessary,
        -- so clients should continue listening for the event past the creation
        -- of wl_keyboard.
        -- @event wl_keyboard:repeat_info
        -- @tparam int rate the rate of repeating keys in characters per second
        -- @tparam int delay delay in milliseconds since key down until repeating starts
        {
            name = "repeat_info",
            signature = "4ii",
            types = { 0, 0, },
        },
    },
    enums = {
        --- keyboard mapping format
        --
        -- This specifies the format of the keymap provided to the
        -- client with the wl_keyboard.keymap event.
        -- @enum wl_keyboard.KeymapFormat
        -- @param NO_KEYMAP 0 no keymap; client must understand how to interpret the raw keycode
        -- @param XKB_V1 1 libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode
        ["keymap_format"] = {
            ["no_keymap"] = 0,
            ["xkb_v1"] = 1,
        },
        --- physical key state
        --
        -- Describes the physical state of a key that produced the key event.
        -- @enum wl_keyboard.KeyState
        -- @param RELEASED 0 key is not pressed
        -- @param PRESSED 1 key is pressed
        ["key_state"] = {
            ["released"] = 0,
            ["pressed"] = 1,
        },
    },
    methods_opcode = {
        ["release"] = 0,
    },
}

--- touchscreen input device
--
-- The wl_touch interface represents a touchscreen
-- associated with a seat.
-- Touch interactions can consist of one or more contacts.
-- For each contact, a series of events is generated, starting
-- with a down event, followed by zero or more motion events,
-- and ending with an up event. Events relating to the same
-- contact point can be identified by the ID of the sequence.
-- @type wl_touch
wau.wl_touch:init {
    name = "wl_touch",
    version = 9,
    methods = {
        --- release the touch object
        -- @function wl_touch:release
        -- @treturn wl_touch self
        {
            name = "release",
            signature = "3",
            types = { },
            type = "destructor"
        },
    },
    events = {
        --- touch down event and beginning of a touch sequence
        --
        -- A new touch point has appeared on the surface. This touch point is
        -- assigned a unique ID. Future events from this touch point reference
        -- this ID. The ID ceases to be valid after a touch up event and may be
        -- reused in the future.
        -- @event wl_touch:down
        -- @tparam uint serial serial number of the touch down event
        -- @tparam uint time timestamp with millisecond granularity
        -- @tparam wl_surface surface surface touched
        -- @tparam int id the unique ID of this touch point
        -- @tparam fixed x surface-local x coordinate
        -- @tparam fixed y surface-local y coordinate
        {
            name = "down",
            signature = "uuoiff",
            types = { 0, 0, wau.wl_surface, 0, 0, 0, },
        },
        --- end of a touch event sequence
        --
        -- The touch point has disappeared. No further events will be sent for
        -- this touch point and the touch point's ID is released and may be
        -- reused in a future touch down event.
        -- @event wl_touch:up
        -- @tparam uint serial serial number of the touch up event
        -- @tparam uint time timestamp with millisecond granularity
        -- @tparam int id the unique ID of this touch point
        {
            name = "up",
            signature = "uui",
            types = { 0, 0, 0, },
        },
        --- update of touch point coordinates
        --
        -- A touch point has changed coordinates.
        -- @event wl_touch:motion
        -- @tparam uint time timestamp with millisecond granularity
        -- @tparam int id the unique ID of this touch point
        -- @tparam fixed x surface-local x coordinate
        -- @tparam fixed y surface-local y coordinate
        {
            name = "motion",
            signature = "uiff",
            types = { 0, 0, 0, 0, },
        },
        --- end of touch frame event
        --
        -- Indicates the end of a set of events that logically belong together.
        -- A client is expected to accumulate the data in all events within the
        -- frame before proceeding.
        -- A wl_touch.frame terminates at least one event but otherwise no
        -- guarantee is provided about the set of events within a frame. A client
        -- must assume that any state not updated in a frame is unchanged from the
        -- previously known state.
        -- @event wl_touch:frame
        {
            name = "frame",
            signature = "",
            types = { },
        },
        --- touch session cancelled
        --
        -- Sent if the compositor decides the touch stream is a global
        -- gesture. No further events are sent to the clients from that
        -- particular gesture. Touch cancellation applies to all touch points
        -- currently active on this client's surface. The client is
        -- responsible for finalizing the touch points, future touch points on
        -- this surface may reuse the touch point ID.
        -- @event wl_touch:cancel
        {
            name = "cancel",
            signature = "",
            types = { },
        },
        --- update shape of touch point
        --
        -- Sent when a touchpoint has changed its shape.
        -- This event does not occur on its own. It is sent before a
        -- wl_touch.frame event and carries the new shape information for
        -- any previously reported, or new touch points of that frame.
        -- Other events describing the touch point such as wl_touch.down,
        -- wl_touch.motion or wl_touch.orientation may be sent within the
        -- same wl_touch.frame. A client should treat these events as a single
        -- logical touch point update. The order of wl_touch.shape,
        -- wl_touch.orientation and wl_touch.motion is not guaranteed.
        -- A wl_touch.down event is guaranteed to occur before the first
        -- wl_touch.shape event for this touch ID but both events may occur within
        -- the same wl_touch.frame.
        -- A touchpoint shape is approximated by an ellipse through the major and
        -- minor axis length. The major axis length describes the longer diameter
        -- of the ellipse, while the minor axis length describes the shorter
        -- diameter. Major and minor are orthogonal and both are specified in
        -- surface-local coordinates. The center of the ellipse is always at the
        -- touchpoint location as reported by wl_touch.down or wl_touch.move.
        -- This event is only sent by the compositor if the touch device supports
        -- shape reports. The client has to make reasonable assumptions about the
        -- shape if it did not receive this event.
        -- @event wl_touch:shape
        -- @tparam int id the unique ID of this touch point
        -- @tparam fixed major length of the major axis in surface-local coordinates
        -- @tparam fixed minor length of the minor axis in surface-local coordinates
        {
            name = "shape",
            signature = "6iff",
            types = { 0, 0, 0, },
        },
        --- update orientation of touch point
        --
        -- Sent when a touchpoint has changed its orientation.
        -- This event does not occur on its own. It is sent before a
        -- wl_touch.frame event and carries the new shape information for
        -- any previously reported, or new touch points of that frame.
        -- Other events describing the touch point such as wl_touch.down,
        -- wl_touch.motion or wl_touch.shape may be sent within the
        -- same wl_touch.frame. A client should treat these events as a single
        -- logical touch point update. The order of wl_touch.shape,
        -- wl_touch.orientation and wl_touch.motion is not guaranteed.
        -- A wl_touch.down event is guaranteed to occur before the first
        -- wl_touch.orientation event for this touch ID but both events may occur
        -- within the same wl_touch.frame.
        -- The orientation describes the clockwise angle of a touchpoint's major
        -- axis to the positive surface y-axis and is normalized to the -180 to
        -- +180 degree range. The granularity of orientation depends on the touch
        -- device, some devices only support binary rotation values between 0 and
        -- 90 degrees.
        -- This event is only sent by the compositor if the touch device supports
        -- orientation reports.
        -- @event wl_touch:orientation
        -- @tparam int id the unique ID of this touch point
        -- @tparam fixed orientation angle between major axis and positive surface y-axis in degrees
        {
            name = "orientation",
            signature = "6if",
            types = { 0, 0, },
        },
    },
    enums = {
    },
    methods_opcode = {
        ["release"] = 0,
    },
}

--- compositor output region
--
-- An output describes part of the compositor geometry.  The
-- compositor works in the 'compositor coordinate system' and an
-- output corresponds to a rectangular area in that space that is
-- actually visible.  This typically corresponds to a monitor that
-- displays part of the compositor space.  This object is published
-- as global during start up, or when a monitor is hotplugged.
-- @type wl_output
wau.wl_output:init {
    name = "wl_output",
    version = 4,
    methods = {
        --- release the output object
        --
        -- Using this request a client can tell the server that it is not going to
        -- use the output object anymore.
        -- @function wl_output:release
        -- @treturn wl_output self
        {
            name = "release",
            signature = "3",
            types = { },
            type = "destructor"
        },
    },
    events = {
        --- properties of the output
        --
        -- The geometry event describes geometric properties of the output.
        -- The event is sent when binding to the output object and whenever
        -- any of the properties change.
        -- The physical size can be set to zero if it doesn't make sense for this
        -- output (e.g. for projectors or virtual outputs).
        -- The geometry event will be followed by a done event (starting from
        -- version 2).
        -- Note: wl_output only advertises partial information about the output
        -- position and identification. Some compositors, for instance those not
        -- implementing a desktop-style output layout or those exposing virtual
        -- outputs, might fake this information. Instead of using x and y, clients
        -- should use xdg_output.logical_position. Instead of using make and model,
        -- clients should use name and description.
        -- @event wl_output:geometry
        -- @tparam int x x position within the global compositor space
        -- @tparam int y y position within the global compositor space
        -- @tparam int physical_width width in millimeters of the output
        -- @tparam int physical_height height in millimeters of the output
        -- @tparam int subpixel subpixel orientation of the output
        -- @tparam string make textual description of the manufacturer
        -- @tparam string model textual description of the model
        -- @tparam int transform transform that maps framebuffer to output
        {
            name = "geometry",
            signature = "iiiiissi",
            types = { 0, 0, 0, 0, 0, 0, 0, 0, },
        },
        --- advertise available modes for the output
        --
        -- The mode event describes an available mode for the output.
        -- The event is sent when binding to the output object and there
        -- will always be one mode, the current mode.  The event is sent
        -- again if an output changes mode, for the mode that is now
        -- current.  In other words, the current mode is always the last
        -- mode that was received with the current flag set.
        -- Non-current modes are deprecated. A compositor can decide to only
        -- advertise the current mode and never send other modes. Clients
        -- should not rely on non-current modes.
        -- The size of a mode is given in physical hardware units of
        -- the output device. This is not necessarily the same as
        -- the output size in the global compositor space. For instance,
        -- the output may be scaled, as described in wl_output.scale,
        -- or transformed, as described in wl_output.transform. Clients
        -- willing to retrieve the output size in the global compositor
        -- space should use xdg_output.logical_size instead.
        -- The vertical refresh rate can be set to zero if it doesn't make
        -- sense for this output (e.g. for virtual outputs).
        -- The mode event will be followed by a done event (starting from
        -- version 2).
        -- Clients should not use the refresh rate to schedule frames. Instead,
        -- they should use the wl_surface.frame event or the presentation-time
        -- protocol.
        -- Note: this information is not always meaningful for all outputs. Some
        -- compositors, such as those exposing virtual outputs, might fake the
        -- refresh rate or the size.
        -- @event wl_output:mode
        -- @tparam uint flags bitfield of mode flags
        -- @tparam int width width of the mode in hardware units
        -- @tparam int height height of the mode in hardware units
        -- @tparam int refresh vertical refresh rate in mHz
        {
            name = "mode",
            signature = "uiii",
            types = { 0, 0, 0, 0, },
        },
        --- sent all information about output
        --
        -- This event is sent after all other properties have been
        -- sent after binding to the output object and after any
        -- other property changes done after that. This allows
        -- changes to the output properties to be seen as
        -- atomic, even if they happen via multiple events.
        -- @event wl_output:done
        {
            name = "done",
            signature = "2",
            types = { },
        },
        --- output scaling properties
        --
        -- This event contains scaling geometry information
        -- that is not in the geometry event. It may be sent after
        -- binding the output object or if the output scale changes
        -- later. If it is not sent, the client should assume a
        -- scale of 1.
        -- A scale larger than 1 means that the compositor will
        -- automatically scale surface buffers by this amount
        -- when rendering. This is used for very high resolution
        -- displays where applications rendering at the native
        -- resolution would be too small to be legible.
        -- It is intended that scaling aware clients track the
        -- current output of a surface, and if it is on a scaled
        -- output it should use wl_surface.set_buffer_scale with
        -- the scale of the output. That way the compositor can
        -- avoid scaling the surface, and the client can supply
        -- a higher detail image.
        -- The scale event will be followed by a done event.
        -- @event wl_output:scale
        -- @tparam int factor scaling factor of output
        {
            name = "scale",
            signature = "2i",
            types = { 0, },
        },
        --- name of this output
        --
        -- Many compositors will assign user-friendly names to their outputs, show
        -- them to the user, allow the user to refer to an output, etc. The client
        -- may wish to know this name as well to offer the user similar behaviors.
        -- The name is a UTF-8 string with no convention defined for its contents.
        -- Each name is unique among all wl_output globals. The name is only
        -- guaranteed to be unique for the compositor instance.
        -- The same output name is used for all clients for a given wl_output
        -- global. Thus, the name can be shared across processes to refer to a
        -- specific wl_output global.
        -- The name is not guaranteed to be persistent across sessions, thus cannot
        -- be used to reliably identify an output in e.g. configuration files.
        -- Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do
        -- not assume that the name is a reflection of an underlying DRM connector,
        -- X11 connection, etc.
        -- The name event is sent after binding the output object. This event is
        -- only sent once per output object, and the name does not change over the
        -- lifetime of the wl_output global.
        -- Compositors may re-use the same output name if the wl_output global is
        -- destroyed and re-created later. Compositors should avoid re-using the
        -- same name if possible.
        -- The name event will be followed by a done event.
        -- @event wl_output:name
        -- @tparam string name output name
        {
            name = "name",
            signature = "4s",
            types = { 0, },
        },
        --- human-readable description of this output
        --
        -- Many compositors can produce human-readable descriptions of their
        -- outputs. The client may wish to know this description as well, e.g. for
        -- output selection purposes.
        -- The description is a UTF-8 string with no convention defined for its
        -- contents. The description is not guaranteed to be unique among all
        -- wl_output globals. Examples might include 'Foocorp 11" Display' or
        -- 'Virtual X11 output via :1'.
        -- The description event is sent after binding the output object and
        -- whenever the description changes. The description is optional, and may
        -- not be sent at all.
        -- The description event will be followed by a done event.
        -- @event wl_output:description
        -- @tparam string description output description
        {
            name = "description",
            signature = "4s",
            types = { 0, },
        },
    },
    enums = {
        --- subpixel geometry information
        --
        -- This enumeration describes how the physical
        -- pixels on an output are laid out.
        -- @enum wl_output.Subpixel
        -- @param UNKNOWN 0 unknown geometry
        -- @param NONE 1 no geometry
        -- @param HORIZONTAL_RGB 2 horizontal RGB
        -- @param HORIZONTAL_BGR 3 horizontal BGR
        -- @param VERTICAL_RGB 4 vertical RGB
        -- @param VERTICAL_BGR 5 vertical BGR
        ["subpixel"] = {
            ["unknown"] = 0,
            ["none"] = 1,
            ["horizontal_rgb"] = 2,
            ["horizontal_bgr"] = 3,
            ["vertical_rgb"] = 4,
            ["vertical_bgr"] = 5,
        },
        --- transform from framebuffer to output
        --
        -- This describes the transform that a compositor will apply to a
        -- surface to compensate for the rotation or mirroring of an
        -- output device.
        -- The flipped values correspond to an initial flip around a
        -- vertical axis followed by rotation.
        -- The purpose is mainly to allow clients to render accordingly and
        -- tell the compositor, so that for fullscreen surfaces, the
        -- compositor will still be able to scan out directly from client
        -- surfaces.
        -- @enum wl_output.Transform
        -- @param NORMAL 0 no transform
        -- @param 90 1 90 degrees counter-clockwise
        -- @param 180 2 180 degrees counter-clockwise
        -- @param 270 3 270 degrees counter-clockwise
        -- @param FLIPPED 4 180 degree flip around a vertical axis
        -- @param FLIPPED_90 5 flip and rotate 90 degrees counter-clockwise
        -- @param FLIPPED_180 6 flip and rotate 180 degrees counter-clockwise
        -- @param FLIPPED_270 7 flip and rotate 270 degrees counter-clockwise
        ["transform"] = {
            ["normal"] = 0,
            ["90"] = 1,
            ["180"] = 2,
            ["270"] = 3,
            ["flipped"] = 4,
            ["flipped_90"] = 5,
            ["flipped_180"] = 6,
            ["flipped_270"] = 7,
        },
        --- mode information
        --
        -- These flags describe properties of an output mode.
        -- They are used in the flags bitfield of the mode event.
        -- @enum wl_output.Mode
        -- @param CURRENT 0x1 indicates this is the current mode
        -- @param PREFERRED 0x2 indicates this is the preferred mode
        ["mode"] = {
            ["current"] = 0x1,
            ["preferred"] = 0x2,
        },
    },
    methods_opcode = {
        ["release"] = 0,
    },
}

--- region interface
--
-- A region object describes an area.
-- Region objects are used to describe the opaque and input
-- regions of a surface.
-- @type wl_region
wau.wl_region:init {
    name = "wl_region",
    version = 1,
    methods = {
        --- destroy region
        --
        -- Destroy the region.  This will invalidate the object ID.
        -- @function wl_region:destroy
        -- @treturn wl_region self
        {
            name = "destroy",
            signature = "",
            types = { },
            type = "destructor"
        },
        --- add rectangle to region
        --
        -- Add the specified rectangle to the region.
        -- @function wl_region:add
        -- @tparam int x region-local x coordinate
        -- @tparam int y region-local y coordinate
        -- @tparam int width rectangle width
        -- @tparam int height rectangle height
        -- @treturn wl_region self
        {
            name = "add",
            signature = "iiii",
            types = { 0, 0, 0, 0, },
        },
        --- subtract rectangle from region
        --
        -- Subtract the specified rectangle from the region.
        -- @function wl_region:subtract
        -- @tparam int x region-local x coordinate
        -- @tparam int y region-local y coordinate
        -- @tparam int width rectangle width
        -- @tparam int height rectangle height
        -- @treturn wl_region self
        {
            name = "subtract",
            signature = "iiii",
            types = { 0, 0, 0, 0, },
        },
    },
    events = {
    },
    enums = {
    },
    methods_opcode = {
        ["destroy"] = 0,
        ["add"] = 1,
        ["subtract"] = 2,
    },
}

--- sub-surface compositing
--
-- The global interface exposing sub-surface compositing capabilities.
-- A wl_surface, that has sub-surfaces associated, is called the
-- parent surface. Sub-surfaces can be arbitrarily nested and create
-- a tree of sub-surfaces.
-- The root surface in a tree of sub-surfaces is the main
-- surface. The main surface cannot be a sub-surface, because
-- sub-surfaces must always have a parent.
-- A main surface with its sub-surfaces forms a (compound) window.
-- For window management purposes, this set of wl_surface objects is
-- to be considered as a single window, and it should also behave as
-- such.
-- The aim of sub-surfaces is to offload some of the compositing work
-- within a window from clients to the compositor. A prime example is
-- a video player with decorations and video in separate wl_surface
-- objects. This should allow the compositor to pass YUV video buffer
-- processing to dedicated overlay hardware when possible.
-- @type wl_subcompositor
wau.wl_subcompositor:init {
    name = "wl_subcompositor",
    version = 1,
    methods = {
        --- unbind from the subcompositor interface
        --
        -- Informs the server that the client will not be using this
        -- protocol object anymore. This does not affect any other
        -- objects, wl_subsurface objects included.
        -- @function wl_subcompositor:destroy
        -- @treturn wl_subcompositor self
        {
            name = "destroy",
            signature = "",
            types = { },
            type = "destructor"
        },
        --- give a surface the role sub-surface
        --
        -- Create a sub-surface interface for the given surface, and
        -- associate it with the given parent surface. This turns a
        -- plain wl_surface into a sub-surface.
        -- The to-be sub-surface must not already have another role, and it
        -- must not have an existing wl_subsurface object. Otherwise the
        -- bad_surface protocol error is raised.
        -- Adding sub-surfaces to a parent is a double-buffered operation on the
        -- parent (see wl_surface.commit). The effect of adding a sub-surface
        -- becomes visible on the next time the state of the parent surface is
        -- applied.
        -- The parent surface must not be one of the child surface's descendants,
        -- and the parent must be different from the child surface, otherwise the
        -- bad_parent protocol error is raised.
        -- This request modifies the behaviour of wl_surface.commit request on
        -- the sub-surface, see the documentation on wl_subsurface interface.
        -- @function wl_subcompositor:get_subsurface
        -- @treturn wl_subsurface
        -- @tparam wl_surface surface the surface to be turned into a sub-surface
        -- @tparam wl_surface parent the parent surface
        {
            name = "get_subsurface",
            signature = "noo",
            types = { wau.wl_subsurface, wau.wl_surface, wau.wl_surface, },
        },
    },
    events = {
    },
    enums = {
        --- error
        -- @enum wl_subcompositor.Error
        -- @param BAD_SURFACE 0 the to-be sub-surface is invalid
        -- @param BAD_PARENT 1 the to-be sub-surface parent is invalid
        ["error"] = {
            ["bad_surface"] = 0,
            ["bad_parent"] = 1,
        },
    },
    methods_opcode = {
        ["destroy"] = 0,
        ["get_subsurface"] = 1,
    },
}

--- sub-surface interface to a wl_surface
--
-- An additional interface to a wl_surface object, which has been
-- made a sub-surface. A sub-surface has one parent surface. A
-- sub-surface's size and position are not limited to that of the parent.
-- Particularly, a sub-surface is not automatically clipped to its
-- parent's area.
-- A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
-- and the parent surface is mapped. The order of which one happens
-- first is irrelevant. A sub-surface is hidden if the parent becomes
-- hidden, or if a NULL wl_buffer is applied. These rules apply
-- recursively through the tree of surfaces.
-- The behaviour of a wl_surface.commit request on a sub-surface
-- depends on the sub-surface's mode. The possible modes are
-- synchronized and desynchronized, see methods
-- wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
-- mode caches the wl_surface state to be applied when the parent's
-- state gets applied, and desynchronized mode applies the pending
-- wl_surface state directly. A sub-surface is initially in the
-- synchronized mode.
-- Sub-surfaces also have another kind of state, which is managed by
-- wl_subsurface requests, as opposed to wl_surface requests. This
-- state includes the sub-surface position relative to the parent
-- surface (wl_subsurface.set_position), and the stacking order of
-- the parent and its sub-surfaces (wl_subsurface.place_above and
-- .place_below). This state is applied when the parent surface's
-- wl_surface state is applied, regardless of the sub-surface's mode.
-- As the exception, set_sync and set_desync are effective immediately.
-- The main surface can be thought to be always in desynchronized mode,
-- since it does not have a parent in the sub-surfaces sense.
-- Even if a sub-surface is in desynchronized mode, it will behave as
-- in synchronized mode, if its parent surface behaves as in
-- synchronized mode. This rule is applied recursively throughout the
-- tree of surfaces. This means, that one can set a sub-surface into
-- synchronized mode, and then assume that all its child and grand-child
-- sub-surfaces are synchronized, too, without explicitly setting them.
-- Destroying a sub-surface takes effect immediately. If you need to
-- synchronize the removal of a sub-surface to the parent surface update,
-- unmap the sub-surface first by attaching a NULL wl_buffer, update parent,
-- and then destroy the sub-surface.
-- If the parent wl_surface object is destroyed, the sub-surface is
-- unmapped.
-- @type wl_subsurface
wau.wl_subsurface:init {
    name = "wl_subsurface",
    version = 1,
    methods = {
        --- remove sub-surface interface
        --
        -- The sub-surface interface is removed from the wl_surface object
        -- that was turned into a sub-surface with a
        -- wl_subcompositor.get_subsurface request. The wl_surface's association
        -- to the parent is deleted. The wl_surface is unmapped immediately.
        -- @function wl_subsurface:destroy
        -- @treturn wl_subsurface self
        {
            name = "destroy",
            signature = "",
            types = { },
            type = "destructor"
        },
        --- reposition the sub-surface
        --
        -- This schedules a sub-surface position change.
        -- The sub-surface will be moved so that its origin (top left
        -- corner pixel) will be at the location x, y of the parent surface
        -- coordinate system. The coordinates are not restricted to the parent
        -- surface area. Negative values are allowed.
        -- The scheduled coordinates will take effect whenever the state of the
        -- parent surface is applied. When this happens depends on whether the
        -- parent surface is in synchronized mode or not. See
        -- wl_subsurface.set_sync and wl_subsurface.set_desync for details.
        -- If more than one set_position request is invoked by the client before
        -- the commit of the parent surface, the position of a new request always
        -- replaces the scheduled position from any previous request.
        -- The initial position is 0, 0.
        -- @function wl_subsurface:set_position
        -- @tparam int x x coordinate in the parent surface
        -- @tparam int y y coordinate in the parent surface
        -- @treturn wl_subsurface self
        {
            name = "set_position",
            signature = "ii",
            types = { 0, 0, },
        },
        --- restack the sub-surface
        --
        -- This sub-surface is taken from the stack, and put back just
        -- above the reference surface, changing the z-order of the sub-surfaces.
        -- The reference surface must be one of the sibling surfaces, or the
        -- parent surface. Using any other surface, including this sub-surface,
        -- will cause a protocol error.
        -- The z-order is double-buffered. Requests are handled in order and
        -- applied immediately to a pending state. The final pending state is
        -- copied to the active state the next time the state of the parent
        -- surface is applied. When this happens depends on whether the parent
        -- surface is in synchronized mode or not. See wl_subsurface.set_sync and
        -- wl_subsurface.set_desync for details.
        -- A new sub-surface is initially added as the top-most in the stack
        -- of its siblings and parent.
        -- @function wl_subsurface:place_above
        -- @tparam wl_surface sibling the reference surface
        -- @treturn wl_subsurface self
        {
            name = "place_above",
            signature = "o",
            types = { wau.wl_surface, },
        },
        --- restack the sub-surface
        --
        -- The sub-surface is placed just below the reference surface.
        -- See wl_subsurface.place_above.
        -- @function wl_subsurface:place_below
        -- @tparam wl_surface sibling the reference surface
        -- @treturn wl_subsurface self
        {
            name = "place_below",
            signature = "o",
            types = { wau.wl_surface, },
        },
        --- set sub-surface to synchronized mode
        --
        -- Change the commit behaviour of the sub-surface to synchronized
        -- mode, also described as the parent dependent mode.
        -- In synchronized mode, wl_surface.commit on a sub-surface will
        -- accumulate the committed state in a cache, but the state will
        -- not be applied and hence will not change the compositor output.
        -- The cached state is applied to the sub-surface immediately after
        -- the parent surface's state is applied. This ensures atomic
        -- updates of the parent and all its synchronized sub-surfaces.
        -- Applying the cached state will invalidate the cache, so further
        -- parent surface commits do not (re-)apply old state.
        -- See wl_subsurface for the recursive effect of this mode.
        -- @function wl_subsurface:set_sync
        -- @treturn wl_subsurface self
        {
            name = "set_sync",
            signature = "",
            types = { },
        },
        --- set sub-surface to desynchronized mode
        --
        -- Change the commit behaviour of the sub-surface to desynchronized
        -- mode, also described as independent or freely running mode.
        -- In desynchronized mode, wl_surface.commit on a sub-surface will
        -- apply the pending state directly, without caching, as happens
        -- normally with a wl_surface. Calling wl_surface.commit on the
        -- parent surface has no effect on the sub-surface's wl_surface
        -- state. This mode allows a sub-surface to be updated on its own.
        -- If cached state exists when wl_surface.commit is called in
        -- desynchronized mode, the pending state is added to the cached
        -- state, and applied as a whole. This invalidates the cache.
        -- Note: even if a sub-surface is set to desynchronized, a parent
        -- sub-surface may override it to behave as synchronized. For details,
        -- see wl_subsurface.
        -- If a surface's parent surface behaves as desynchronized, then
        -- the cached state is applied on set_desync.
        -- @function wl_subsurface:set_desync
        -- @treturn wl_subsurface self
        {
            name = "set_desync",
            signature = "",
            types = { },
        },
    },
    events = {
    },
    enums = {
        --- error
        -- @enum wl_subsurface.Error
        -- @param BAD_SURFACE 0 wl_surface is not a sibling or the parent
        ["error"] = {
            ["bad_surface"] = 0,
        },
    },
    methods_opcode = {
        ["destroy"] = 0,
        ["set_position"] = 1,
        ["place_above"] = 2,
        ["place_below"] = 3,
        ["set_sync"] = 4,
        ["set_desync"] = 5,
    },
}

end
