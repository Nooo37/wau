local xml2lua = require("xml2lua")
local handler = require("xmlhandler.tree")

-- parsing

local parser = {}

function parser.get_field(t, field)
    -- the xml parser either sets
    -- t["field"] = myfield; if there is only one occurence of "field" in t
    -- t["field"] = { myfield1, myfield2, ... }; if there are multiple occurences
    -- or t["field"] = nil; if there are none
    -- In this function we are making sure that we get a list in any case
    return t[field] and (#t[field] == 0 and {t[field]} or t[field]) or {}
end

function parser.description(handle)
    if not handle then return nil end
    local result = handle._attr or {}
    result.long = handle[1]
    return result
end

function parser.arg(handle)
    if not handle._attr then error("Argument without attributes") end
    local result = handle._attr
    return result
end

function parser.request(handle)
    local result = handle._attr or {}
    result.description = parser.description(handle.description)
    result.args = {}
    local args = parser.get_field(handle, "arg")
    for i, arg in ipairs(args) do
        result.args[i] = parser.arg(arg)
    end
    return result
end

function parser.event(handle)
    local result = handle._attr or {}
    result.description = parser.description(handle.description)
    result.args = {}
    local args = parser.get_field(handle, "arg")
    for i, arg in ipairs(args) do
        result.args[i] = parser.arg(arg)
    end
    return result
end

function parser.enum(handle)
    local result = handle._attr or {}
    result.description = parser.description(handle.description)
    result.entries = {}
    local entries = parser.get_field(handle, "entry")
    for i, entry in ipairs(entries) do
        if not entry._attr then error("Enum entry without attributes") end
        result.entries[i] = entry._attr
    end
    return result
end

function parser.interface(handle)
    local result = handle._attr or {}
    result.description = parser.description(handle.description)
    result.requests = {}
    local requests = parser.get_field(handle, "request")
    for i, request in ipairs(requests) do
        result.requests[i] = parser.request(request)
    end
    result.events = {}
    local events = parser.get_field(handle, "event")
    for i, event in ipairs(events) do
        result.events[i] = parser.event(event)
    end
    result.enums = {}
    local enums = parser.get_field(handle, "enum")
    for i, enum in ipairs(enums) do
        result.enums[i] = parser.enum(enum)
    end
    return result
end

function parser.protocol(handle)
    local result = handle._attr or {}
    result.copyright = handle.copyright
    result.description = parser.description(handle.description)
    result.interfaces = {}
    local interfaces = parser.get_field(handle, "interface")
    for i, iface in ipairs(interfaces) do
        result.interfaces[i] = parser.interface(iface)
    end
    return result
end

-- printing

local function to_camel_case(s)
    return s:gsub("_(.)",s.upper):gsub("^(.)", string.upper)
end

local function to_upper_case(s)
    return s:upper()
end

local function get_argument_string(args)
    local result = ""
    for _, arg in ipairs(args) do
        if arg.type ~= "new_id" then
            result = string.format("%s, %s", result, arg.name)
        end
    end
    return result
end

local function convert_type_to_signature(type_name, optional)
    local res = optional and "?" or ""
    if type_name == "int" then return res .. "i"
    elseif type_name == "string" then return res .. "s"
    elseif type_name == "fd" then return res .. "h"
    elseif type_name == "fixed" then return res .. "f"
    elseif type_name == "array" then return res .. "a"
    elseif type_name == "object" then return res .. "o"
    elseif type_name == "new_id" then return res .. "n"
    elseif type_name == "uint" then return res .. "u"
    else error("Couldn't resolve type", type_name) end
end

local function get_message_types(args)
    local types = "{ "
    for _, arg in ipairs(args) do
        if arg.type == "object" or arg.type == "new_id" then
            local iface = arg.interface
                and string.format("wau.%s", arg.interface)
                or "0"
            types = string.format("%s%s, ", types, iface)
        else
            types = types .. "0, "
        end
    end
    if #args == 0 then -- there should be no empty type arrays
        types = string.format("%s%s ", types, "0 ")
    end
    return types .. "}"
end

local function get_message_signature(mes)
    local signature = mes.since and mes.since or ""
    for _, arg in ipairs(mes.args) do
        signature = signature .. convert_type_to_signature(arg.type,
            arg["allow-null"] and arg["allow-null"] == "true")
    end
    if signature == "un" then signature = "usun" end -- TODO
    return signature
end


local printer = {
    result = "-- Auto generated by the wau-wayland-scanner v0\n",
    include_comments = true,
    opcode_field = "_OpCode",
    indent = 0,
    indent_delta = 4,
}

function printer.indent_add()
    printer.indent = printer.indent + printer.indent_delta
    return printer
end

function printer.indent_sub()
    printer.indent = printer.indent - printer.indent_delta
    return printer
end

function printer.line(f, ...)
    if not f then f = "" end
    if f == "" then
        printer.result = string.format("%s\n", printer.result)
        return printer
    end
    local indent = ""
    for _=1,printer.indent do
        indent = string.format("%s ", indent)
    end
    printer.result = string.format("%s\n%s%s", printer.result, indent, string.format(f, ...))
    return printer
end

function printer.comment(s)
    if printer.include_comments then
        local toprint = s:gsub("^%s*", "-- "):gsub("\n%s*", "\n-- ")
        for line in (toprint ..'\n'):gmatch'(.-)\r?\n' do
            printer.line(line)
        end
    end
    return printer
end

function printer.internal_message(mes)
    printer.indent_add()
    printer.line([[{]])
    printer.indent_add()
    printer.line([[name = "%s",]], mes.name)
    printer.line([[signature = "%s",]],
        get_message_signature(mes))
    printer.line([[types = %s,]],
        get_message_types(mes.args))
    printer.indent_sub()
    printer.line([[},]])
    printer.indent_sub()
end

function printer.internal_enum(enum)
    printer.indent_add()
    printer.line([[["%s"] = {]], enum.name)
    printer.indent_add()
    for _, entry in ipairs(enum.entries) do
        printer.line([[["%s"] = %s,]], entry.name, entry.value)
    end
    printer.indent_sub()
    printer.line([[},]])
    printer.indent_sub()
end

function printer.internal_interface(iface)
    printer.line([[wau.interface.init(wau.%s, {]], iface.name)
    printer.indent_add()
    printer.line([[name = "%s",]], iface.name)
    printer.line([[version = %s,]], iface.version)
    printer.line([[requests = {]])
    printer.indent_add()
    for _, request in ipairs(iface.requests) do
        printer.internal_message(request)
    end
    printer.indent_sub()
    printer.line([[},]])
    printer.line([[events = {]])
    printer.indent_add()
    for _, event in ipairs(iface.events) do
        printer.internal_message(event)
    end
    printer.indent_sub()
    printer.line([[},]])
    printer.line([[enums = {]])
    printer.indent_add()
    for _, enum in ipairs(iface.enums) do
        printer.internal_enum(enum)
    end
    printer.indent_sub()
    printer.line([[},]])

    printer.indent_sub()
    printer.line([[})]])
    printer.line()
end

function printer.description(desc)
    if desc.summary and printer.include_comments then
        printer.line([[--- %s]], desc.summary)
    end
    if desc.long then
        printer.comment(desc.long)
    end
end

local function is_constructor(request)
    for _, arg in ipairs(request.args) do
        if arg.type == "new_id" then return arg.interface or true end
    end
    return false
end

function printer.request_simple(obj, iface_name, arguments)
    local path = string.format("wau.%s.%s", iface_name, obj.name)
    printer.line([[function %s(self%s)]], path, arguments)
    printer.indent_add()
    printer.line([[self:marshal(wau.%s.%s.%s%s)]], iface_name,
            printer.opcode_field, to_upper_case(obj.name), arguments)
    printer.line([[return self]])
    printer.indent_sub()
    printer.line([[end]])
    printer.line()
end

function printer.request_constructor(obj, iface_name, arguments)
    local path = string.format("wau.%s.%s", iface_name, obj.name)
    local constructor = is_constructor(obj)
    printer.line([[function wau.%s.%s(self%s)]], iface_name, obj.name, arguments)
    printer.indent_add()
    printer.line([[local id = self:marshal_constructor(]])
    printer.line([[    wau.%s.%s.%s, wau.%s, nil%s)]], iface_name,
                printer.opcode_field, to_upper_case(obj.name), constructor, arguments)
    printer.line([[wau.proxy.set_interface(id, wau.%s)]], constructor)
    printer.line([[return id]])
    printer.indent_sub()
    printer.line([[end]])
    printer.line()
end

function printer.request_constructor_versioned(obj, iface_name, arguments)
    -- TODO currently only really supports the wl_registry:bind constructor
    -- I'm unaware of any other usecases but still
    local path = string.format("wau.%s.%s", iface_name, obj.name)
    printer.line([[function %s(self, name, interface, version)]], path)
    printer.indent_add()
    printer.line([[local id = self:marshal_constructor_versioned(]])
    printer.line([[    wau.%s.%s.%s, interface, version, name, interface.name, version, nil)]],
            iface_name, printer.opcode_field, to_upper_case(obj.name))
    printer.line([[wau.proxy.set_interface(id, interface)]], iface_name)
    printer.line([[return id]])
    printer.indent_sub()
    printer.line([[end]])
end

function printer.request_destructor(obj, iface_name, arguments)
    printer.line([[function wau.%s.%s(self%s)]], iface_name, obj.name, arguments)
    printer.indent_add()
    printer.line([[wau.proxy.destroy(self)]])
    printer.line([[self:marshal(self.%s.%s%s)]],
                printer.opcode_field, to_upper_case(obj.name), arguments)
    printer.indent_sub()
    printer.line([[end]])
end

function printer.request(obj, iface_name)
    if obj.description then printer.description(obj.description) end
    local arguments = get_argument_string(obj.args)
    local constructor = is_constructor(obj)
    -- first block is the special case of a versioned constructor
    -- which is a constructor that doesn't have a pre-specified interface
    -- I think only wl_registry_bind is actually using that one
    if constructor and type(constructor) ~= "string" then
        printer.request_constructor_versioned(obj, iface_name, arguments)
    elseif obj.type and obj.type == "destructor" then
        printer.request_destructor(obj, iface_name, arguments)
    elseif constructor then
        printer.request_constructor(obj, iface_name, arguments)
    else
        printer.request_simple(obj, iface_name, arguments)
    end
end

function printer.enum(obj, iface_name)
    if obj.description then printer.description(obj.description) end
    printer.line([[wau.%s.%s = {]], iface_name, to_camel_case(obj.name))
    printer.indent_add()
    for _, entry in ipairs(obj.entries) do
        if printer.include_comments and entry.summary then
            printer.comment(entry.summary)
        end
        printer.line([[["%s"] = %s,]],
            to_upper_case(entry.name), entry.value)
    end
    printer.indent_sub()
    printer.line([[}]])
end

function printer.interface(iface)
    if iface.description then
        printer.description(iface.description)
    end
    printer.line()
    -- opcodes are kept in an enum
    .line([[wau.%s.%s = {]], iface.name, printer.opcode_field)
    .indent_add()
    for i, request in ipairs(iface.requests) do
        printer.line([[["%s"] = %s,]], to_upper_case(request.name),
            tostring(i - 1))
    end
    printer.indent_sub()
    printer.line([[}]])
    printer.line()
    for _, enum in ipairs(iface.enums) do
        printer.enum(enum, iface.name)
        printer.line()
    end
    for _, request in ipairs(iface.requests) do
        printer.request(request, iface.name)
        printer.line()
    end
    printer.line()
end

function printer.protocol(protocol)
    if protocol.copyright and printer.include_comments then
        printer.comment(protocol.copyright)
        printer.line()
    end
    printer.description(protocol)
    printer.line([[return function(wau)]])
    printer.line()
    for _, iface in ipairs(protocol.interfaces) do
        printer.line([[wau.%s = wau.interface.new()]], iface.name, iface.name)
        printer.line()
    end
    for _, iface in ipairs(protocol.interfaces) do
        printer.internal_interface(iface)
    end
    for _, iface in ipairs(protocol.interfaces) do
        printer.interface(iface)
    end
    printer.line([[end]])
end

-- main

local function main()
    local content
    for line in io.lines() do
        content = content and string.format("%s\n%s", content, line) or line
    end
    assert(content)

    for _, a in ipairs(arg) do
        if a == "-nc" then
            printer.include_comments = false
        end
    end

    local xml_parser = xml2lua.parser(handler)
    xml_parser:parse(content)

    assert(handler.root.protocol, "Failed to parse protocol")
    local protocol = parser.protocol(handler.root.protocol)

    printer.protocol(protocol)
    print(printer.result)
end

main()
