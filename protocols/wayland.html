<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>wau - wayland on lua</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>wau</h1>


<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Class_wl_display">Class wl_display </a></li>
<li><a href="#Class_wl_registry">Class wl_registry </a></li>
<li><a href="#Class_wl_callback">Class wl_callback </a></li>
<li><a href="#Class_wl_compositor">Class wl_compositor </a></li>
<li><a href="#Class_wl_shm_pool">Class wl_shm_pool </a></li>
<li><a href="#Class_wl_shm">Class wl_shm </a></li>
<li><a href="#Class_wl_buffer">Class wl_buffer </a></li>
<li><a href="#Class_wl_data_offer">Class wl_data_offer </a></li>
<li><a href="#Class_wl_data_source">Class wl_data_source </a></li>
<li><a href="#Class_wl_data_device">Class wl_data_device </a></li>
<li><a href="#Class_wl_data_device_manager">Class wl_data_device_manager </a></li>
<li><a href="#Class_wl_shell">Class wl_shell </a></li>
<li><a href="#Class_wl_shell_surface">Class wl_shell_surface </a></li>
<li><a href="#Class_wl_surface">Class wl_surface </a></li>
<li><a href="#Class_wl_seat">Class wl_seat </a></li>
<li><a href="#Class_wl_pointer">Class wl_pointer </a></li>
<li><a href="#Class_wl_keyboard">Class wl_keyboard </a></li>
<li><a href="#Class_wl_touch">Class wl_touch </a></li>
<li><a href="#Class_wl_output">Class wl_output </a></li>
<li><a href="#Class_wl_region">Class wl_region </a></li>
<li><a href="#Class_wl_subcompositor">Class wl_subcompositor </a></li>
<li><a href="#Class_wl_subsurface">Class wl_subsurface </a></li>
</ul>


<h2>Protocols</h2>
<ul class="nowrap">
  <li><strong>wayland</strong></li>
</ul>
<h2>Classes</h2>
<ul class="nowrap">
  <li><a href="../classes/wl_display.html">wl_display</a></li>
  <li><a href="../classes/wl_interface.html">wl_interface</a></li>
  <li><a href="../classes/wl_proxy.html">wl_proxy</a></li>
  <li><a href="../classes/wl_cursor.html">wl_cursor</a></li>
  <li><a href="../classes/wl_cursor_image.html">wl_cursor_image</a></li>
  <li><a href="../classes/wl_cursor_theme.html">wl_cursor_theme</a></li>
</ul>
<h2>Manual</h2>
<ul class="nowrap">
  <li><a href="../manual/README.md.html">README</a></li>
  <li><a href="../manual/coming-from-c.md.html">coming-from-c</a></li>
  <li><a href="../manual/overview.md.html">overview</a></li>
  <li><a href="../manual/scanner.md.html">scanner</a></li>
</ul>
<h2>Examples</h2>
<ul class="nowrap">
  <li><a href="../examples/foreign_toplevel_manager.lua.html">foreign_toplevel_manager.lua</a></li>
  <li><a href="../examples/layershell.lua.html">layershell.lua</a></li>
  <li><a href="../examples/list_globals.lua.html">list_globals.lua</a></li>
  <li><a href="../examples/toplevel.lua.html">toplevel.lua</a></li>
  <li><a href="../examples/xdg_top.lua.html">xdg_top.lua</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>wayland</code></h1>
<p>wayland</p>
<p>

</p>


<h2><a href="#Class_wl_display">Class wl_display </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_display:sync">wl_display:sync ()</a></td>
	<td class="summary">asynchronous roundtrip</p>

<p> The sync request asks the server to emit the 'done' event
 on the returned wl_callback object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_display:get_registry">wl_display:get_registry ()</a></td>
	<td class="summary">get global registry object</p>

<p> This request creates a registry object that allows the client
 to list and bind the global objects available from the
 compositor.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_display:error">wl_display:error</a></td>
	<td class="summary">fatal error event</p>

<p> The error event is sent out when a fatal (non-recoverable)
 error has occurred.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_display:delete_id">wl_display:delete_id</a></td>
	<td class="summary">acknowledge object ID deletion</p>

<p> This event is used internally by the object ID management
 logic.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_display.Error">wl_display.Error</a></td>
	<td class="summary">global error values</td>
	</tr>
</table>
<h2><a href="#Class_wl_registry">Class wl_registry </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_registry:bind">wl_registry:bind (name)</a></td>
	<td class="summary">bind an object to the display</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_registry:global">wl_registry:global</a></td>
	<td class="summary">announce global object</p>

<p> Notify the client of global objects.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_registry:global_remove">wl_registry:global_remove</a></td>
	<td class="summary">announce removal of global object</p>

<p> Notify the client of removed global objects.</td>
	</tr>
</table>
<h2><a href="#Class_wl_callback">Class wl_callback </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_callback:done">wl_callback:done</a></td>
	<td class="summary">done event</td>
	</tr>
</table>
<h2><a href="#Class_wl_compositor">Class wl_compositor </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_compositor:create_surface">wl_compositor:create_surface ()</a></td>
	<td class="summary">create new surface</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_compositor:create_region">wl_compositor:create_region ()</a></td>
	<td class="summary">create new region</td>
	</tr>
</table>
<h2><a href="#Class_wl_shm_pool">Class wl_shm_pool </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_shm_pool:create_buffer">wl_shm_pool:create_buffer (offset, width, height, stride, format)</a></td>
	<td class="summary">create a buffer from the pool</p>

<p> Create a wl_buffer object from the pool.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shm_pool:destroy">wl_shm_pool:destroy ()</a></td>
	<td class="summary">destroy the pool</p>

<p> Destroy the shared memory pool.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shm_pool:resize">wl_shm_pool:resize (size)</a></td>
	<td class="summary">change the size of the pool mapping</p>

<p> This request will cause the server to remap the backing memory
 for the pool from the file descriptor passed when the pool was
 created, but using the new size.</td>
	</tr>
</table>
<h2><a href="#Class_wl_shm">Class wl_shm </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_shm:create_pool">wl_shm:create_pool (fd, size)</a></td>
	<td class="summary">create a shm pool</p>

<p> Create a new wl<em>shm</em>pool object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shm:format">wl_shm:format</a></td>
	<td class="summary">pixel format description</p>

<p> Informs the client about a valid pixel format that
 can be used for buffers.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shm.Error">wl_shm.Error</a></td>
	<td class="summary">wl_shm error values</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shm.Format">wl_shm.Format</a></td>
	<td class="summary">pixel formats</p>

<p> This describes the memory layout of an individual pixel.</td>
	</tr>
</table>
<h2><a href="#Class_wl_buffer">Class wl_buffer </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_buffer:destroy">wl_buffer:destroy ()</a></td>
	<td class="summary">destroy a buffer</p>

<p> Destroy a buffer.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_buffer:release">wl_buffer:release</a></td>
	<td class="summary">compositor releases buffer</p>

<p> Sent when this wl_buffer is no longer used by the compositor.</td>
	</tr>
</table>
<h2><a href="#Class_wl_data_offer">Class wl_data_offer </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_data_offer:accept">wl_data_offer:accept (serial, mime_type)</a></td>
	<td class="summary">accept one of the offered mime types</p>

<p> Indicate that the client can accept the given mime type, or
 NULL for not accepted.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_offer:receive">wl_data_offer:receive (mime_type, fd)</a></td>
	<td class="summary">request that the data is transferred</p>

<p> To transfer the offered data, the client issues this request
 and indicates the mime type it wants to receive.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_offer:destroy">wl_data_offer:destroy ()</a></td>
	<td class="summary">destroy data offer</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_offer:finish">wl_data_offer:finish ()</a></td>
	<td class="summary">the offer will no longer be used</p>

<p> Notifies the compositor that the drag destination successfully
 finished the drag-and-drop operation.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_offer:set_actions">wl_data_offer:set_actions (dnd_actions, preferred_action)</a></td>
	<td class="summary">set the available/preferred drag-and-drop actions</p>

<p> Sets the actions that the destination side client supports for
 this operation.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_offer:offer">wl_data_offer:offer</a></td>
	<td class="summary">advertise offered mime type</p>

<p> Sent immediately after creating the wl<em>data</em>offer object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_offer:source_actions">wl_data_offer:source_actions</a></td>
	<td class="summary">notify the source-side available actions</p>

<p> This event indicates the actions offered by the data source.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_offer:action">wl_data_offer:action</a></td>
	<td class="summary">notify the selected action</p>

<p> This event indicates the action selected by the compositor after
 matching the source/destination side actions.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_offer.Error">wl_data_offer.Error</a></td>
	<td class="summary">error</td>
	</tr>
</table>
<h2><a href="#Class_wl_data_source">Class wl_data_source </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_data_source:offer">wl_data_source:offer (mime_type)</a></td>
	<td class="summary">add an offered mime type</p>

<p> This request adds a mime type to the set of mime types
 advertised to targets.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_source:destroy">wl_data_source:destroy ()</a></td>
	<td class="summary">destroy the data source</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_source:set_actions">wl_data_source:set_actions (dnd_actions)</a></td>
	<td class="summary">set the available drag-and-drop actions</p>

<p> Sets the actions that the source side client supports for this
 operation.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_source:target">wl_data_source:target</a></td>
	<td class="summary">a target accepts an offered mime type</p>

<p> Sent when a target accepts pointer_focus or motion events.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_source:send">wl_data_source:send</a></td>
	<td class="summary">send the data</p>

<p> Request for data from the client.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_source:cancelled">wl_data_source:cancelled</a></td>
	<td class="summary">selection was cancelled</p>

<p> This data source is no longer valid.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_source:dnd_drop_performed">wl_data_source:dnd_drop_performed</a></td>
	<td class="summary">the drag-and-drop operation physically finished</p>

<p> The user performed the drop action.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_source:dnd_finished">wl_data_source:dnd_finished</a></td>
	<td class="summary">the drag-and-drop operation concluded</p>

<p> The drop destination finished interoperating with this data
 source, so the client is now free to destroy this data source and
 free all associated data.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_source:action">wl_data_source:action</a></td>
	<td class="summary">notify the selected action</p>

<p> This event indicates the action selected by the compositor after
 matching the source/destination side actions.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_source.Error">wl_data_source.Error</a></td>
	<td class="summary">error</td>
	</tr>
</table>
<h2><a href="#Class_wl_data_device">Class wl_data_device </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_data_device:start_drag">wl_data_device:start_drag (source, origin, icon, serial)</a></td>
	<td class="summary">start drag-and-drop operation</p>

<p> This request asks the compositor to start a drag-and-drop
 operation on behalf of the client.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_device:set_selection">wl_data_device:set_selection (source, serial)</a></td>
	<td class="summary">copy data to the selection</p>

<p> This request asks the compositor to set the selection
 to the data from the source on behalf of the client.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_device:release">wl_data_device:release ()</a></td>
	<td class="summary">destroy data device</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_device:data_offer">wl_data_device:data_offer</a></td>
	<td class="summary">introduce a new wl<em>data</em>offer</p>

<p> The data<em>offer event introduces a new wl</em>data<em>offer object,
 which will subsequently be used in either the
 data</em>device.enter event (for drag-and-drop) or the
 data_device.selection event (for selections).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_device:enter">wl_data_device:enter</a></td>
	<td class="summary">initiate drag-and-drop session</p>

<p> This event is sent when an active drag-and-drop pointer enters
 a surface owned by the client.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_device:leave">wl_data_device:leave</a></td>
	<td class="summary">end drag-and-drop session</p>

<p> This event is sent when the drag-and-drop pointer leaves the
 surface and the session ends.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_device:motion">wl_data_device:motion</a></td>
	<td class="summary">drag-and-drop session motion</p>

<p> This event is sent when the drag-and-drop pointer moves within
 the currently focused surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_device:drop">wl_data_device:drop</a></td>
	<td class="summary">end drag-and-drop session successfully</p>

<p> The event is sent when a drag-and-drop operation is ended
 because the implicit grab is removed.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_device:selection">wl_data_device:selection</a></td>
	<td class="summary">advertise new selection</p>

<p> The selection event is sent out to notify the client of a new
 wl<em>data</em>offer for the selection for this device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_device.Error">wl_data_device.Error</a></td>
	<td class="summary">error</td>
	</tr>
</table>
<h2><a href="#Class_wl_data_device_manager">Class wl_data_device_manager </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_data_device_manager:create_data_source">wl_data_device_manager:create_data_source ()</a></td>
	<td class="summary">create a new data source</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_device_manager:get_data_device">wl_data_device_manager:get_data_device (seat)</a></td>
	<td class="summary">create a new data device</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_data_device_manager.DndAction">wl_data_device_manager.DndAction</a></td>
	<td class="summary">drag and drop actions</p>

<p> This is a bitmask of the available/preferred actions in a
 drag-and-drop operation.</td>
	</tr>
</table>
<h2><a href="#Class_wl_shell">Class wl_shell </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_shell:get_shell_surface">wl_shell:get_shell_surface (surface)</a></td>
	<td class="summary">create a shell surface from a surface</p>

<p> Create a shell surface for an existing surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shell.Error">wl_shell.Error</a></td>
	<td class="summary">error</td>
	</tr>
</table>
<h2><a href="#Class_wl_shell_surface">Class wl_shell_surface </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_shell_surface:pong">wl_shell_surface:pong (serial)</a></td>
	<td class="summary">respond to a ping event</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shell_surface:move">wl_shell_surface:move (seat, serial)</a></td>
	<td class="summary">start an interactive move</p>

<p> Start a pointer-driven move of the surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shell_surface:resize">wl_shell_surface:resize (seat, serial, edges)</a></td>
	<td class="summary">start an interactive resize</p>

<p> Start a pointer-driven resizing of the surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shell_surface:set_toplevel">wl_shell_surface:set_toplevel ()</a></td>
	<td class="summary">make the surface a toplevel surface</p>

<p> Map the surface as a toplevel surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shell_surface:set_transient">wl_shell_surface:set_transient (parent, x, y, flags)</a></td>
	<td class="summary">make the surface a transient surface</p>

<p> Map the surface relative to an existing surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shell_surface:set_fullscreen">wl_shell_surface:set_fullscreen (method, framerate, output)</a></td>
	<td class="summary">make the surface a fullscreen surface</p>

<p> Map the surface as a fullscreen surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shell_surface:set_popup">wl_shell_surface:set_popup (seat, serial, parent, x, y, flags)</a></td>
	<td class="summary">make the surface a popup surface</p>

<p> Map the surface as a popup.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shell_surface:set_maximized">wl_shell_surface:set_maximized (output)</a></td>
	<td class="summary">make the surface a maximized surface</p>

<p> Map the surface as a maximized surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shell_surface:set_title">wl_shell_surface:set_title (title)</a></td>
	<td class="summary">set surface title</p>

<p> Set a short title for the surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shell_surface:set_class">wl_shell_surface:set_class (class_)</a></td>
	<td class="summary">set surface class</p>

<p> Set a class for the surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shell_surface:ping">wl_shell_surface:ping</a></td>
	<td class="summary">ping client</p>

<p> Ping a client to check if it is receiving events and sending
 requests.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shell_surface:configure">wl_shell_surface:configure</a></td>
	<td class="summary">suggest resize</p>

<p> The configure event asks the client to resize its surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shell_surface:popup_done">wl_shell_surface:popup_done</a></td>
	<td class="summary">popup interaction is done</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shell_surface.Resize">wl_shell_surface.Resize</a></td>
	<td class="summary">edge values for resizing</p>

<p> These values are used to indicate which edge of a surface
 is being dragged in a resize operation.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shell_surface.Transient">wl_shell_surface.Transient</a></td>
	<td class="summary">details of transient behaviour</p>

<p> These flags specify details of the expected behaviour
 of transient surfaces.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_shell_surface.FullscreenMethod">wl_shell_surface.FullscreenMethod</a></td>
	<td class="summary">different method to set the surface fullscreen</p>

<p> Hints to indicate to the compositor how to deal with a conflict
 between the dimensions of the surface and the dimensions of the
 output.</td>
	</tr>
</table>
<h2><a href="#Class_wl_surface">Class wl_surface </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_surface:destroy">wl_surface:destroy ()</a></td>
	<td class="summary">delete surface</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_surface:attach">wl_surface:attach (buffer, x, y)</a></td>
	<td class="summary">set the surface contents</p>

<p> Set a buffer as the content of this surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_surface:damage">wl_surface:damage (x, y, width, height)</a></td>
	<td class="summary">mark part of the surface damaged</p>

<p> This request is used to describe the regions where the pending
 buffer is different from the current surface contents, and where
 the surface therefore needs to be repainted.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_surface:frame">wl_surface:frame ()</a></td>
	<td class="summary">request a frame throttling hint</p>

<p> Request a notification when it is a good time to start drawing a new
 frame, by creating a frame callback.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_surface:set_opaque_region">wl_surface:set_opaque_region (region)</a></td>
	<td class="summary">set opaque region</p>

<p> This request sets the region of the surface that contains
 opaque content.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_surface:set_input_region">wl_surface:set_input_region (region)</a></td>
	<td class="summary">set input region</p>

<p> This request sets the region of the surface that can receive
 pointer and touch events.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_surface:commit">wl_surface:commit ()</a></td>
	<td class="summary">commit pending surface state</p>

<p> Surface state (input, opaque, and damage regions, attached buffers,
 etc.) is double-buffered.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_surface:set_buffer_transform">wl_surface:set_buffer_transform (transform)</a></td>
	<td class="summary">sets the buffer transformation</p>

<p> This request sets an optional transformation on how the compositor
 interprets the contents of the buffer attached to the surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_surface:set_buffer_scale">wl_surface:set_buffer_scale (scale)</a></td>
	<td class="summary">sets the buffer scaling factor</p>

<p> This request sets an optional scaling factor on how the compositor
 interprets the contents of the buffer attached to the window.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_surface:damage_buffer">wl_surface:damage_buffer (x, y, width, height)</a></td>
	<td class="summary">mark part of the surface damaged using buffer coordinates</p>

<p> This request is used to describe the regions where the pending
 buffer is different from the current surface contents, and where
 the surface therefore needs to be repainted.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_surface:offset">wl_surface:offset (x, y)</a></td>
	<td class="summary">set the surface contents offset</p>

<p> The x and y arguments specify the location of the new pending
 buffer's upper left corner, relative to the current buffer's upper
 left corner, in surface-local coordinates.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_surface:enter">wl_surface:enter</a></td>
	<td class="summary">surface enters an output</p>

<p> This is emitted whenever a surface's creation, movement, or resizing
 results in some part of it being within the scanout region of an
 output.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_surface:leave">wl_surface:leave</a></td>
	<td class="summary">surface leaves an output</p>

<p> This is emitted whenever a surface's creation, movement, or resizing
 results in it no longer having any part of it within the scanout region
 of an output.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_surface:preferred_buffer_scale">wl_surface:preferred_buffer_scale</a></td>
	<td class="summary">preferred buffer scale for the surface</p>

<p> This event indicates the preferred buffer scale for this surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_surface:preferred_buffer_transform">wl_surface:preferred_buffer_transform</a></td>
	<td class="summary">preferred buffer transform for the surface</p>

<p> This event indicates the preferred buffer transform for this surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_surface.Error">wl_surface.Error</a></td>
	<td class="summary">wl_surface error values</td>
	</tr>
</table>
<h2><a href="#Class_wl_seat">Class wl_seat </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_seat:get_pointer">wl_seat:get_pointer ()</a></td>
	<td class="summary">return pointer object</p>

<p> The ID provided will be initialized to the wl_pointer interface
 for this seat.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_seat:get_keyboard">wl_seat:get_keyboard ()</a></td>
	<td class="summary">return keyboard object</p>

<p> The ID provided will be initialized to the wl_keyboard interface
 for this seat.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_seat:get_touch">wl_seat:get_touch ()</a></td>
	<td class="summary">return touch object</p>

<p> The ID provided will be initialized to the wl_touch interface
 for this seat.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_seat:release">wl_seat:release ()</a></td>
	<td class="summary">release the seat object</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_seat:capabilities">wl_seat:capabilities</a></td>
	<td class="summary">seat capabilities changed</p>

<p> This is emitted whenever a seat gains or loses the pointer,
 keyboard or touch capabilities.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_seat:name">wl_seat:name</a></td>
	<td class="summary">unique identifier for this seat</p>

<p> In a multi-seat configuration the seat name can be used by clients to
 help identify which physical devices the seat represents.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_seat.Capability">wl_seat.Capability</a></td>
	<td class="summary">seat capability bitmask</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_seat.Error">wl_seat.Error</a></td>
	<td class="summary">wl_seat error values</td>
	</tr>
</table>
<h2><a href="#Class_wl_pointer">Class wl_pointer </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_pointer:set_cursor">wl_pointer:set_cursor (serial, surface, hotspot_x, hotspot_y)</a></td>
	<td class="summary">set the pointer surface</p>

<p> Set the pointer surface, i.e., the surface that contains the
 pointer image (cursor).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_pointer:release">wl_pointer:release ()</a></td>
	<td class="summary">release the pointer object</p>

<p> Using this request a client can tell the server that it is not going to
 use the pointer object anymore.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_pointer:enter">wl_pointer:enter</a></td>
	<td class="summary">enter event</p>

<p> Notification that this seat's pointer is focused on a certain
 surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_pointer:leave">wl_pointer:leave</a></td>
	<td class="summary">leave event</p>

<p> Notification that this seat's pointer is no longer focused on
 a certain surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_pointer:motion">wl_pointer:motion</a></td>
	<td class="summary">pointer motion event</p>

<p> Notification of pointer location change.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_pointer:button">wl_pointer:button</a></td>
	<td class="summary">pointer button event</p>

<p> Mouse button click and release notifications.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_pointer:axis">wl_pointer:axis</a></td>
	<td class="summary">axis event</p>

<p> Scroll and other axis notifications.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_pointer:frame">wl_pointer:frame</a></td>
	<td class="summary">end of a pointer event sequence</p>

<p> Indicates the end of a set of events that logically belong together.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_pointer:axis_source">wl_pointer:axis_source</a></td>
	<td class="summary">axis source event</p>

<p> Source information for scroll and other axes.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_pointer:axis_stop">wl_pointer:axis_stop</a></td>
	<td class="summary">axis stop event</p>

<p> Stop notification for scroll and other axes.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_pointer:axis_discrete">wl_pointer:axis_discrete</a></td>
	<td class="summary">axis click event</p>

<p> Discrete step information for scroll and other axes.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_pointer:axis_value120">wl_pointer:axis_value120</a></td>
	<td class="summary">axis high-resolution scroll event</p>

<p> Discrete high-resolution scroll information.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_pointer:axis_relative_direction">wl_pointer:axis_relative_direction</a></td>
	<td class="summary">axis relative physical direction event</p>

<p> Relative directional information of the entity causing the axis
 motion.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_pointer.Error">wl_pointer.Error</a></td>
	<td class="summary">error</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_pointer.ButtonState">wl_pointer.ButtonState</a></td>
	<td class="summary">physical button state</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_pointer.Axis">wl_pointer.Axis</a></td>
	<td class="summary">axis types</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_pointer.AxisSource">wl_pointer.AxisSource</a></td>
	<td class="summary">axis source types</p>

<p> Describes the source types for axis events.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_pointer.AxisRelativeDirection">wl_pointer.AxisRelativeDirection</a></td>
	<td class="summary">axis relative direction</td>
	</tr>
</table>
<h2><a href="#Class_wl_keyboard">Class wl_keyboard </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_keyboard:release">wl_keyboard:release ()</a></td>
	<td class="summary">release the keyboard object</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_keyboard:keymap">wl_keyboard:keymap</a></td>
	<td class="summary">keyboard mapping</p>

<p> This event provides a file descriptor to the client which can be
 memory-mapped in read-only mode to provide a keyboard mapping
 description.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_keyboard:enter">wl_keyboard:enter</a></td>
	<td class="summary">enter event</p>

<p> Notification that this seat's keyboard focus is on a certain
 surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_keyboard:leave">wl_keyboard:leave</a></td>
	<td class="summary">leave event</p>

<p> Notification that this seat's keyboard focus is no longer on
 a certain surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_keyboard:key">wl_keyboard:key</a></td>
	<td class="summary">key event</p>

<p> A key was pressed or released.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_keyboard:modifiers">wl_keyboard:modifiers</a></td>
	<td class="summary">modifier and group state</p>

<p> Notifies clients that the modifier and/or group state has
 changed, and it should update its local state.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_keyboard:repeat_info">wl_keyboard:repeat_info</a></td>
	<td class="summary">repeat rate and delay</p>

<p> Informs the client about the keyboard's repeat rate and delay.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_keyboard.KeymapFormat">wl_keyboard.KeymapFormat</a></td>
	<td class="summary">keyboard mapping format</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_keyboard.KeyState">wl_keyboard.KeyState</a></td>
	<td class="summary">physical key state</td>
	</tr>
</table>
<h2><a href="#Class_wl_touch">Class wl_touch </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_touch:release">wl_touch:release ()</a></td>
	<td class="summary">release the touch object</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_touch:down">wl_touch:down</a></td>
	<td class="summary">touch down event and beginning of a touch sequence</p>

<p> A new touch point has appeared on the surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_touch:up">wl_touch:up</a></td>
	<td class="summary">end of a touch event sequence</p>

<p> The touch point has disappeared.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_touch:motion">wl_touch:motion</a></td>
	<td class="summary">update of touch point coordinates</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_touch:frame">wl_touch:frame</a></td>
	<td class="summary">end of touch frame event</p>

<p> Indicates the end of a set of events that logically belong together.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_touch:cancel">wl_touch:cancel</a></td>
	<td class="summary">touch session cancelled</p>

<p> Sent if the compositor decides the touch stream is a global
 gesture.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_touch:shape">wl_touch:shape</a></td>
	<td class="summary">update shape of touch point</p>

<p> Sent when a touchpoint has changed its shape.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_touch:orientation">wl_touch:orientation</a></td>
	<td class="summary">update orientation of touch point</p>

<p> Sent when a touchpoint has changed its orientation.</td>
	</tr>
</table>
<h2><a href="#Class_wl_output">Class wl_output </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_output:release">wl_output:release ()</a></td>
	<td class="summary">release the output object</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_output:geometry">wl_output:geometry</a></td>
	<td class="summary">properties of the output</p>

<p> The geometry event describes geometric properties of the output.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_output:mode">wl_output:mode</a></td>
	<td class="summary">advertise available modes for the output</p>

<p> The mode event describes an available mode for the output.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_output:done">wl_output:done</a></td>
	<td class="summary">sent all information about output</p>

<p> This event is sent after all other properties have been
 sent after binding to the output object and after any
 other property changes done after that.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_output:scale">wl_output:scale</a></td>
	<td class="summary">output scaling properties</p>

<p> This event contains scaling geometry information
 that is not in the geometry event.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_output:name">wl_output:name</a></td>
	<td class="summary">name of this output</p>

<p> Many compositors will assign user-friendly names to their outputs, show
 them to the user, allow the user to refer to an output, etc.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_output:description">wl_output:description</a></td>
	<td class="summary">human-readable description of this output</p>

<p> Many compositors can produce human-readable descriptions of their
 outputs.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_output.Subpixel">wl_output.Subpixel</a></td>
	<td class="summary">subpixel geometry information</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_output.Transform">wl_output.Transform</a></td>
	<td class="summary">transform from framebuffer to output</p>

<p> This describes the transform that a compositor will apply to a
 surface to compensate for the rotation or mirroring of an
 output device.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_output.Mode">wl_output.Mode</a></td>
	<td class="summary">mode information</p>

<p> These flags describe properties of an output mode.</td>
	</tr>
</table>
<h2><a href="#Class_wl_region">Class wl_region </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_region:destroy">wl_region:destroy ()</a></td>
	<td class="summary">destroy region</p>

<p> Destroy the region.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_region:add">wl_region:add (x, y, width, height)</a></td>
	<td class="summary">add rectangle to region</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_region:subtract">wl_region:subtract (x, y, width, height)</a></td>
	<td class="summary">subtract rectangle from region</td>
	</tr>
</table>
<h2><a href="#Class_wl_subcompositor">Class wl_subcompositor </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_subcompositor:destroy">wl_subcompositor:destroy ()</a></td>
	<td class="summary">unbind from the subcompositor interface</p>

<p> Informs the server that the client will not be using this
 protocol object anymore.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_subcompositor:get_subsurface">wl_subcompositor:get_subsurface (surface, parent)</a></td>
	<td class="summary">give a surface the role sub-surface</p>

<p> Create a sub-surface interface for the given surface, and
 associate it with the given parent surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_subcompositor.Error">wl_subcompositor.Error</a></td>
	<td class="summary">error</td>
	</tr>
</table>
<h2><a href="#Class_wl_subsurface">Class wl_subsurface </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#wl_subsurface:destroy">wl_subsurface:destroy ()</a></td>
	<td class="summary">remove sub-surface interface</p>

<p> The sub-surface interface is removed from the wl<em>surface object
 that was turned into a sub-surface with a
 wl</em>subcompositor.get_subsurface request.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_subsurface:set_position">wl_subsurface:set_position (x, y)</a></td>
	<td class="summary">reposition the sub-surface</p>

<p> This schedules a sub-surface position change.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_subsurface:place_above">wl_subsurface:place_above (sibling)</a></td>
	<td class="summary">restack the sub-surface</p>

<p> This sub-surface is taken from the stack, and put back just
 above the reference surface, changing the z-order of the sub-surfaces.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_subsurface:place_below">wl_subsurface:place_below (sibling)</a></td>
	<td class="summary">restack the sub-surface</p>

<p> The sub-surface is placed just below the reference surface.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_subsurface:set_sync">wl_subsurface:set_sync ()</a></td>
	<td class="summary">set sub-surface to synchronized mode</p>

<p> Change the commit behaviour of the sub-surface to synchronized
 mode, also described as the parent dependent mode.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_subsurface:set_desync">wl_subsurface:set_desync ()</a></td>
	<td class="summary">set sub-surface to desynchronized mode</p>

<p> Change the commit behaviour of the sub-surface to desynchronized
 mode, also described as independent or freely running mode.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wl_subsurface.Error">wl_subsurface.Error</a></td>
	<td class="summary">error</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header has-description"><a name="Class_wl_display"></a>Class wl_display </h2>

          <div class="section-description">
          core global object</p>

<p> The core global object.   This is a special singleton object.  It
 is used for internal Wayland protocol features.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_display:sync"></a>
    <strong>wl_display:sync ()</strong>
    </dt>
    <dd>
    asynchronous roundtrip</p>

<p> The sync request asks the server to emit the 'done' event
 on the returned wl<em>callback object.   Since requests are
 handled in-order and events are delivered in-order, this can
 be used as a barrier to ensure all previous requests and the
 resulting events have been handled.
 The object returned by this request will be destroyed by the
 compositor after the callback is fired and as such the client must not
 attempt to use it after that point.
 The callback</em>data passed in the callback is the event serial.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_callback</span></span>



    </ol>




</dd>
    <dt>
    <a name = "wl_display:get_registry"></a>
    <strong>wl_display:get_registry ()</strong>
    </dt>
    <dd>
    get global registry object</p>

<p> This request creates a registry object that allows the client
 to list and bind the global objects available from the
 compositor.
 It should be noted that the server side resources consumed in
 response to a get<em>registry request can only be released when the
 client disconnects, not when the client side proxy is destroyed.
 Therefore, clients should invoke get</em>registry as infrequently as
 possible to avoid wasting memory.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_registry</span></span>



    </ol>




</dd>
    <dt>
    <a name = "wl_display:error"></a>
    <strong>wl_display:error</strong>
    </dt>
    <dd>
    fatal error event</p>

<p> The error event is sent out when a fatal (non-recoverable)
 error has occurred.   The object_id argument is the object
 where the error occurred, most often in response to a request
 to that object.  The code identifies the error and is defined
 by the object interface.  As such, each interface defines its
 own set of error codes.  The message is a brief description
 of the error, for (debugging) convenience.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">object_id</span>
            <span class="types"><span class="type">object</span></span>
         object where the error occurred
        </li>
        <li><span class="parameter">code</span>
            <span class="types"><span class="type">uint</span></span>
         error code
        </li>
        <li><span class="parameter">message</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.4/manual.html#6.4">string</a></span>
         error description
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_display:delete_id"></a>
    <strong>wl_display:delete_id</strong>
    </dt>
    <dd>
    acknowledge object ID deletion</p>

<p> This event is used internally by the object ID management
 logic.  When a client deletes an object that it had created,
 the server will send this event to acknowledge that it has
 seen the delete request. When the client receives this event,
 it will know that it can safely reuse the object ID.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>
            <span class="types"><span class="type">uint</span></span>
         deleted object ID
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_display.Error"></a>
    <strong>wl_display.Error</strong>
    </dt>
    <dd>
    global error values  These errors are global and can be emitted in response to any
 server request.


    <ul>
        <li><span class="parameter">INVALID_OBJECT</span>
         0 server couldn't find object
        </li>
        <li><span class="parameter">INVALID_METHOD</span>
         1 method doesn't exist on the specified interface or malformed request
        </li>
        <li><span class="parameter">NO_MEMORY</span>
         2 server is out of memory
        </li>
        <li><span class="parameter">IMPLEMENTATION</span>
         3 implementation error in compositor
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_registry"></a>Class wl_registry </h2>

          <div class="section-description">
          global registry object</p>

<p> The singleton global registry object.   The server has a number of
 global objects that are available to all clients.  These objects
 typically represent an actual object in the server (for example,
 an input device) or they are singleton objects that provide
 extension functionality.
 When a client creates a registry object, the registry object
 will emit a global event for each global currently in the
 registry.  Globals come and go as a result of device or
 monitor hotplugs, reconfiguration or other events, and the
 registry will send out global and global<em>remove events to
 keep the client up to date with the changes.  To mark the end
 of the initial burst of events, the client can use the
 wl</em>display.sync request immediately after calling
 wl<em>display.get</em>registry.
 A client can bind to a global object by using the bind
 request.  This creates a client-side handle that lets the object
 emit events to the client and lets the client invoke requests on
 the object.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_registry:bind"></a>
    <strong>wl_registry:bind (name)</strong>
    </dt>
    <dd>
    bind an object to the display  Binds a new, client-created object to the server using the
 specified name as the identifier.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">name</span>
            <span class="types"><span class="type">uint</span></span>
         unique numeric name of the object
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">object</span></span>



    </ol>




</dd>
    <dt>
    <a name = "wl_registry:global"></a>
    <strong>wl_registry:global</strong>
    </dt>
    <dd>
    announce global object</p>

<p> Notify the client of global objects.
 The event notifies the client that a global object with
 the given name is now available, and it implements the
 given version of the given interface.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">name</span>
            <span class="types"><span class="type">uint</span></span>
         numeric name of the global object
        </li>
        <li><span class="parameter">interface</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.4/manual.html#6.4">string</a></span>
         interface implemented by the object
        </li>
        <li><span class="parameter">version</span>
            <span class="types"><span class="type">uint</span></span>
         interface version
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_registry:global_remove"></a>
    <strong>wl_registry:global_remove</strong>
    </dt>
    <dd>
    announce removal of global object</p>

<p> Notify the client of removed global objects.
 This event notifies the client that the global identified
 by name is no longer available.  If the client bound to
 the global using the bind request, the client should now
 destroy that object.
 The object remains valid and requests to the object will be
 ignored until the client destroys it, to avoid races between
 the global going away and a client sending a request to it.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">name</span>
            <span class="types"><span class="type">uint</span></span>
         numeric name of the global object
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_callback"></a>Class wl_callback </h2>

          <div class="section-description">
          callback object</p>

<p> Clients can handle the 'done' event to get notified when
 the related request is done.
 Note, because wl<em>callback objects are created from multiple independent
 factory interfaces, the wl</em>callback interface is frozen at version 1.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_callback:done"></a>
    <strong>wl_callback:done</strong>
    </dt>
    <dd>
    done event  Notify the client when the related request is done.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">callback_data</span>
            <span class="types"><span class="type">uint</span></span>
         request-specific data for the callback
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_compositor"></a>Class wl_compositor </h2>

          <div class="section-description">
          the compositor singleton</p>

<p> A compositor.   This object is a singleton global.  The
 compositor is in charge of combining the contents of multiple
 surfaces into one displayable output.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_compositor:create_surface"></a>
    <strong>wl_compositor:create_surface ()</strong>
    </dt>
    <dd>
    create new surface  Ask the compositor to create a new surface.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_surface</span></span>



    </ol>




</dd>
    <dt>
    <a name = "wl_compositor:create_region"></a>
    <strong>wl_compositor:create_region ()</strong>
    </dt>
    <dd>
    create new region  Ask the compositor to create a new region.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_region</span></span>



    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_shm_pool"></a>Class wl_shm_pool </h2>

          <div class="section-description">
          a shared memory pool</p>

<p> The wl<em>shm</em>pool object encapsulates a piece of memory shared
 between the compositor and client.   Through the wl<em>shm</em>pool
 object, the client can allocate shared memory wl_buffer objects.
 All objects created through the same pool share the same
 underlying mapped memory. Reusing the mapped memory avoids the
 setup/teardown overhead and is useful when interactively resizing
 a surface or for many small buffers.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_shm_pool:create_buffer"></a>
    <strong>wl_shm_pool:create_buffer (offset, width, height, stride, format)</strong>
    </dt>
    <dd>
    create a buffer from the pool</p>

<p> Create a wl<em>buffer object from the pool.
 The buffer is created offset bytes into the pool and has
 width and height as specified.  The stride argument specifies
 the number of bytes from the beginning of one row to the beginning
 of the next.  The format is the pixel format of the buffer and
 must be one of those advertised through the wl</em>shm.format event.
 A buffer will keep a reference to the pool it was created from
 so it is valid to destroy the pool immediately after creating
 a buffer from it.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">offset</span>
            <span class="types"><span class="type">int</span></span>
         buffer byte offset within the pool
        </li>
        <li><span class="parameter">width</span>
            <span class="types"><span class="type">int</span></span>
         buffer width, in pixels
        </li>
        <li><span class="parameter">height</span>
            <span class="types"><span class="type">int</span></span>
         buffer height, in pixels
        </li>
        <li><span class="parameter">stride</span>
            <span class="types"><span class="type">int</span></span>
         number of bytes from the beginning of one row to the beginning of the next row
        </li>
        <li><span class="parameter">format</span>
            <span class="types"><span class="type">uint</span></span>
         buffer pixel format
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_buffer</span></span>



    </ol>




</dd>
    <dt>
    <a name = "wl_shm_pool:destroy"></a>
    <strong>wl_shm_pool:destroy ()</strong>
    </dt>
    <dd>
    destroy the pool</p>

<p> Destroy the shared memory pool.
 The mmapped memory will be released when all
 buffers that have been created from this pool
 are gone.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_shm_pool</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_shm_pool:resize"></a>
    <strong>wl_shm_pool:resize (size)</strong>
    </dt>
    <dd>
    change the size of the pool mapping</p>

<p> This request will cause the server to remap the backing memory
 for the pool from the file descriptor passed when the pool was
 created, but using the new size.   This request can only be
 used to make the pool bigger.
 This request only changes the amount of bytes that are mmapped
 by the server and does not touch the file corresponding to the
 file descriptor passed at creation time. It is the client's
 responsibility to ensure that the file is at least as big as
 the new pool size.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">size</span>
            <span class="types"><span class="type">int</span></span>
         new size of the pool, in bytes
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_shm_pool</span></span>
        self
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_shm"></a>Class wl_shm </h2>

          <div class="section-description">
          shared memory support</p>

<p> A singleton global object that provides support for shared
 memory.
 Clients can create wl<em>shm</em>pool objects using the create<em>pool
 request.
 On binding the wl</em>shm object one or more format events
 are emitted to inform clients about the valid pixel formats
 that can be used for buffers.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_shm:create_pool"></a>
    <strong>wl_shm:create_pool (fd, size)</strong>
    </dt>
    <dd>
    create a shm pool</p>

<p> Create a new wl<em>shm</em>pool object.
 The pool can be used to create shared memory based buffer
 objects.  The server will mmap size bytes of the passed file
 descriptor, to use as backing memory for the pool.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">fd</span>
            <span class="types"><span class="type">fd</span></span>
         file descriptor for the pool
        </li>
        <li><span class="parameter">size</span>
            <span class="types"><span class="type">int</span></span>
         pool size, in bytes
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_shm_pool</span></span>



    </ol>




</dd>
    <dt>
    <a name = "wl_shm:format"></a>
    <strong>wl_shm:format</strong>
    </dt>
    <dd>
    pixel format description</p>

<p> Informs the client about a valid pixel format that
 can be used for buffers.  Known formats include
 argb8888 and xrgb8888.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">format</span>
            <span class="types"><span class="type">uint</span></span>
         buffer pixel format
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_shm.Error"></a>
    <strong>wl_shm.Error</strong>
    </dt>
    <dd>
    wl<em>shm error values  These errors can be emitted in response to wl</em>shm requests.


    <ul>
        <li><span class="parameter">INVALID_FORMAT</span>
         0 buffer format is not known
        </li>
        <li><span class="parameter">INVALID_STRIDE</span>
         1 invalid size or stride during pool or buffer creation
        </li>
        <li><span class="parameter">INVALID_FD</span>
         2 mmapping the file descriptor failed
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_shm.Format"></a>
    <strong>wl_shm.Format</strong>
    </dt>
    <dd>
    pixel formats</p>

<p> This describes the memory layout of an individual pixel.
 All renderers should support argb8888 and xrgb8888 but any other
 formats are optional and may not be supported by the particular
 renderer in use.
 The drm format codes match the macros defined in drm<em>fourcc.h, except
 argb8888 and xrgb8888. The formats actually supported by the compositor
 will be reported by the format event.
 For all wl</em>shm formats and unless specified in another protocol
 extension, pre-multiplied alpha is used for pixel values.


    <ul>
        <li><span class="parameter">ARGB8888</span>
         0 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
        </li>
        <li><span class="parameter">XRGB8888</span>
         1 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
        </li>
        <li><span class="parameter">C8</span>
         0x20203843 8-bit color index format, [7:0] C
        </li>
        <li><span class="parameter">RGB332</span>
         0x38424752 8-bit RGB format, [7:0] R:G:B 3:3:2
        </li>
        <li><span class="parameter">BGR233</span>
         0x38524742 8-bit BGR format, [7:0] B:G:R 2:3:3
        </li>
        <li><span class="parameter">XRGB4444</span>
         0x32315258 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
        </li>
        <li><span class="parameter">XBGR4444</span>
         0x32314258 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
        </li>
        <li><span class="parameter">RGBX4444</span>
         0x32315852 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
        </li>
        <li><span class="parameter">BGRX4444</span>
         0x32315842 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
        </li>
        <li><span class="parameter">ARGB4444</span>
         0x32315241 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
        </li>
        <li><span class="parameter">ABGR4444</span>
         0x32314241 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
        </li>
        <li><span class="parameter">RGBA4444</span>
         0x32314152 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
        </li>
        <li><span class="parameter">BGRA4444</span>
         0x32314142 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
        </li>
        <li><span class="parameter">XRGB1555</span>
         0x35315258 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
        </li>
        <li><span class="parameter">XBGR1555</span>
         0x35314258 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
        </li>
        <li><span class="parameter">RGBX5551</span>
         0x35315852 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
        </li>
        <li><span class="parameter">BGRX5551</span>
         0x35315842 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
        </li>
        <li><span class="parameter">ARGB1555</span>
         0x35315241 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
        </li>
        <li><span class="parameter">ABGR1555</span>
         0x35314241 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
        </li>
        <li><span class="parameter">RGBA5551</span>
         0x35314152 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
        </li>
        <li><span class="parameter">BGRA5551</span>
         0x35314142 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
        </li>
        <li><span class="parameter">RGB565</span>
         0x36314752 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
        </li>
        <li><span class="parameter">BGR565</span>
         0x36314742 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
        </li>
        <li><span class="parameter">RGB888</span>
         0x34324752 24-bit RGB format, [23:0] R:G:B little endian
        </li>
        <li><span class="parameter">BGR888</span>
         0x34324742 24-bit BGR format, [23:0] B:G:R little endian
        </li>
        <li><span class="parameter">XBGR8888</span>
         0x34324258 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
        </li>
        <li><span class="parameter">RGBX8888</span>
         0x34325852 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
        </li>
        <li><span class="parameter">BGRX8888</span>
         0x34325842 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
        </li>
        <li><span class="parameter">ABGR8888</span>
         0x34324241 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
        </li>
        <li><span class="parameter">RGBA8888</span>
         0x34324152 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
        </li>
        <li><span class="parameter">BGRA8888</span>
         0x34324142 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
        </li>
        <li><span class="parameter">XRGB2101010</span>
         0x30335258 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
        </li>
        <li><span class="parameter">XBGR2101010</span>
         0x30334258 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
        </li>
        <li><span class="parameter">RGBX1010102</span>
         0x30335852 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
        </li>
        <li><span class="parameter">BGRX1010102</span>
         0x30335842 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
        </li>
        <li><span class="parameter">ARGB2101010</span>
         0x30335241 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
        </li>
        <li><span class="parameter">ABGR2101010</span>
         0x30334241 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
        </li>
        <li><span class="parameter">RGBA1010102</span>
         0x30334152 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
        </li>
        <li><span class="parameter">BGRA1010102</span>
         0x30334142 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
        </li>
        <li><span class="parameter">YUYV</span>
         0x56595559 packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
        </li>
        <li><span class="parameter">YVYU</span>
         0x55595659 packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
        </li>
        <li><span class="parameter">UYVY</span>
         0x59565955 packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
        </li>
        <li><span class="parameter">VYUY</span>
         0x59555956 packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
        </li>
        <li><span class="parameter">AYUV</span>
         0x56555941 packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
        </li>
        <li><span class="parameter">NV12</span>
         0x3231564e 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
        </li>
        <li><span class="parameter">NV21</span>
         0x3132564e 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
        </li>
        <li><span class="parameter">NV16</span>
         0x3631564e 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
        </li>
        <li><span class="parameter">NV61</span>
         0x3136564e 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
        </li>
        <li><span class="parameter">YUV410</span>
         0x39565559 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
        </li>
        <li><span class="parameter">YVU410</span>
         0x39555659 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
        </li>
        <li><span class="parameter">YUV411</span>
         0x31315559 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
        </li>
        <li><span class="parameter">YVU411</span>
         0x31315659 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
        </li>
        <li><span class="parameter">YUV420</span>
         0x32315559 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
        </li>
        <li><span class="parameter">YVU420</span>
         0x32315659 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
        </li>
        <li><span class="parameter">YUV422</span>
         0x36315559 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
        </li>
        <li><span class="parameter">YVU422</span>
         0x36315659 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
        </li>
        <li><span class="parameter">YUV444</span>
         0x34325559 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
        </li>
        <li><span class="parameter">YVU444</span>
         0x34325659 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
        </li>
        <li><span class="parameter">R8</span>
         0x20203852 [7:0] R
        </li>
        <li><span class="parameter">R16</span>
         0x20363152 [15:0] R little endian
        </li>
        <li><span class="parameter">RG88</span>
         0x38384752 [15:0] R:G 8:8 little endian
        </li>
        <li><span class="parameter">GR88</span>
         0x38385247 [15:0] G:R 8:8 little endian
        </li>
        <li><span class="parameter">RG1616</span>
         0x32334752 [31:0] R:G 16:16 little endian
        </li>
        <li><span class="parameter">GR1616</span>
         0x32335247 [31:0] G:R 16:16 little endian
        </li>
        <li><span class="parameter">XRGB16161616F</span>
         0x48345258 [63:0] x:R:G:B 16:16:16:16 little endian
        </li>
        <li><span class="parameter">XBGR16161616F</span>
         0x48344258 [63:0] x:B:G:R 16:16:16:16 little endian
        </li>
        <li><span class="parameter">ARGB16161616F</span>
         0x48345241 [63:0] A:R:G:B 16:16:16:16 little endian
        </li>
        <li><span class="parameter">ABGR16161616F</span>
         0x48344241 [63:0] A:B:G:R 16:16:16:16 little endian
        </li>
        <li><span class="parameter">XYUV8888</span>
         0x56555958 [31:0] X:Y:Cb:Cr 8:8:8:8 little endian
        </li>
        <li><span class="parameter">VUY888</span>
         0x34325556 [23:0] Cr:Cb:Y 8:8:8 little endian
        </li>
        <li><span class="parameter">VUY101010</span>
         0x30335556 Y followed by U then V, 10:10:10. Non-linear modifier only
        </li>
        <li><span class="parameter">Y210</span>
         0x30313259 [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels
        </li>
        <li><span class="parameter">Y212</span>
         0x32313259 [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels
        </li>
        <li><span class="parameter">Y216</span>
         0x36313259 [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels
        </li>
        <li><span class="parameter">Y410</span>
         0x30313459 [31:0] A:Cr:Y:Cb 2:10:10:10 little endian
        </li>
        <li><span class="parameter">Y412</span>
         0x32313459 [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
        </li>
        <li><span class="parameter">Y416</span>
         0x36313459 [63:0] A:Cr:Y:Cb 16:16:16:16 little endian
        </li>
        <li><span class="parameter">XVYU2101010</span>
         0x30335658 [31:0] X:Cr:Y:Cb 2:10:10:10 little endian
        </li>
        <li><span class="parameter">XVYU12_16161616</span>
         0x36335658 [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
        </li>
        <li><span class="parameter">XVYU16161616</span>
         0x38345658 [63:0] X:Cr:Y:Cb 16:16:16:16 little endian
        </li>
        <li><span class="parameter">Y0L0</span>
         0x304c3059 [63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
        </li>
        <li><span class="parameter">X0L0</span>
         0x304c3058 [63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
        </li>
        <li><span class="parameter">Y0L2</span>
         0x324c3059 [63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
        </li>
        <li><span class="parameter">X0L2</span>
         0x324c3058 [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
        </li>
        <li><span class="parameter">YUV420_8BIT</span>
         0x38305559
        </li>
        <li><span class="parameter">YUV420_10BIT</span>
         0x30315559
        </li>
        <li><span class="parameter">XRGB8888_A8</span>
         0x38415258
        </li>
        <li><span class="parameter">XBGR8888_A8</span>
         0x38414258
        </li>
        <li><span class="parameter">RGBX8888_A8</span>
         0x38415852
        </li>
        <li><span class="parameter">BGRX8888_A8</span>
         0x38415842
        </li>
        <li><span class="parameter">RGB888_A8</span>
         0x38413852
        </li>
        <li><span class="parameter">BGR888_A8</span>
         0x38413842
        </li>
        <li><span class="parameter">RGB565_A8</span>
         0x38413552
        </li>
        <li><span class="parameter">BGR565_A8</span>
         0x38413542
        </li>
        <li><span class="parameter">NV24</span>
         0x3432564e non-subsampled Cr:Cb plane
        </li>
        <li><span class="parameter">NV42</span>
         0x3234564e non-subsampled Cb:Cr plane
        </li>
        <li><span class="parameter">P210</span>
         0x30313250 2x1 subsampled Cr:Cb plane, 10 bit per channel
        </li>
        <li><span class="parameter">P010</span>
         0x30313050 2x2 subsampled Cr:Cb plane 10 bits per channel
        </li>
        <li><span class="parameter">P012</span>
         0x32313050 2x2 subsampled Cr:Cb plane 12 bits per channel
        </li>
        <li><span class="parameter">P016</span>
         0x36313050 2x2 subsampled Cr:Cb plane 16 bits per channel
        </li>
        <li><span class="parameter">AXBXGXRX106106106106</span>
         0x30314241 [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian
        </li>
        <li><span class="parameter">NV15</span>
         0x3531564e 2x2 subsampled Cr:Cb plane
        </li>
        <li><span class="parameter">Q410</span>
         0x30313451
        </li>
        <li><span class="parameter">Q401</span>
         0x31303451
        </li>
        <li><span class="parameter">XRGB16161616</span>
         0x38345258 [63:0] x:R:G:B 16:16:16:16 little endian
        </li>
        <li><span class="parameter">XBGR16161616</span>
         0x38344258 [63:0] x:B:G:R 16:16:16:16 little endian
        </li>
        <li><span class="parameter">ARGB16161616</span>
         0x38345241 [63:0] A:R:G:B 16:16:16:16 little endian
        </li>
        <li><span class="parameter">ABGR16161616</span>
         0x38344241 [63:0] A:B:G:R 16:16:16:16 little endian
        </li>
        <li><span class="parameter">C1</span>
         0x20203143 [7:0] C0:C1:C2:C3:C4:C5:C6:C7 1:1:1:1:1:1:1:1 eight pixels/byte
        </li>
        <li><span class="parameter">C2</span>
         0x20203243 [7:0] C0:C1:C2:C3 2:2:2:2 four pixels/byte
        </li>
        <li><span class="parameter">C4</span>
         0x20203443 [7:0] C0:C1 4:4 two pixels/byte
        </li>
        <li><span class="parameter">D1</span>
         0x20203144 [7:0] D0:D1:D2:D3:D4:D5:D6:D7 1:1:1:1:1:1:1:1 eight pixels/byte
        </li>
        <li><span class="parameter">D2</span>
         0x20203244 [7:0] D0:D1:D2:D3 2:2:2:2 four pixels/byte
        </li>
        <li><span class="parameter">D4</span>
         0x20203444 [7:0] D0:D1 4:4 two pixels/byte
        </li>
        <li><span class="parameter">D8</span>
         0x20203844 [7:0] D
        </li>
        <li><span class="parameter">R1</span>
         0x20203152 [7:0] R0:R1:R2:R3:R4:R5:R6:R7 1:1:1:1:1:1:1:1 eight pixels/byte
        </li>
        <li><span class="parameter">R2</span>
         0x20203252 [7:0] R0:R1:R2:R3 2:2:2:2 four pixels/byte
        </li>
        <li><span class="parameter">R4</span>
         0x20203452 [7:0] R0:R1 4:4 two pixels/byte
        </li>
        <li><span class="parameter">R10</span>
         0x20303152 [15:0] x:R 6:10 little endian
        </li>
        <li><span class="parameter">R12</span>
         0x20323152 [15:0] x:R 4:12 little endian
        </li>
        <li><span class="parameter">AVUY8888</span>
         0x59555641 [31:0] A:Cr:Cb:Y 8:8:8:8 little endian
        </li>
        <li><span class="parameter">XVUY8888</span>
         0x59555658 [31:0] X:Cr:Cb:Y 8:8:8:8 little endian
        </li>
        <li><span class="parameter">P030</span>
         0x30333050 2x2 subsampled Cr:Cb plane 10 bits per channel packed
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_buffer"></a>Class wl_buffer </h2>

          <div class="section-description">
          content for a wl_surface</p>

<p> A buffer provides the content for a wl<em>surface.  Buffers are
 created through factory interfaces such as wl</em>shm, wp<em>linux</em>buffer<em>params
 (from the linux-dmabuf protocol extension) or similar. It has a width and
 a height and can be attached to a wl</em>surface, but the mechanism by which a
 client provides and updates the contents is defined by the buffer factory
 interface.
 If the buffer uses a format that has an alpha channel, the alpha channel
 is assumed to be premultiplied in the color channels unless otherwise
 specified.
 Note, because wl<em>buffer objects are created from multiple independent
 factory interfaces, the wl</em>buffer interface is frozen at version 1.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_buffer:destroy"></a>
    <strong>wl_buffer:destroy ()</strong>
    </dt>
    <dd>
    destroy a buffer</p>

<p> Destroy a buffer.  If and how you need to release the backing
 storage is defined by the buffer factory interface.
 For possible side-effects to a surface, see wl_surface.attach.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_buffer</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_buffer:release"></a>
    <strong>wl_buffer:release</strong>
    </dt>
    <dd>
    compositor releases buffer</p>

<p> Sent when this wl<em>buffer is no longer used by the compositor.
 The client is now free to reuse or destroy this buffer and its
 backing storage.
 If a client receives a release event before the frame callback
 requested in the same wl</em>surface.commit that attaches this
 wl<em>buffer to a surface, then the client is immediately free to
 reuse the buffer and its backing storage, and does not need a
 second buffer for the next surface content update. Typically
 this is possible, when the compositor maintains a copy of the
 wl</em>surface contents, e.g. as a GL texture. This is an important
 optimization for GL(ES) compositors with wl_shm clients.







</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_data_offer"></a>Class wl_data_offer </h2>

          <div class="section-description">
          offer to transfer data</p>

<p> A wl<em>data</em>offer represents a piece of data offered for transfer
 by another client (the source client).   It is used by the
 copy-and-paste and drag-and-drop mechanisms.  The offer
 describes the different mime types that the data can be
 converted to and provides the mechanism for transferring the
 data directly from the source client.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_data_offer:accept"></a>
    <strong>wl_data_offer:accept (serial, mime_type)</strong>
    </dt>
    <dd>
    accept one of the offered mime types</p>

<p> Indicate that the client can accept the given mime type, or
 NULL for not accepted.
 For objects of version 2 or older, this request is used by the
 client to give feedback whether the client can receive the given
 mime type, or NULL if none is accepted; the feedback does not
 determine whether the drag-and-drop operation succeeds or not.
 For objects of version 3 or newer, this request determines the
 final result of the drag-and-drop operation. If the end result
 is that no mime types were accepted, the drag-and-drop operation
 will be cancelled and the corresponding drag source will receive
 wl<em>data</em>source.cancelled. Clients may still use this event in
 conjunction with wl<em>data</em>source.action for feedback.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the accept request
        </li>
        <li><span class="parameter">mime_type</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.4/manual.html#6.4">string</a></span>
         mime type accepted by the client
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_data_offer</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_data_offer:receive"></a>
    <strong>wl_data_offer:receive (mime_type, fd)</strong>
    </dt>
    <dd>
    request that the data is transferred</p>

<p> To transfer the offered data, the client issues this request
 and indicates the mime type it wants to receive.   The transfer
 happens through the passed file descriptor (typically created
 with the pipe system call).  The source client writes the data
 in the mime type representation requested and then closes the
 file descriptor.
 The receiving client reads from the read end of the pipe until
 EOF and then closes its end, at which point the transfer is
 complete.
 This request may happen multiple times for different mime types,
 both before and after wl<em>data</em>device.drop. Drag-and-drop destination
 clients may preemptively fetch data or examine it more closely to
 determine acceptance.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">mime_type</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.4/manual.html#6.4">string</a></span>
         mime type desired by receiver
        </li>
        <li><span class="parameter">fd</span>
            <span class="types"><span class="type">fd</span></span>
         file descriptor for data transfer
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_data_offer</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_data_offer:destroy"></a>
    <strong>wl_data_offer:destroy ()</strong>
    </dt>
    <dd>
    destroy data offer  Destroy the data offer.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_data_offer</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_data_offer:finish"></a>
    <strong>wl_data_offer:finish ()</strong>
    </dt>
    <dd>
    the offer will no longer be used</p>

<p> Notifies the compositor that the drag destination successfully
 finished the drag-and-drop operation.
 Upon receiving this request, the compositor will emit
 wl<em>data</em>source.dnd<em>finished on the drag source client.
 It is a client error to perform other requests than
 wl</em>data<em>offer.destroy after this one. It is also an error to perform
 this request after a NULL mime type has been set in
 wl</em>data<em>offer.accept or no action was received through
 wl</em>data<em>offer.action.
 If wl</em>data<em>offer.finish request is received for a non drag and drop
 operation, the invalid</em>finish protocol error is raised.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_data_offer</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_data_offer:set_actions"></a>
    <strong>wl_data_offer:set_actions (dnd_actions, preferred_action)</strong>
    </dt>
    <dd>
    set the available/preferred drag-and-drop actions</p>

<p> Sets the actions that the destination side client supports for
 this operation.  This request may trigger the emission of
 wl<em>data</em>source.action and wl<em>data</em>offer.action events if the compositor
 needs to change the selected action.
 This request can be called multiple times throughout the
 drag-and-drop operation, typically in response to wl<em>data</em>device.enter
 or wl<em>data</em>device.motion events.
 This request determines the final result of the drag-and-drop
 operation. If the end result is that no action is accepted,
 the drag source will receive wl<em>data</em>source.cancelled.
 The dnd<em>actions argument must contain only values expressed in the
 wl</em>data<em>device</em>manager.dnd<em>actions enum, and the preferred</em>action
 argument must only contain one of those values set, otherwise it
 will result in a protocol error.
 While managing an "ask" action, the destination drag-and-drop client
 may perform further wl<em>data</em>offer.receive requests, and is expected
 to perform one last wl<em>data</em>offer.set<em>actions request with a preferred
 action other than "ask" (and optionally wl</em>data<em>offer.accept) before
 requesting wl</em>data<em>offer.finish, in order to convey the action selected
 by the user. If the preferred action is not in the
 wl</em>data<em>offer.source</em>actions mask, an error will be raised.
 If the "ask" action is dismissed (e.g. user cancellation), the client
 is expected to perform wl<em>data</em>offer.destroy right away.
 This request can only be made on drag-and-drop offers, a protocol error
 will be raised otherwise.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">dnd_actions</span>
            <span class="types"><span class="type">uint</span></span>
         actions supported by the destination client
        </li>
        <li><span class="parameter">preferred_action</span>
            <span class="types"><span class="type">uint</span></span>
         action preferred by the destination client
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_data_offer</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_data_offer:offer"></a>
    <strong>wl_data_offer:offer</strong>
    </dt>
    <dd>
    advertise offered mime type</p>

<p> Sent immediately after creating the wl<em>data</em>offer object.   One
 event per offered mime type.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">mime_type</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.4/manual.html#6.4">string</a></span>
         offered mime type
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_data_offer:source_actions"></a>
    <strong>wl_data_offer:source_actions</strong>
    </dt>
    <dd>
    notify the source-side available actions</p>

<p> This event indicates the actions offered by the data source.  It
 will be sent immediately after creating the wl<em>data</em>offer object,
 or anytime the source side changes its offered actions through
 wl<em>data</em>source.set_actions.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">source_actions</span>
            <span class="types"><span class="type">uint</span></span>
         actions offered by the data source
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_data_offer:action"></a>
    <strong>wl_data_offer:action</strong>
    </dt>
    <dd>
    notify the selected action</p>

<p> This event indicates the action selected by the compositor after
 matching the source/destination side actions.  Only one action (or
 none) will be offered here.
 This event can be emitted multiple times during the drag-and-drop
 operation in response to destination side action changes through
 wl<em>data</em>offer.set<em>actions.
 This event will no longer be emitted after wl</em>data<em>device.drop
 happened on the drag-and-drop destination, the client must
 honor the last action received, or the last preferred one set
 through wl</em>data<em>offer.set</em>actions when handling an "ask" action.
 Compositors may also change the selected action on the fly, mainly
 in response to keyboard modifier changes during the drag-and-drop
 operation.
 The most recent action received is always the valid one. Prior to
 receiving wl<em>data</em>device.drop, the chosen action may change (e.g.
 due to keyboard modifiers being pressed). At the time of receiving
 wl<em>data</em>device.drop the drag-and-drop destination must honor the
 last action received.
 Action changes may still happen after wl<em>data</em>device.drop,
 especially on "ask" actions, where the drag-and-drop destination
 may choose another action afterwards. Action changes happening
 at this stage are always the result of inter-client negotiation, the
 compositor shall no longer be able to induce a different action.
 Upon "ask" actions, it is expected that the drag-and-drop destination
 may potentially choose a different action and/or mime type,
 based on wl<em>data</em>offer.source<em>actions and finally chosen by the
 user (e.g. popping up a menu with the available options). The
 final wl</em>data<em>offer.set</em>actions and wl<em>data</em>offer.accept requests
 must happen before the call to wl<em>data</em>offer.finish.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">dnd_action</span>
            <span class="types"><span class="type">uint</span></span>
         action selected by the compositor
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_data_offer.Error"></a>
    <strong>wl_data_offer.Error</strong>
    </dt>
    <dd>
    error


    <ul>
        <li><span class="parameter">INVALID_FINISH</span>
         0 finish request was called untimely
        </li>
        <li><span class="parameter">INVALID_ACTION_MASK</span>
         1 action mask contains invalid values
        </li>
        <li><span class="parameter">INVALID_ACTION</span>
         2 action argument has an invalid value
        </li>
        <li><span class="parameter">INVALID_OFFER</span>
         3 offer doesn't accept this request
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_data_source"></a>Class wl_data_source </h2>

          <div class="section-description">
          offer to transfer data</p>

<p> The wl<em>data</em>source object is the source side of a wl<em>data</em>offer.
 It is created by the source client in a data transfer and
 provides a way to describe the offered data and a way to respond
 to requests to transfer the data.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_data_source:offer"></a>
    <strong>wl_data_source:offer (mime_type)</strong>
    </dt>
    <dd>
    add an offered mime type</p>

<p> This request adds a mime type to the set of mime types
 advertised to targets.   Can be called several times to offer
 multiple types.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">mime_type</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.4/manual.html#6.4">string</a></span>
         mime type offered by the data source
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_data_source</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_data_source:destroy"></a>
    <strong>wl_data_source:destroy ()</strong>
    </dt>
    <dd>
    destroy the data source  Destroy the data source.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_data_source</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_data_source:set_actions"></a>
    <strong>wl_data_source:set_actions (dnd_actions)</strong>
    </dt>
    <dd>
    set the available drag-and-drop actions</p>

<p> Sets the actions that the source side client supports for this
 operation.  This request may trigger wl<em>data</em>source.action and
 wl<em>data</em>offer.action events if the compositor needs to change the
 selected action.
 The dnd<em>actions argument must contain only values expressed in the
 wl</em>data<em>device</em>manager.dnd<em>actions enum, otherwise it will result
 in a protocol error.
 This request must be made once only, and can only be made on sources
 used in drag-and-drop, so it must be performed before
 wl</em>data<em>device.start</em>drag. Attempting to use the source other than
 for drag-and-drop will raise a protocol error.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">dnd_actions</span>
            <span class="types"><span class="type">uint</span></span>
         actions supported by the data source
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_data_source</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_data_source:target"></a>
    <strong>wl_data_source:target</strong>
    </dt>
    <dd>
    a target accepts an offered mime type</p>

<p> Sent when a target accepts pointer_focus or motion events.   If
 a target does not accept any of the offered types, type is NULL.
 Used for feedback during drag-and-drop.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">mime_type</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.4/manual.html#6.4">string</a></span>
         mime type accepted by the target
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_data_source:send"></a>
    <strong>wl_data_source:send</strong>
    </dt>
    <dd>
    send the data</p>

<p> Request for data from the client.   Send the data as the
 specified mime type over the passed file descriptor, then
 close it.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">mime_type</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.4/manual.html#6.4">string</a></span>
         mime type for the data
        </li>
        <li><span class="parameter">fd</span>
            <span class="types"><span class="type">fd</span></span>
         file descriptor for the data
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_data_source:cancelled"></a>
    <strong>wl_data_source:cancelled</strong>
    </dt>
    <dd>
    selection was cancelled</p>

<p> This data source is no longer valid.  There are several reasons why
 this could happen:
 - The data source has been replaced by another data source.
 - The drag-and-drop operation was performed, but the drop destination
 did not accept any of the mime types offered through
 wl<em>data</em>source.target.
 - The drag-and-drop operation was performed, but the drop destination
 did not select any of the actions present in the mask offered through
 wl<em>data</em>source.action.
 - The drag-and-drop operation was performed but didn't happen over a
 surface.
 - The compositor cancelled the drag-and-drop operation (e.g. compositor
 dependent timeouts to avoid stale drag-and-drop transfers).
 The client should clean up and destroy this data source.
 For objects of version 2 or older, wl<em>data</em>source.cancelled will
 only be emitted if the data source was replaced by another data
 source.







</dd>
    <dt>
    <a name = "wl_data_source:dnd_drop_performed"></a>
    <strong>wl_data_source:dnd_drop_performed</strong>
    </dt>
    <dd>
    the drag-and-drop operation physically finished</p>

<p> The user performed the drop action.  This event does not indicate
 acceptance, wl<em>data</em>source.cancelled may still be emitted afterwards
 if the drop destination does not accept any mime type.
 However, this event might however not be received if the compositor
 cancelled the drag-and-drop operation before this event could happen.
 Note that the data_source may still be used in the future and should
 not be destroyed here.







</dd>
    <dt>
    <a name = "wl_data_source:dnd_finished"></a>
    <strong>wl_data_source:dnd_finished</strong>
    </dt>
    <dd>
    the drag-and-drop operation concluded</p>

<p> The drop destination finished interoperating with this data
 source, so the client is now free to destroy this data source and
 free all associated data.
 If the action used to perform the operation was "move", the
 source can now delete the transferred data.







</dd>
    <dt>
    <a name = "wl_data_source:action"></a>
    <strong>wl_data_source:action</strong>
    </dt>
    <dd>
    notify the selected action</p>

<p> This event indicates the action selected by the compositor after
 matching the source/destination side actions.  Only one action (or
 none) will be offered here.
 This event can be emitted multiple times during the drag-and-drop
 operation, mainly in response to destination side changes through
 wl<em>data</em>offer.set<em>actions, and as the data device enters/leaves
 surfaces.
 It is only possible to receive this event after
 wl</em>data<em>source.dnd</em>drop<em>performed if the drag-and-drop operation
 ended in an "ask" action, in which case the final wl</em>data<em>source.action
 event will happen immediately before wl</em>data<em>source.dnd</em>finished.
 Compositors may also change the selected action on the fly, mainly
 in response to keyboard modifier changes during the drag-and-drop
 operation.
 The most recent action received is always the valid one. The chosen
 action may change alongside negotiation (e.g. an "ask" action can turn
 into a "move" operation), so the effects of the final action must
 always be applied in wl<em>data</em>offer.dnd_finished.
 Clients can trigger cursor surface changes from this point, so
 they reflect the current action.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">dnd_action</span>
            <span class="types"><span class="type">uint</span></span>
         action selected by the compositor
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_data_source.Error"></a>
    <strong>wl_data_source.Error</strong>
    </dt>
    <dd>
    error


    <ul>
        <li><span class="parameter">INVALID_ACTION_MASK</span>
         0 action mask contains invalid values
        </li>
        <li><span class="parameter">INVALID_SOURCE</span>
         1 source doesn't accept this request
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_data_device"></a>Class wl_data_device </h2>

          <div class="section-description">
          data transfer device</p>

<p> There is one wl<em>data</em>device per seat which can be obtained
 from the global wl<em>data</em>device<em>manager singleton.
 A wl</em>data_device provides access to inter-client data transfer
 mechanisms such as copy-and-paste and drag-and-drop.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_data_device:start_drag"></a>
    <strong>wl_data_device:start_drag (source, origin, icon, serial)</strong>
    </dt>
    <dd>
    start drag-and-drop operation</p>

<p> This request asks the compositor to start a drag-and-drop
 operation on behalf of the client.
 The source argument is the data source that provides the data
 for the eventual data transfer. If source is NULL, enter, leave
 and motion events are sent only to the client that initiated the
 drag and the client is expected to handle the data passing
 internally. If source is destroyed, the drag-and-drop session will be
 cancelled.
 The origin surface is the surface where the drag originates and
 the client must have an active implicit grab that matches the
 serial.
 The icon surface is an optional (can be NULL) surface that
 provides an icon to be moved around with the cursor.  Initially,
 the top-left corner of the icon surface is placed at the cursor
 hotspot, but subsequent wl<em>surface.attach request can move the
 relative position. Attach requests must be confirmed with
 wl</em>surface.commit as usual. The icon surface is given the role of
 a drag-and-drop icon. If the icon surface already has another role,
 it raises a protocol error.
 The input region is ignored for wl<em>surfaces with the role of a
 drag-and-drop icon.
 The given source may not be used in any further set</em>selection or
 start<em>drag requests. Attempting to reuse a previously-used source
 may send a used</em>source error.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">source</span>
            <span class="types"><span class="type">wl_data_source</span></span>
         data source for the eventual transfer
        </li>
        <li><span class="parameter">origin</span>
            <span class="types"><span class="type">wl_surface</span></span>
         surface where the drag originates
        </li>
        <li><span class="parameter">icon</span>
            <span class="types"><span class="type">wl_surface</span></span>
         drag-and-drop icon surface
        </li>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the implicit grab on the origin
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_data_device</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_data_device:set_selection"></a>
    <strong>wl_data_device:set_selection (source, serial)</strong>
    </dt>
    <dd>
    copy data to the selection</p>

<p> This request asks the compositor to set the selection
 to the data from the source on behalf of the client.
 To unset the selection, set the source to NULL.
 The given source may not be used in any further set<em>selection or
 start</em>drag requests. Attempting to reuse a previously-used source
 may send a used_source error.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">source</span>
            <span class="types"><span class="type">wl_data_source</span></span>
         data source for the selection
        </li>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the event that triggered this request
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_data_device</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_data_device:release"></a>
    <strong>wl_data_device:release ()</strong>
    </dt>
    <dd>
    destroy data device  This request destroys the data device.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_data_device</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_data_device:data_offer"></a>
    <strong>wl_data_device:data_offer</strong>
    </dt>
    <dd>
    introduce a new wl<em>data</em>offer</p>

<p> The data<em>offer event introduces a new wl</em>data<em>offer object,
 which will subsequently be used in either the
 data</em>device.enter event (for drag-and-drop) or the
 data<em>device.selection event (for selections).   Immediately
 following the data</em>device.data<em>offer event, the new data</em>offer
 object will send out data_offer.offer events to describe the
 mime types it offers.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>
            <span class="types"><span class="type">wl_data_offer</span></span>
         the new data_offer object
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_data_device:enter"></a>
    <strong>wl_data_device:enter</strong>
    </dt>
    <dd>
    initiate drag-and-drop session</p>

<p> This event is sent when an active drag-and-drop pointer enters
 a surface owned by the client.   The position of the pointer at
 enter time is provided by the x and y arguments, in surface-local
 coordinates.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the enter event
        </li>
        <li><span class="parameter">surface</span>
            <span class="types"><span class="type">wl_surface</span></span>
         client surface entered
        </li>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">fixed</span></span>
         surface-local x coordinate
        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">fixed</span></span>
         surface-local y coordinate
        </li>
        <li><span class="parameter">id</span>
            <span class="types"><span class="type">wl_data_offer</span></span>
         source data_offer object
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_data_device:leave"></a>
    <strong>wl_data_device:leave</strong>
    </dt>
    <dd>
    end drag-and-drop session</p>

<p> This event is sent when the drag-and-drop pointer leaves the
 surface and the session ends.   The client must destroy the
 wl<em>data</em>offer introduced at enter time at this point.







</dd>
    <dt>
    <a name = "wl_data_device:motion"></a>
    <strong>wl_data_device:motion</strong>
    </dt>
    <dd>
    drag-and-drop session motion</p>

<p> This event is sent when the drag-and-drop pointer moves within
 the currently focused surface.  The new position of the pointer
 is provided by the x and y arguments, in surface-local
 coordinates.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">time</span>
            <span class="types"><span class="type">uint</span></span>
         timestamp with millisecond granularity
        </li>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">fixed</span></span>
         surface-local x coordinate
        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">fixed</span></span>
         surface-local y coordinate
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_data_device:drop"></a>
    <strong>wl_data_device:drop</strong>
    </dt>
    <dd>
    end drag-and-drop session successfully</p>

<p> The event is sent when a drag-and-drop operation is ended
 because the implicit grab is removed.
 The drag-and-drop destination is expected to honor the last action
 received through wl<em>data</em>offer.action, if the resulting action is
 "copy" or "move", the destination can still perform
 wl<em>data</em>offer.receive requests, and is expected to end all
 transfers with a wl<em>data</em>offer.finish request.
 If the resulting action is "ask", the action will not be considered
 final. The drag-and-drop destination is expected to perform one last
 wl<em>data</em>offer.set<em>actions request, or wl</em>data_offer.destroy in order
 to cancel the operation.







</dd>
    <dt>
    <a name = "wl_data_device:selection"></a>
    <strong>wl_data_device:selection</strong>
    </dt>
    <dd>
    advertise new selection</p>

<p> The selection event is sent out to notify the client of a new
 wl<em>data</em>offer for the selection for this device.   The
 data<em>device.data</em>offer and the data<em>offer.offer events are
 sent out immediately before this event to introduce the data
 offer object.  The selection event is sent to a client
 immediately before receiving keyboard focus and when a new
 selection is set while the client has keyboard focus.  The
 data</em>offer is valid until a new data<em>offer or NULL is received
 or until the client loses keyboard focus.  Switching surface with
 keyboard focus within the same client doesn't mean a new selection
 will be sent.  The client must destroy the previous selection
 data</em>offer, if any, upon receiving this event.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>
            <span class="types"><span class="type">wl_data_offer</span></span>
         selection data_offer object
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_data_device.Error"></a>
    <strong>wl_data_device.Error</strong>
    </dt>
    <dd>
    error


    <ul>
        <li><span class="parameter">ROLE</span>
         0 given wl_surface has another role
        </li>
        <li><span class="parameter">USED_SOURCE</span>
         1 source has already been used
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_data_device_manager"></a>Class wl_data_device_manager </h2>

          <div class="section-description">
          data transfer interface</p>

<p> The wl<em>data</em>device<em>manager is a singleton global object that
 provides access to inter-client data transfer mechanisms such as
 copy-and-paste and drag-and-drop.   These mechanisms are tied to
 a wl</em>seat and this interface lets a client get a wl<em>data</em>device
 corresponding to a wl<em>seat.
 Depending on the version bound, the objects created from the bound
 wl</em>data<em>device</em>manager object will have different requirements for
 functioning properly. See wl<em>data</em>source.set<em>actions,
 wl</em>data<em>offer.accept and wl</em>data_offer.finish for details.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_data_device_manager:create_data_source"></a>
    <strong>wl_data_device_manager:create_data_source ()</strong>
    </dt>
    <dd>
    create a new data source  Create a new data source.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_data_source</span></span>



    </ol>




</dd>
    <dt>
    <a name = "wl_data_device_manager:get_data_device"></a>
    <strong>wl_data_device_manager:get_data_device (seat)</strong>
    </dt>
    <dd>
    create a new data device  Create a new data device for a given seat.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">seat</span>
            <span class="types"><span class="type">wl_seat</span></span>
         seat associated with the data device
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_data_device</span></span>



    </ol>




</dd>
    <dt>
    <a name = "wl_data_device_manager.DndAction"></a>
    <strong>wl_data_device_manager.DndAction</strong>
    </dt>
    <dd>
    drag and drop actions</p>

<p> This is a bitmask of the available/preferred actions in a
 drag-and-drop operation.
 In the compositor, the selected action is a result of matching the
 actions offered by the source and destination sides.  "action" events
 with a "none" action will be sent to both source and destination if
 there is no match. All further checks will effectively happen on
 (source actions ∩ destination actions).
 In addition, compositors may also pick different actions in
 reaction to key modifiers being pressed. One common design that
 is used in major toolkits (and the behavior recommended for
 compositors) is:
 - If no modifiers are pressed, the first match (in bit order)
 will be used.
 - Pressing Shift selects "move", if enabled in the mask.
 - Pressing Control selects "copy", if enabled in the mask.
 Behavior beyond that is considered implementation-dependent.
 Compositors may for example bind other modifiers (like Alt/Meta)
 or drags initiated with other buttons than BTN_LEFT to specific
 actions (e.g. "ask").


    <ul>
        <li><span class="parameter">NONE</span>
         0 no action
        </li>
        <li><span class="parameter">COPY</span>
         1 copy action
        </li>
        <li><span class="parameter">MOVE</span>
         2 move action
        </li>
        <li><span class="parameter">ASK</span>
         4 ask action
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_shell"></a>Class wl_shell </h2>

          <div class="section-description">
          create desktop-style surfaces</p>

<p> This interface is implemented by servers that provide
 desktop-style user interfaces.
 It allows clients to associate a wl<em>shell</em>surface with
 a basic surface.
 Note! This protocol is deprecated and not intended for production use.
 For desktop-style user interfaces, use xdg_shell. Compositors and clients
 should not implement this interface.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_shell:get_shell_surface"></a>
    <strong>wl_shell:get_shell_surface (surface)</strong>
    </dt>
    <dd>
    create a shell surface from a surface</p>

<p> Create a shell surface for an existing surface.  This gives
 the wl<em>surface the role of a shell surface. If the wl</em>surface
 already has another role, it raises a protocol error.
 Only one shell surface can be associated with a given surface.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">surface</span>
            <span class="types"><span class="type">wl_surface</span></span>
         surface to be given the shell surface role
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_shell_surface</span></span>



    </ol>




</dd>
    <dt>
    <a name = "wl_shell.Error"></a>
    <strong>wl_shell.Error</strong>
    </dt>
    <dd>
    error


    <ul>
        <li><span class="parameter">ROLE</span>
         0 given wl_surface has another role
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_shell_surface"></a>Class wl_shell_surface </h2>

          <div class="section-description">
          desktop-style metadata interface</p>

<p> An interface that may be implemented by a wl<em>surface, for
 implementations that provide a desktop-style user interface.
 It provides requests to treat surfaces like toplevel, fullscreen
 or popup windows, move, resize or maximize them, associate
 metadata like title and class, etc.
 On the server side the object is automatically destroyed when
 the related wl</em>surface is destroyed. On the client side,
 wl<em>shell</em>surface<em>destroy() must be called before destroying
 the wl</em>surface object.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_shell_surface:pong"></a>
    <strong>wl_shell_surface:pong (serial)</strong>
    </dt>
    <dd>
    respond to a ping event  A client must respond to a ping event with a pong request or
 the client may be deemed unresponsive.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the ping event
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_shell_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_shell_surface:move"></a>
    <strong>wl_shell_surface:move (seat, serial)</strong>
    </dt>
    <dd>
    start an interactive move</p>

<p> Start a pointer-driven move of the surface.
 This request must be used in response to a button press event.
 The server may ignore move requests depending on the state of
 the surface (e.g. fullscreen or maximized).


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">seat</span>
            <span class="types"><span class="type">wl_seat</span></span>
         seat whose pointer is used
        </li>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the implicit grab on the pointer
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_shell_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_shell_surface:resize"></a>
    <strong>wl_shell_surface:resize (seat, serial, edges)</strong>
    </dt>
    <dd>
    start an interactive resize</p>

<p> Start a pointer-driven resizing of the surface.
 This request must be used in response to a button press event.
 The server may ignore resize requests depending on the state of
 the surface (e.g. fullscreen or maximized).


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">seat</span>
            <span class="types"><span class="type">wl_seat</span></span>
         seat whose pointer is used
        </li>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the implicit grab on the pointer
        </li>
        <li><span class="parameter">edges</span>
            <span class="types"><span class="type">uint</span></span>
         which edge or corner is being dragged
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_shell_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_shell_surface:set_toplevel"></a>
    <strong>wl_shell_surface:set_toplevel ()</strong>
    </dt>
    <dd>
    make the surface a toplevel surface</p>

<p> Map the surface as a toplevel surface.
 A toplevel surface is not fullscreen, maximized or transient.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_shell_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_shell_surface:set_transient"></a>
    <strong>wl_shell_surface:set_transient (parent, x, y, flags)</strong>
    </dt>
    <dd>
    make the surface a transient surface</p>

<p> Map the surface relative to an existing surface.
 The x and y arguments specify the location of the upper left
 corner of the surface relative to the upper left corner of the
 parent surface, in surface-local coordinates.
 The flags argument controls details of the transient behaviour.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">parent</span>
            <span class="types"><span class="type">wl_surface</span></span>
         parent surface
        </li>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">int</span></span>
         surface-local x coordinate
        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">int</span></span>
         surface-local y coordinate
        </li>
        <li><span class="parameter">flags</span>
            <span class="types"><span class="type">uint</span></span>
         transient surface behavior
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_shell_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_shell_surface:set_fullscreen"></a>
    <strong>wl_shell_surface:set_fullscreen (method, framerate, output)</strong>
    </dt>
    <dd>
    make the surface a fullscreen surface</p>

<p> Map the surface as a fullscreen surface.
 If an output parameter is given then the surface will be made
 fullscreen on that output. If the client does not specify the
 output then the compositor will apply its policy - usually
 choosing the output on which the surface has the biggest surface
 area.
 The client may specify a method to resolve a size conflict
 between the output size and the surface size - this is provided
 through the method parameter.
 The framerate parameter is used only when the method is set
 to "driver", to indicate the preferred framerate. A value of 0
 indicates that the client does not care about framerate.  The
 framerate is specified in mHz, that is framerate of 60000 is 60Hz.
 A method of "scale" or "driver" implies a scaling operation of
 the surface, either via a direct scaling operation or a change of
 the output mode. This will override any kind of output scaling, so
 that mapping a surface with a buffer size equal to the mode can
 fill the screen independent of buffer<em>scale.
 A method of "fill" means we don't scale up the buffer, however
 any output scale is applied. This means that you may run into
 an edge case where the application maps a buffer with the same
 size of the output mode but buffer</em>scale 1 (thus making a
 surface larger than the output). In this case it is allowed to
 downscale the results to fit the screen.
 The compositor must reply to this request with a configure event
 with the dimensions for the output on which the surface will
 be made fullscreen.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">method</span>
            <span class="types"><span class="type">uint</span></span>
         method for resolving size conflict
        </li>
        <li><span class="parameter">framerate</span>
            <span class="types"><span class="type">uint</span></span>
         framerate in mHz
        </li>
        <li><span class="parameter">output</span>
            <span class="types"><span class="type">wl_output</span></span>
         output on which the surface is to be fullscreen
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_shell_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_shell_surface:set_popup"></a>
    <strong>wl_shell_surface:set_popup (seat, serial, parent, x, y, flags)</strong>
    </dt>
    <dd>
    make the surface a popup surface</p>

<p> Map the surface as a popup.
 A popup surface is a transient surface with an added pointer
 grab.
 An existing implicit grab will be changed to owner-events mode,
 and the popup grab will continue after the implicit grab ends
 (i.e. releasing the mouse button does not cause the popup to
 be unmapped).
 The popup grab continues until the window is destroyed or a
 mouse button is pressed in any other client's window. A click
 in any of the client's surfaces is reported as normal, however,
 clicks in other clients' surfaces will be discarded and trigger
 the callback.
 The x and y arguments specify the location of the upper left
 corner of the surface relative to the upper left corner of the
 parent surface, in surface-local coordinates.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">seat</span>
            <span class="types"><span class="type">wl_seat</span></span>
         seat whose pointer is used
        </li>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the implicit grab on the pointer
        </li>
        <li><span class="parameter">parent</span>
            <span class="types"><span class="type">wl_surface</span></span>
         parent surface
        </li>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">int</span></span>
         surface-local x coordinate
        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">int</span></span>
         surface-local y coordinate
        </li>
        <li><span class="parameter">flags</span>
            <span class="types"><span class="type">uint</span></span>
         transient surface behavior
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_shell_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_shell_surface:set_maximized"></a>
    <strong>wl_shell_surface:set_maximized (output)</strong>
    </dt>
    <dd>
    make the surface a maximized surface</p>

<p> Map the surface as a maximized surface.
 If an output parameter is given then the surface will be
 maximized on that output. If the client does not specify the
 output then the compositor will apply its policy - usually
 choosing the output on which the surface has the biggest surface
 area.
 The compositor will reply with a configure event telling
 the expected new surface size. The operation is completed
 on the next buffer attach to this surface.
 A maximized surface typically fills the entire output it is
 bound to, except for desktop elements such as panels. This is
 the main difference between a maximized shell surface and a
 fullscreen shell surface.
 The details depend on the compositor implementation.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">output</span>
            <span class="types"><span class="type">wl_output</span></span>
         output on which the surface is to be maximized
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_shell_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_shell_surface:set_title"></a>
    <strong>wl_shell_surface:set_title (title)</strong>
    </dt>
    <dd>
    set surface title</p>

<p> Set a short title for the surface.
 This string may be used to identify the surface in a task bar,
 window list, or other user interface elements provided by the
 compositor.
 The string must be encoded in UTF-8.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">title</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.4/manual.html#6.4">string</a></span>
         surface title
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_shell_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_shell_surface:set_class"></a>
    <strong>wl_shell_surface:set_class (class_)</strong>
    </dt>
    <dd>
    set surface class</p>

<p> Set a class for the surface.
 The surface class identifies the general class of applications
 to which the surface belongs. A common convention is to use the
 file name (or the full path if it is a non-standard location) of
 the application's .desktop file as the class.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">class_</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.4/manual.html#6.4">string</a></span>
         surface class
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_shell_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_shell_surface:ping"></a>
    <strong>wl_shell_surface:ping</strong>
    </dt>
    <dd>
    ping client</p>

<p> Ping a client to check if it is receiving events and sending
 requests.  A client is expected to reply with a pong request.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the ping
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_shell_surface:configure"></a>
    <strong>wl_shell_surface:configure</strong>
    </dt>
    <dd>
    suggest resize</p>

<p> The configure event asks the client to resize its surface.
 The size is a hint, in the sense that the client is free to
 ignore it if it doesn't resize, pick a smaller size (to
 satisfy aspect ratio or resize in steps of NxM pixels).
 The edges parameter provides a hint about how the surface
 was resized. The client may use this information to decide
 how to adjust its content to the new size (e.g. a scrolling
 area might adjust its content position to leave the viewable
 content unmoved).
 The client is free to dismiss all but the last configure
 event it received.
 The width and height arguments specify the size of the window
 in surface-local coordinates.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">edges</span>
            <span class="types"><span class="type">uint</span></span>
         how the surface was resized
        </li>
        <li><span class="parameter">width</span>
            <span class="types"><span class="type">int</span></span>
         new width of the surface
        </li>
        <li><span class="parameter">height</span>
            <span class="types"><span class="type">int</span></span>
         new height of the surface
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_shell_surface:popup_done"></a>
    <strong>wl_shell_surface:popup_done</strong>
    </dt>
    <dd>
    popup interaction is done  The popup_done event is sent out when a popup grab is broken,
 that is, when the user clicks a surface that doesn't belong
 to the client owning the popup surface.







</dd>
    <dt>
    <a name = "wl_shell_surface.Resize"></a>
    <strong>wl_shell_surface.Resize</strong>
    </dt>
    <dd>
    edge values for resizing</p>

<p> These values are used to indicate which edge of a surface
 is being dragged in a resize operation.  The server may
 use this information to adapt its behavior, e.g. choose
 an appropriate cursor image.


    <ul>
        <li><span class="parameter">NONE</span>
         0 no edge
        </li>
        <li><span class="parameter">TOP</span>
         1 top edge
        </li>
        <li><span class="parameter">BOTTOM</span>
         2 bottom edge
        </li>
        <li><span class="parameter">LEFT</span>
         4 left edge
        </li>
        <li><span class="parameter">TOP_LEFT</span>
         5 top and left edges
        </li>
        <li><span class="parameter">BOTTOM_LEFT</span>
         6 bottom and left edges
        </li>
        <li><span class="parameter">RIGHT</span>
         8 right edge
        </li>
        <li><span class="parameter">TOP_RIGHT</span>
         9 top and right edges
        </li>
        <li><span class="parameter">BOTTOM_RIGHT</span>
         10 bottom and right edges
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_shell_surface.Transient"></a>
    <strong>wl_shell_surface.Transient</strong>
    </dt>
    <dd>
    details of transient behaviour</p>

<p> These flags specify details of the expected behaviour
 of transient surfaces.  Used in the set_transient request.


    <ul>
        <li><span class="parameter">INACTIVE</span>
         0x1 do not set keyboard focus
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_shell_surface.FullscreenMethod"></a>
    <strong>wl_shell_surface.FullscreenMethod</strong>
    </dt>
    <dd>
    different method to set the surface fullscreen</p>

<p> Hints to indicate to the compositor how to deal with a conflict
 between the dimensions of the surface and the dimensions of the
 output.  The compositor is free to ignore this parameter.


    <ul>
        <li><span class="parameter">DEFAULT</span>
         0 no preference, apply default policy
        </li>
        <li><span class="parameter">SCALE</span>
         1 scale, preserve the surface's aspect ratio and center on output
        </li>
        <li><span class="parameter">DRIVER</span>
         2 switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
        </li>
        <li><span class="parameter">FILL</span>
         3 no upscaling, center on output and add black borders to compensate size mismatch
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_surface"></a>Class wl_surface </h2>

          <div class="section-description">
          an onscreen surface</p>

<p> A surface is a rectangular area that may be displayed on zero
 or more outputs, and shown any number of times at the compositor's
 discretion.  They can present wl<em>buffers, receive user input, and
 define a local coordinate system.
 The size of a surface (and relative positions on it) is described
 in surface-local coordinates, which may differ from the buffer
 coordinates of the pixel content, in case a buffer</em>transform
 or a buffer<em>scale is used.
 A surface without a "role" is fairly useless: a compositor does
 not know where, when or how to present it. The role is the
 purpose of a wl</em>surface. Examples of roles are a cursor for a
 pointer (as set by wl<em>pointer.set</em>cursor), a drag icon
 (wl<em>data</em>device.start<em>drag), a sub-surface
 (wl</em>subcompositor.get<em>subsurface), and a window as defined by a
 shell protocol (e.g. wl</em>shell.get<em>shell</em>surface).
 A surface can have only one role at a time. Initially a
 wl<em>surface does not have a role. Once a wl</em>surface is given a
 role, it is set permanently for the whole lifetime of the
 wl<em>surface object. Giving the current role again is allowed,
 unless explicitly forbidden by the relevant interface
 specification.
 Surface roles are given by requests in other interfaces such as
 wl</em>pointer.set<em>cursor. The request should explicitly mention
 that this request gives a role to a wl</em>surface. Often, this
 request also creates a new protocol object that represents the
 role and adds additional functionality to wl<em>surface. When a
 client wants to destroy a wl</em>surface, they must destroy this role
 object before the wl<em>surface, otherwise a defunct</em>role<em>object error is
 sent.
 Destroying the role object does not remove the role from the
 wl</em>surface, but it may stop the wl<em>surface from "playing the role".
 For instance, if a wl</em>subsurface object is destroyed, the wl<em>surface
 it was created for will be unmapped and forget its position and
 z-order. It is allowed to create a wl</em>subsurface for the same
 wl<em>surface again, but it is not allowed to use the wl</em>surface as
 a cursor (cursor is a different role than sub-surface, and role
 switching is not allowed).
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_surface:destroy"></a>
    <strong>wl_surface:destroy ()</strong>
    </dt>
    <dd>
    delete surface  Deletes the surface and invalidates its object ID.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_surface:attach"></a>
    <strong>wl_surface:attach (buffer, x, y)</strong>
    </dt>
    <dd>
    set the surface contents</p>

<p> Set a buffer as the content of this surface.
 The new size of the surface is calculated based on the buffer
 size transformed by the inverse buffer<em>transform and the
 inverse buffer</em>scale. This means that at commit time the supplied
 buffer size must be an integer multiple of the buffer<em>scale. If
 that's not the case, an invalid</em>size error is sent.
 The x and y arguments specify the location of the new pending
 buffer's upper left corner, relative to the current buffer's upper
 left corner, in surface-local coordinates. In other words, the
 x and y, combined with the new surface size define in which
 directions the surface's size changes. Setting anything other than 0
 as x and y arguments is discouraged, and should instead be replaced
 with using the separate wl<em>surface.offset request.
 When the bound wl</em>surface version is 5 or higher, passing any
 non-zero x or y is a protocol violation, and will result in an
 'invalid<em>offset' error being raised. The x and y arguments are ignored
 and do not change the pending state. To achieve equivalent semantics,
 use wl</em>surface.offset.
 Surface contents are double-buffered state, see wl<em>surface.commit.
 The initial surface contents are void; there is no content.
 wl</em>surface.attach assigns the given wl<em>buffer as the pending
 wl</em>buffer. wl<em>surface.commit makes the pending wl</em>buffer the new
 surface contents, and the size of the surface becomes the size
 calculated from the wl<em>buffer, as described above. After commit,
 there is no pending buffer until the next attach.
 Committing a pending wl</em>buffer allows the compositor to read the
 pixels in the wl<em>buffer. The compositor may access the pixels at
 any time after the wl</em>surface.commit request. When the compositor
 will not access the pixels anymore, it will send the
 wl<em>buffer.release event. Only after receiving wl</em>buffer.release,
 the client may reuse the wl<em>buffer. A wl</em>buffer that has been
 attached and then replaced by another attach instead of committed
 will not receive a release event, and is not used by the
 compositor.
 If a pending wl<em>buffer has been committed to more than one wl</em>surface,
 the delivery of wl<em>buffer.release events becomes undefined. A well
 behaved client should not rely on wl</em>buffer.release events in this
 case. Alternatively, a client could create multiple wl<em>buffer objects
 from the same backing storage or use wp</em>linux<em>buffer</em>release.
 Destroying the wl<em>buffer after wl</em>buffer.release does not change
 the surface contents. Destroying the wl<em>buffer before wl</em>buffer.release
 is allowed as long as the underlying buffer storage isn't re-used (this
 can happen e.g. on client process termination). However, if the client
 destroys the wl<em>buffer before receiving the wl</em>buffer.release event and
 mutates the underlying buffer storage, the surface contents become
 undefined immediately.
 If wl<em>surface.attach is sent with a NULL wl</em>buffer, the
 following wl_surface.commit will remove the surface content.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">buffer</span>
            <span class="types"><span class="type">wl_buffer</span></span>
         buffer of surface contents
        </li>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">int</span></span>
         surface-local x coordinate
        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">int</span></span>
         surface-local y coordinate
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_surface:damage"></a>
    <strong>wl_surface:damage (x, y, width, height)</strong>
    </dt>
    <dd>
    mark part of the surface damaged</p>

<p> This request is used to describe the regions where the pending
 buffer is different from the current surface contents, and where
 the surface therefore needs to be repainted.  The compositor
 ignores the parts of the damage that fall outside of the surface.
 Damage is double-buffered state, see wl<em>surface.commit.
 The damage rectangle is specified in surface-local coordinates,
 where x and y specify the upper left corner of the damage rectangle.
 The initial value for pending damage is empty: no damage.
 wl</em>surface.damage adds pending damage: the new pending damage
 is the union of old pending damage and the given rectangle.
 wl<em>surface.commit assigns pending damage as the current damage,
 and clears pending damage. The server will clear the current
 damage as it repaints the surface.
 Note! New clients should not use this request. Instead damage can be
 posted with wl</em>surface.damage_buffer which uses buffer coordinates
 instead of surface coordinates.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">int</span></span>
         surface-local x coordinate
        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">int</span></span>
         surface-local y coordinate
        </li>
        <li><span class="parameter">width</span>
            <span class="types"><span class="type">int</span></span>
         width of damage rectangle
        </li>
        <li><span class="parameter">height</span>
            <span class="types"><span class="type">int</span></span>
         height of damage rectangle
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_surface:frame"></a>
    <strong>wl_surface:frame ()</strong>
    </dt>
    <dd>
    request a frame throttling hint</p>

<p> Request a notification when it is a good time to start drawing a new
 frame, by creating a frame callback.  This is useful for throttling
 redrawing operations, and driving animations.
 When a client is animating on a wl<em>surface, it can use the 'frame'
 request to get notified when it is a good time to draw and commit the
 next frame of animation. If the client commits an update earlier than
 that, it is likely that some updates will not make it to the display,
 and the client is wasting resources by drawing too often.
 The frame request will take effect on the next wl</em>surface.commit.
 The notification will only be posted for one frame unless
 requested again. For a wl<em>surface, the notifications are posted in
 the order the frame requests were committed.
 The server must send the notifications so that a client
 will not send excessive updates, while still allowing
 the highest possible update rate for clients that wait for the reply
 before drawing again. The server should give some time for the client
 to draw and commit after sending the frame callback events to let it
 hit the next output refresh.
 A server should avoid signaling the frame callbacks if the
 surface is not visible in any way, e.g. the surface is off-screen,
 or completely obscured by other opaque surfaces.
 The object returned by this request will be destroyed by the
 compositor after the callback is fired and as such the client must not
 attempt to use it after that point.
 The callback</em>data passed in the callback is the current time, in
 milliseconds, with an undefined base.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_callback</span></span>



    </ol>




</dd>
    <dt>
    <a name = "wl_surface:set_opaque_region"></a>
    <strong>wl_surface:set_opaque_region (region)</strong>
    </dt>
    <dd>
    set opaque region</p>

<p> This request sets the region of the surface that contains
 opaque content.
 The opaque region is an optimization hint for the compositor
 that lets it optimize the redrawing of content behind opaque
 regions.  Setting an opaque region is not required for correct
 behaviour, but marking transparent content as opaque will result
 in repaint artifacts.
 The opaque region is specified in surface-local coordinates.
 The compositor ignores the parts of the opaque region that fall
 outside of the surface.
 Opaque region is double-buffered state, see wl<em>surface.commit.
 wl</em>surface.set<em>opaque</em>region changes the pending opaque region.
 wl<em>surface.commit copies the pending region to the current region.
 Otherwise, the pending and current regions are never changed.
 The initial value for an opaque region is empty. Setting the pending
 opaque region has copy semantics, and the wl</em>region object can be
 destroyed immediately. A NULL wl_region causes the pending opaque
 region to be set to empty.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">region</span>
            <span class="types"><span class="type">wl_region</span></span>
         opaque region of the surface
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_surface:set_input_region"></a>
    <strong>wl_surface:set_input_region (region)</strong>
    </dt>
    <dd>
    set input region</p>

<p> This request sets the region of the surface that can receive
 pointer and touch events.
 Input events happening outside of this region will try the next
 surface in the server surface stack. The compositor ignores the
 parts of the input region that fall outside of the surface.
 The input region is specified in surface-local coordinates.
 Input region is double-buffered state, see wl<em>surface.commit.
 wl</em>surface.set<em>input</em>region changes the pending input region.
 wl<em>surface.commit copies the pending region to the current region.
 Otherwise the pending and current regions are never changed,
 except cursor and icon surfaces are special cases, see
 wl</em>pointer.set<em>cursor and wl</em>data<em>device.start</em>drag.
 The initial value for an input region is infinite. That means the
 whole surface will accept input. Setting the pending input region
 has copy semantics, and the wl<em>region object can be destroyed
 immediately. A NULL wl</em>region causes the input region to be set
 to infinite.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">region</span>
            <span class="types"><span class="type">wl_region</span></span>
         input region of the surface
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_surface:commit"></a>
    <strong>wl_surface:commit ()</strong>
    </dt>
    <dd>
    commit pending surface state</p>

<p> Surface state (input, opaque, and damage regions, attached buffers,
 etc.) is double-buffered.  Protocol requests modify the pending state,
 as opposed to the current state in use by the compositor. A commit
 request atomically applies all pending state, replacing the current
 state. After commit, the new pending state is as documented for each
 related request.
 On commit, a pending wl<em>buffer is applied first, and all other state
 second. This means that all coordinates in double-buffered state are
 relative to the new wl</em>buffer coming into use, except for
 wl<em>surface.attach itself. If there is no pending wl</em>buffer, the
 coordinates are relative to the current surface contents.
 All requests that need a commit to become effective are documented
 to affect double-buffered state.
 Other interfaces may add further double-buffered surface state.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_surface:set_buffer_transform"></a>
    <strong>wl_surface:set_buffer_transform (transform)</strong>
    </dt>
    <dd>
    sets the buffer transformation</p>

<p> This request sets an optional transformation on how the compositor
 interprets the contents of the buffer attached to the surface.  The
 accepted values for the transform parameter are the values for
 wl<em>output.transform.
 Buffer transform is double-buffered state, see wl</em>surface.commit.
 A newly created surface has its buffer transformation set to normal.
 wl<em>surface.set</em>buffer<em>transform changes the pending buffer
 transformation. wl</em>surface.commit copies the pending buffer
 transformation to the current one. Otherwise, the pending and current
 values are never changed.
 The purpose of this request is to allow clients to render content
 according to the output transform, thus permitting the compositor to
 use certain optimizations even if the display is rotated. Using
 hardware overlays and scanning out a client buffer for fullscreen
 surfaces are examples of such optimizations. Those optimizations are
 highly dependent on the compositor implementation, so the use of this
 request should be considered on a case-by-case basis.
 Note that if the transform value includes 90 or 270 degree rotation,
 the width of the buffer will become the surface height and the height
 of the buffer will become the surface width.
 If transform is not one of the values from the
 wl<em>output.transform enum the invalid</em>transform protocol error
 is raised.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">transform</span>
            <span class="types"><span class="type">int</span></span>
         transform for interpreting buffer contents
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_surface:set_buffer_scale"></a>
    <strong>wl_surface:set_buffer_scale (scale)</strong>
    </dt>
    <dd>
    sets the buffer scaling factor</p>

<p> This request sets an optional scaling factor on how the compositor
 interprets the contents of the buffer attached to the window.
 Buffer scale is double-buffered state, see wl<em>surface.commit.
 A newly created surface has its buffer scale set to 1.
 wl</em>surface.set<em>buffer</em>scale changes the pending buffer scale.
 wl<em>surface.commit copies the pending buffer scale to the current one.
 Otherwise, the pending and current values are never changed.
 The purpose of this request is to allow clients to supply higher
 resolution buffer data for use on high resolution outputs. It is
 intended that you pick the same buffer scale as the scale of the
 output that the surface is displayed on. This means the compositor
 can avoid scaling when rendering the surface on that output.
 Note that if the scale is larger than 1, then you have to attach
 a buffer that is larger (by a factor of scale in each dimension)
 than the desired surface size.
 If scale is not positive the invalid</em>scale protocol error is
 raised.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">scale</span>
            <span class="types"><span class="type">int</span></span>
         positive scale for interpreting buffer contents
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_surface:damage_buffer"></a>
    <strong>wl_surface:damage_buffer (x, y, width, height)</strong>
    </dt>
    <dd>
    mark part of the surface damaged using buffer coordinates</p>

<p> This request is used to describe the regions where the pending
 buffer is different from the current surface contents, and where
 the surface therefore needs to be repainted.  The compositor
 ignores the parts of the damage that fall outside of the surface.
 Damage is double-buffered state, see wl<em>surface.commit.
 The damage rectangle is specified in buffer coordinates,
 where x and y specify the upper left corner of the damage rectangle.
 The initial value for pending damage is empty: no damage.
 wl</em>surface.damage<em>buffer adds pending damage: the new pending
 damage is the union of old pending damage and the given rectangle.
 wl</em>surface.commit assigns pending damage as the current damage,
 and clears pending damage. The server will clear the current
 damage as it repaints the surface.
 This request differs from wl<em>surface.damage in only one way - it
 takes damage in buffer coordinates instead of surface-local
 coordinates. While this generally is more intuitive than surface
 coordinates, it is especially desirable when using wp</em>viewport
 or when a drawing library (like EGL) is unaware of buffer scale
 and buffer transform.
 Note: Because buffer transformation changes and damage requests may
 be interleaved in the protocol stream, it is impossible to determine
 the actual mapping between surface and buffer damage until
 wl<em>surface.commit time. Therefore, compositors wishing to take both
 kinds of damage into account will have to accumulate damage from the
 two requests separately and only transform from one to the other
 after receiving the wl</em>surface.commit.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">int</span></span>
         buffer-local x coordinate
        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">int</span></span>
         buffer-local y coordinate
        </li>
        <li><span class="parameter">width</span>
            <span class="types"><span class="type">int</span></span>
         width of damage rectangle
        </li>
        <li><span class="parameter">height</span>
            <span class="types"><span class="type">int</span></span>
         height of damage rectangle
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_surface:offset"></a>
    <strong>wl_surface:offset (x, y)</strong>
    </dt>
    <dd>
    set the surface contents offset</p>

<p> The x and y arguments specify the location of the new pending
 buffer's upper left corner, relative to the current buffer's upper
 left corner, in surface-local coordinates.  In other words, the
 x and y, combined with the new surface size define in which
 directions the surface's size changes.
 Surface location offset is double-buffered state, see
 wl<em>surface.commit.
 This request is semantically equivalent to and the replaces the x and y
 arguments in the wl</em>surface.attach request in wl<em>surface versions prior
 to 5. See wl</em>surface.attach for details.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">int</span></span>
         surface-local x coordinate
        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">int</span></span>
         surface-local y coordinate
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_surface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_surface:enter"></a>
    <strong>wl_surface:enter</strong>
    </dt>
    <dd>
    surface enters an output</p>

<p> This is emitted whenever a surface's creation, movement, or resizing
 results in some part of it being within the scanout region of an
 output.
 Note that a surface may be overlapping with zero or more outputs.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">output</span>
            <span class="types"><span class="type">wl_output</span></span>
         output entered by the surface
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_surface:leave"></a>
    <strong>wl_surface:leave</strong>
    </dt>
    <dd>
    surface leaves an output</p>

<p> This is emitted whenever a surface's creation, movement, or resizing
 results in it no longer having any part of it within the scanout region
 of an output.
 Clients should not use the number of outputs the surface is on for frame
 throttling purposes. The surface might be hidden even if no leave event
 has been sent, and the compositor might expect new surface content
 updates even if no enter event has been sent. The frame event should be
 used instead.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">output</span>
            <span class="types"><span class="type">wl_output</span></span>
         output left by the surface
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_surface:preferred_buffer_scale"></a>
    <strong>wl_surface:preferred_buffer_scale</strong>
    </dt>
    <dd>
    preferred buffer scale for the surface</p>

<p> This event indicates the preferred buffer scale for this surface.  It is
 sent whenever the compositor's preference changes.
 It is intended that scaling aware clients use this event to scale their
 content and use wl<em>surface.set</em>buffer_scale to indicate the scale they
 have rendered with. This allows clients to supply a higher detail
 buffer.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">factor</span>
            <span class="types"><span class="type">int</span></span>
         preferred scaling factor
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_surface:preferred_buffer_transform"></a>
    <strong>wl_surface:preferred_buffer_transform</strong>
    </dt>
    <dd>
    preferred buffer transform for the surface</p>

<p> This event indicates the preferred buffer transform for this surface.
 It is sent whenever the compositor's preference changes.
 It is intended that transform aware clients use this event to apply the
 transform to their content and use wl<em>surface.set</em>buffer_transform to
 indicate the transform they have rendered with.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">transform</span>
            <span class="types"><span class="type">uint</span></span>
         preferred transform
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_surface.Error"></a>
    <strong>wl_surface.Error</strong>
    </dt>
    <dd>
    wl<em>surface error values  These errors can be emitted in response to wl</em>surface requests.


    <ul>
        <li><span class="parameter">INVALID_SCALE</span>
         0 buffer scale value is invalid
        </li>
        <li><span class="parameter">INVALID_TRANSFORM</span>
         1 buffer transform value is invalid
        </li>
        <li><span class="parameter">INVALID_SIZE</span>
         2 buffer size is invalid
        </li>
        <li><span class="parameter">INVALID_OFFSET</span>
         3 buffer offset is invalid
        </li>
        <li><span class="parameter">DEFUNCT_ROLE_OBJECT</span>
         4 surface was destroyed before its role object
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_seat"></a>Class wl_seat </h2>

          <div class="section-description">
          group of input devices</p>

<p> A seat is a group of keyboards, pointer and touch devices.  This
 object is published as a global during start up, or when such a
 device is hot plugged.  A seat typically has a pointer and
 maintains a keyboard focus and a pointer focus.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_seat:get_pointer"></a>
    <strong>wl_seat:get_pointer ()</strong>
    </dt>
    <dd>
    return pointer object</p>

<p> The ID provided will be initialized to the wl<em>pointer interface
 for this seat.
 This request only takes effect if the seat has the pointer
 capability, or has had the pointer capability in the past.
 It is a protocol violation to issue this request on a seat that has
 never had the pointer capability. The missing</em>capability error will
 be sent in this case.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_pointer</span></span>



    </ol>




</dd>
    <dt>
    <a name = "wl_seat:get_keyboard"></a>
    <strong>wl_seat:get_keyboard ()</strong>
    </dt>
    <dd>
    return keyboard object</p>

<p> The ID provided will be initialized to the wl<em>keyboard interface
 for this seat.
 This request only takes effect if the seat has the keyboard
 capability, or has had the keyboard capability in the past.
 It is a protocol violation to issue this request on a seat that has
 never had the keyboard capability. The missing</em>capability error will
 be sent in this case.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_keyboard</span></span>



    </ol>




</dd>
    <dt>
    <a name = "wl_seat:get_touch"></a>
    <strong>wl_seat:get_touch ()</strong>
    </dt>
    <dd>
    return touch object</p>

<p> The ID provided will be initialized to the wl<em>touch interface
 for this seat.
 This request only takes effect if the seat has the touch
 capability, or has had the touch capability in the past.
 It is a protocol violation to issue this request on a seat that has
 never had the touch capability. The missing</em>capability error will
 be sent in this case.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_touch</span></span>



    </ol>




</dd>
    <dt>
    <a name = "wl_seat:release"></a>
    <strong>wl_seat:release ()</strong>
    </dt>
    <dd>
    release the seat object  Using this request a client can tell the server that it is not going to
 use the seat object anymore.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_seat</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_seat:capabilities"></a>
    <strong>wl_seat:capabilities</strong>
    </dt>
    <dd>
    seat capabilities changed</p>

<p> This is emitted whenever a seat gains or loses the pointer,
 keyboard or touch capabilities.   The argument is a capability
 enum containing the complete set of capabilities this seat has.
 When the pointer capability is added, a client may create a
 wl<em>pointer object using the wl</em>seat.get<em>pointer request. This object
 will receive pointer events until the capability is removed in the
 future.
 When the pointer capability is removed, a client should destroy the
 wl</em>pointer objects associated with the seat where the capability was
 removed, using the wl<em>pointer.release request. No further pointer
 events will be received on these objects.
 In some compositors, if a seat regains the pointer capability and a
 client has a previously obtained wl</em>pointer object of version 4 or
 less, that object may start sending pointer events again. This
 behavior is considered a misinterpretation of the intended behavior
 and must not be relied upon by the client. wl<em>pointer objects of
 version 5 or later must not send events if created before the most
 recent event notifying the client of an added pointer capability.
 The above behavior also applies to wl</em>keyboard and wl_touch with the
 keyboard and touch capabilities, respectively.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">capabilities</span>
            <span class="types"><span class="type">uint</span></span>
         capabilities of the seat
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_seat:name"></a>
    <strong>wl_seat:name</strong>
    </dt>
    <dd>
    unique identifier for this seat</p>

<p> In a multi-seat configuration the seat name can be used by clients to
 help identify which physical devices the seat represents.
 The seat name is a UTF-8 string with no convention defined for its
 contents. Each name is unique among all wl<em>seat globals. The name is
 only guaranteed to be unique for the current compositor instance.
 The same seat names are used for all clients. Thus, the name can be
 shared across processes to refer to a specific wl</em>seat global.
 The name event is sent after binding to the seat global. This event is
 only sent once per seat object, and the name does not change over the
 lifetime of the wl<em>seat global.
 Compositors may re-use the same seat name if the wl</em>seat global is
 destroyed and re-created later.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">name</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.4/manual.html#6.4">string</a></span>
         seat identifier
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_seat.Capability"></a>
    <strong>wl_seat.Capability</strong>
    </dt>
    <dd>
    seat capability bitmask  This is a bitmask of capabilities this seat has; if a member is
 set, then it is present on the seat.


    <ul>
        <li><span class="parameter">POINTER</span>
         1 the seat has pointer devices
        </li>
        <li><span class="parameter">KEYBOARD</span>
         2 the seat has one or more keyboards
        </li>
        <li><span class="parameter">TOUCH</span>
         4 the seat has touch devices
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_seat.Error"></a>
    <strong>wl_seat.Error</strong>
    </dt>
    <dd>
    wl<em>seat error values  These errors can be emitted in response to wl</em>seat requests.


    <ul>
        <li><span class="parameter">MISSING_CAPABILITY</span>
         0 get<em>pointer, get</em>keyboard or get_touch called on seat without the matching capability
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_pointer"></a>Class wl_pointer </h2>

          <div class="section-description">
          pointer input device</p>

<p> The wl<em>pointer interface represents one or more input devices,
 such as mice, which control the pointer location and pointer</em>focus
 of a seat.
 The wl_pointer interface generates motion, enter and leave
 events for the surfaces that the pointer is located over,
 and button and axis events for button presses, button releases
 and scrolling.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_pointer:set_cursor"></a>
    <strong>wl_pointer:set_cursor (serial, surface, hotspot_x, hotspot_y)</strong>
    </dt>
    <dd>
    set the pointer surface</p>

<p> Set the pointer surface, i.e., the surface that contains the
 pointer image (cursor).  This request gives the surface the role
 of a cursor. If the surface already has another role, it raises
 a protocol error.
 The cursor actually changes only if the pointer
 focus for this device is one of the requesting client's surfaces
 or the surface parameter is the current pointer surface. If
 there was a previous surface set with this request it is
 replaced. If surface is NULL, the pointer image is hidden.
 The parameters hotspot<em>x and hotspot</em>y define the position of
 the pointer surface relative to the pointer location. Its
 top-left corner is always at (x, y) - (hotspot<em>x, hotspot</em>y),
 where (x, y) are the coordinates of the pointer location, in
 surface-local coordinates.
 On surface.attach requests to the pointer surface, hotspot<em>x
 and hotspot</em>y are decremented by the x and y parameters
 passed to the request. Attach must be confirmed by
 wl<em>surface.commit as usual.
 The hotspot can also be updated by passing the currently set
 pointer surface to this request with new values for hotspot</em>x
 and hotspot<em>y.
 The input region is ignored for wl</em>surfaces with the role of
 a cursor. When the use as a cursor ends, the wl<em>surface is
 unmapped.
 The serial parameter must match the latest wl</em>pointer.enter
 serial number sent to the client. Otherwise the request will be
 ignored.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the enter event
        </li>
        <li><span class="parameter">surface</span>
            <span class="types"><span class="type">wl_surface</span></span>
         pointer surface
        </li>
        <li><span class="parameter">hotspot_x</span>
            <span class="types"><span class="type">int</span></span>
         surface-local x coordinate
        </li>
        <li><span class="parameter">hotspot_y</span>
            <span class="types"><span class="type">int</span></span>
         surface-local y coordinate
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_pointer</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_pointer:release"></a>
    <strong>wl_pointer:release ()</strong>
    </dt>
    <dd>
    release the pointer object</p>

<p> Using this request a client can tell the server that it is not going to
 use the pointer object anymore.
 This request destroys the pointer proxy object, so clients must not call
 wl<em>pointer</em>destroy() after using this request.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_pointer</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_pointer:enter"></a>
    <strong>wl_pointer:enter</strong>
    </dt>
    <dd>
    enter event</p>

<p> Notification that this seat's pointer is focused on a certain
 surface.
 When a seat's focus enters a surface, the pointer image
 is undefined and a client should respond to this event by setting
 an appropriate pointer image with the set_cursor request.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the enter event
        </li>
        <li><span class="parameter">surface</span>
            <span class="types"><span class="type">wl_surface</span></span>
         surface entered by the pointer
        </li>
        <li><span class="parameter">surface_x</span>
            <span class="types"><span class="type">fixed</span></span>
         surface-local x coordinate
        </li>
        <li><span class="parameter">surface_y</span>
            <span class="types"><span class="type">fixed</span></span>
         surface-local y coordinate
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_pointer:leave"></a>
    <strong>wl_pointer:leave</strong>
    </dt>
    <dd>
    leave event</p>

<p> Notification that this seat's pointer is no longer focused on
 a certain surface.
 The leave notification is sent before the enter notification
 for the new focus.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the leave event
        </li>
        <li><span class="parameter">surface</span>
            <span class="types"><span class="type">wl_surface</span></span>
         surface left by the pointer
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_pointer:motion"></a>
    <strong>wl_pointer:motion</strong>
    </dt>
    <dd>
    pointer motion event</p>

<p> Notification of pointer location change.  The arguments
 surface<em>x and surface</em>y are the location relative to the
 focused surface.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">time</span>
            <span class="types"><span class="type">uint</span></span>
         timestamp with millisecond granularity
        </li>
        <li><span class="parameter">surface_x</span>
            <span class="types"><span class="type">fixed</span></span>
         surface-local x coordinate
        </li>
        <li><span class="parameter">surface_y</span>
            <span class="types"><span class="type">fixed</span></span>
         surface-local y coordinate
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_pointer:button"></a>
    <strong>wl_pointer:button</strong>
    </dt>
    <dd>
    pointer button event</p>

<p> Mouse button click and release notifications.
 The location of the click is given by the last motion or
 enter event.
 The time argument is a timestamp with millisecond
 granularity, with an undefined base.
 The button is a button code as defined in the Linux kernel's
 linux/input-event-codes.h header file, e.g. BTN_LEFT.
 Any 16-bit button code value is reserved for future additions to the
 kernel's event code list. All other button codes above 0xFFFF are
 currently undefined but may be used in future versions of this
 protocol.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the button event
        </li>
        <li><span class="parameter">time</span>
            <span class="types"><span class="type">uint</span></span>
         timestamp with millisecond granularity
        </li>
        <li><span class="parameter">button</span>
            <span class="types"><span class="type">uint</span></span>
         button that produced the event
        </li>
        <li><span class="parameter">state</span>
            <span class="types"><span class="type">uint</span></span>
         physical state of the button
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_pointer:axis"></a>
    <strong>wl_pointer:axis</strong>
    </dt>
    <dd>
    axis event</p>

<p> Scroll and other axis notifications.
 For scroll events (vertical and horizontal scroll axes), the
 value parameter is the length of a vector along the specified
 axis in a coordinate space identical to those of motion events,
 representing a relative movement along the specified axis.
 For devices that support movements non-parallel to axes multiple
 axis events will be emitted.
 When applicable, for example for touch pads, the server can
 choose to emit scroll events where the motion vector is
 equivalent to a motion event vector.
 When applicable, a client can transform its content relative to the
 scroll distance.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">time</span>
            <span class="types"><span class="type">uint</span></span>
         timestamp with millisecond granularity
        </li>
        <li><span class="parameter">axis</span>
            <span class="types"><span class="type">uint</span></span>
         axis type
        </li>
        <li><span class="parameter">value</span>
            <span class="types"><span class="type">fixed</span></span>
         length of vector in surface-local coordinate space
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_pointer:frame"></a>
    <strong>wl_pointer:frame</strong>
    </dt>
    <dd>
    end of a pointer event sequence</p>

<p> Indicates the end of a set of events that logically belong together.
 A client is expected to accumulate the data in all events within the
 frame before proceeding.
 All wl<em>pointer events before a wl</em>pointer.frame event belong
 logically together. For example, in a diagonal scroll motion the
 compositor will send an optional wl<em>pointer.axis</em>source event, two
 wl<em>pointer.axis events (horizontal and vertical) and finally a
 wl</em>pointer.frame event. The client may use this information to
 calculate a diagonal vector for scrolling.
 When multiple wl<em>pointer.axis events occur within the same frame,
 the motion vector is the combined motion of all events.
 When a wl</em>pointer.axis and a wl<em>pointer.axis</em>stop event occur within
 the same frame, this indicates that axis movement in one axis has
 stopped but continues in the other axis.
 When multiple wl<em>pointer.axis</em>stop events occur within the same
 frame, this indicates that these axes stopped in the same instance.
 A wl<em>pointer.frame event is sent for every logical event group,
 even if the group only contains a single wl</em>pointer event.
 Specifically, a client may get a sequence: motion, frame, button,
 frame, axis, frame, axis<em>stop, frame.
 The wl</em>pointer.enter and wl<em>pointer.leave events are logical events
 generated by the compositor and not the hardware. These events are
 also grouped by a wl</em>pointer.frame. When a pointer moves from one
 surface to another, a compositor should group the
 wl<em>pointer.leave event within the same wl</em>pointer.frame.
 However, a client must not rely on wl<em>pointer.leave and
 wl</em>pointer.enter being in the same wl<em>pointer.frame.
 Compositor-specific policies may require the wl</em>pointer.leave and
 wl<em>pointer.enter event being split across multiple wl</em>pointer.frame
 groups.







</dd>
    <dt>
    <a name = "wl_pointer:axis_source"></a>
    <strong>wl_pointer:axis_source</strong>
    </dt>
    <dd>
    axis source event</p>

<p> Source information for scroll and other axes.
 This event does not occur on its own. It is sent before a
 wl<em>pointer.frame event and carries the source information for
 all events within that frame.
 The source specifies how this event was generated. If the source is
 wl</em>pointer.axis<em>source.finger, a wl</em>pointer.axis<em>stop event will be
 sent when the user lifts the finger off the device.
 If the source is wl</em>pointer.axis<em>source.wheel,
 wl</em>pointer.axis<em>source.wheel</em>tilt or
 wl<em>pointer.axis</em>source.continuous, a wl<em>pointer.axis</em>stop event may
 or may not be sent. Whether a compositor sends an axis<em>stop event
 for these sources is hardware-specific and implementation-dependent;
 clients must not rely on receiving an axis</em>stop event for these
 scroll sources and should treat scroll sequences from these scroll
 sources as unterminated by default.
 This event is optional. If the source is unknown for a particular
 axis event sequence, no event is sent.
 Only one wl<em>pointer.axis</em>source event is permitted per frame.
 The order of wl<em>pointer.axis</em>discrete and wl<em>pointer.axis</em>source is
 not guaranteed.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">axis_source</span>
            <span class="types"><span class="type">uint</span></span>
         source of the axis event
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_pointer:axis_stop"></a>
    <strong>wl_pointer:axis_stop</strong>
    </dt>
    <dd>
    axis stop event</p>

<p> Stop notification for scroll and other axes.
 For some wl<em>pointer.axis</em>source types, a wl<em>pointer.axis</em>stop event
 is sent to notify a client that the axis sequence has terminated.
 This enables the client to implement kinetic scrolling.
 See the wl<em>pointer.axis</em>source documentation for information on when
 this event may be generated.
 Any wl<em>pointer.axis events with the same axis</em>source after this
 event should be considered as the start of a new axis motion.
 The timestamp is to be interpreted identical to the timestamp in the
 wl<em>pointer.axis event. The timestamp value may be the same as a
 preceding wl</em>pointer.axis event.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">time</span>
            <span class="types"><span class="type">uint</span></span>
         timestamp with millisecond granularity
        </li>
        <li><span class="parameter">axis</span>
            <span class="types"><span class="type">uint</span></span>
         the axis stopped with this event
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_pointer:axis_discrete"></a>
    <strong>wl_pointer:axis_discrete</strong>
    </dt>
    <dd>
    axis click event</p>

<p> Discrete step information for scroll and other axes.
 This event carries the axis value of the wl<em>pointer.axis event in
 discrete steps (e.g. mouse wheel clicks).
 This event is deprecated with wl</em>pointer version 8 - this event is not
 sent to clients supporting version 8 or later.
 This event does not occur on its own, it is coupled with a
 wl<em>pointer.axis event that represents this axis value on a
 continuous scale. The protocol guarantees that each axis</em>discrete
 event is always followed by exactly one axis event with the same
 axis number within the same wl<em>pointer.frame. Note that the protocol
 allows for other events to occur between the axis</em>discrete and
 its coupled axis event, including other axis<em>discrete or axis
 events. A wl</em>pointer.frame must not contain more than one axis<em>discrete
 event per axis type.
 This event is optional; continuous scrolling devices
 like two-finger scrolling on touchpads do not have discrete
 steps and do not generate this event.
 The discrete value carries the directional information. e.g. a value
 of -2 is two steps towards the negative direction of this axis.
 The axis number is identical to the axis number in the associated
 axis event.
 The order of wl</em>pointer.axis<em>discrete and wl</em>pointer.axis_source is
 not guaranteed.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">axis</span>
            <span class="types"><span class="type">uint</span></span>
         axis type
        </li>
        <li><span class="parameter">discrete</span>
            <span class="types"><span class="type">int</span></span>
         number of steps
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_pointer:axis_value120"></a>
    <strong>wl_pointer:axis_value120</strong>
    </dt>
    <dd>
    axis high-resolution scroll event</p>

<p> Discrete high-resolution scroll information.
 This event carries high-resolution wheel scroll information,
 with each multiple of 120 representing one logical scroll step
 (a wheel detent). For example, an axis<em>value120 of 30 is one quarter of
 a logical scroll step in the positive direction, a value120 of
 -240 are two logical scroll steps in the negative direction within the
 same hardware event.
 Clients that rely on discrete scrolling should accumulate the
 value120 to multiples of 120 before processing the event.
 The value120 must not be zero.
 This event replaces the wl</em>pointer.axis<em>discrete event in clients
 supporting wl</em>pointer version 8 or later.
 Where a wl<em>pointer.axis</em>source event occurs in the same
 wl<em>pointer.frame, the axis source applies to this event.
 The order of wl</em>pointer.axis<em>value120 and wl</em>pointer.axis_source is
 not guaranteed.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">axis</span>
            <span class="types"><span class="type">uint</span></span>
         axis type
        </li>
        <li><span class="parameter">value120</span>
            <span class="types"><span class="type">int</span></span>
         scroll distance as fraction of 120
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_pointer:axis_relative_direction"></a>
    <strong>wl_pointer:axis_relative_direction</strong>
    </dt>
    <dd>
    axis relative physical direction event</p>

<p> Relative directional information of the entity causing the axis
 motion.
 For a wl<em>pointer.axis event, the wl</em>pointer.axis<em>relative</em>direction
 event specifies the movement direction of the entity causing the
 wl<em>pointer.axis event. For example:
 - if a user's fingers on a touchpad move down and this
 causes a wl</em>pointer.axis vertical<em>scroll down event, the physical
 direction is 'identical'
 - if a user's fingers on a touchpad move down and this causes a
 wl</em>pointer.axis vertical<em>scroll up scroll up event ('natural
 scrolling'), the physical direction is 'inverted'.
 A client may use this information to adjust scroll motion of
 components. Specifically, enabling natural scrolling causes the
 content to change direction compared to traditional scrolling.
 Some widgets like volume control sliders should usually match the
 physical direction regardless of whether natural scrolling is
 active. This event enables clients to match the scroll direction of
 a widget to the physical direction.
 This event does not occur on its own, it is coupled with a
 wl</em>pointer.axis event that represents this axis value.
 The protocol guarantees that each axis<em>relative</em>direction event is
 always followed by exactly one axis event with the same
 axis number within the same wl<em>pointer.frame. Note that the protocol
 allows for other events to occur between the axis</em>relative<em>direction
 and its coupled axis event.
 The axis number is identical to the axis number in the associated
 axis event.
 The order of wl</em>pointer.axis<em>relative</em>direction,
 wl<em>pointer.axis</em>discrete and wl<em>pointer.axis</em>source is not
 guaranteed.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">axis</span>
            <span class="types"><span class="type">uint</span></span>
         axis type
        </li>
        <li><span class="parameter">direction</span>
            <span class="types"><span class="type">uint</span></span>
         physical direction relative to axis motion
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_pointer.Error"></a>
    <strong>wl_pointer.Error</strong>
    </dt>
    <dd>
    error


    <ul>
        <li><span class="parameter">ROLE</span>
         0 given wl_surface has another role
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_pointer.ButtonState"></a>
    <strong>wl_pointer.ButtonState</strong>
    </dt>
    <dd>
    physical button state  Describes the physical state of a button that produced the button
 event.


    <ul>
        <li><span class="parameter">RELEASED</span>
         0 the button is not pressed
        </li>
        <li><span class="parameter">PRESSED</span>
         1 the button is pressed
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_pointer.Axis"></a>
    <strong>wl_pointer.Axis</strong>
    </dt>
    <dd>
    axis types  Describes the axis types of scroll events.


    <ul>
        <li><span class="parameter">VERTICAL_SCROLL</span>
         0 vertical axis
        </li>
        <li><span class="parameter">HORIZONTAL_SCROLL</span>
         1 horizontal axis
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_pointer.AxisSource"></a>
    <strong>wl_pointer.AxisSource</strong>
    </dt>
    <dd>
    axis source types</p>

<p> Describes the source types for axis events.  This indicates to the
 client how an axis event was physically generated; a client may
 adjust the user interface accordingly. For example, scroll events
 from a "finger" source may be in a smooth coordinate space with
 kinetic scrolling whereas a "wheel" source may be in discrete steps
 of a number of lines.
 The "continuous" axis source is a device generating events in a
 continuous coordinate space, but using something other than a
 finger. One example for this source is button-based scrolling where
 the vertical motion of a device is converted to scroll events while
 a button is held down.
 The "wheel tilt" axis source indicates that the actual device is a
 wheel but the scroll event is not caused by a rotation but a
 (usually sideways) tilt of the wheel.


    <ul>
        <li><span class="parameter">WHEEL</span>
         0 a physical wheel rotation
        </li>
        <li><span class="parameter">FINGER</span>
         1 finger on a touch surface
        </li>
        <li><span class="parameter">CONTINUOUS</span>
         2 continuous coordinate space
        </li>
        <li><span class="parameter">WHEEL_TILT</span>
         3 a physical wheel tilt
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_pointer.AxisRelativeDirection"></a>
    <strong>wl_pointer.AxisRelativeDirection</strong>
    </dt>
    <dd>
    axis relative direction  This specifies the direction of the physical motion that caused a
 wl<em>pointer.axis event, relative to the wl</em>pointer.axis direction.


    <ul>
        <li><span class="parameter">IDENTICAL</span>
         0 physical motion matches axis direction
        </li>
        <li><span class="parameter">INVERTED</span>
         1 physical motion is the inverse of the axis direction
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_keyboard"></a>Class wl_keyboard </h2>

          <div class="section-description">
          keyboard input device  The wl_keyboard interface represents one or more keyboards
 associated with a seat.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_keyboard:release"></a>
    <strong>wl_keyboard:release ()</strong>
    </dt>
    <dd>
    release the keyboard object



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_keyboard</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_keyboard:keymap"></a>
    <strong>wl_keyboard:keymap</strong>
    </dt>
    <dd>
    keyboard mapping</p>

<p> This event provides a file descriptor to the client which can be
 memory-mapped in read-only mode to provide a keyboard mapping
 description.
 From version 7 onwards, the fd must be mapped with MAP<em>PRIVATE by
 the recipient, as MAP</em>SHARED may fail.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">format</span>
            <span class="types"><span class="type">uint</span></span>
         keymap format
        </li>
        <li><span class="parameter">fd</span>
            <span class="types"><span class="type">fd</span></span>
         keymap file descriptor
        </li>
        <li><span class="parameter">size</span>
            <span class="types"><span class="type">uint</span></span>
         keymap size, in bytes
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_keyboard:enter"></a>
    <strong>wl_keyboard:enter</strong>
    </dt>
    <dd>
    enter event</p>

<p> Notification that this seat's keyboard focus is on a certain
 surface.
 The compositor must send the wl_keyboard.modifiers event after this
 event.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the enter event
        </li>
        <li><span class="parameter">surface</span>
            <span class="types"><span class="type">wl_surface</span></span>
         surface gaining keyboard focus
        </li>
        <li><span class="parameter">keys</span>
            <span class="types"><span class="type">array</span></span>
         the currently pressed keys
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_keyboard:leave"></a>
    <strong>wl_keyboard:leave</strong>
    </dt>
    <dd>
    leave event</p>

<p> Notification that this seat's keyboard focus is no longer on
 a certain surface.
 The leave notification is sent before the enter notification
 for the new focus.
 After this event client must assume that no keys are pressed,
 it must stop key repeating if there's some going on and until
 it receives the next wl_keyboard.modifiers event, the client
 must also assume no modifiers are active.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the leave event
        </li>
        <li><span class="parameter">surface</span>
            <span class="types"><span class="type">wl_surface</span></span>
         surface that lost keyboard focus
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_keyboard:key"></a>
    <strong>wl_keyboard:key</strong>
    </dt>
    <dd>
    key event</p>

<p> A key was pressed or released.
 The time argument is a timestamp with millisecond
 granularity, with an undefined base.
 The key is a platform-specific key code that can be interpreted
 by feeding it to the keyboard mapping (see the keymap event).
 If this event produces a change in modifiers, then the resulting
 wl_keyboard.modifiers event must be sent after this event.
 The compositor must not send this event without a surface of the client
 having keyboard focus.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the key event
        </li>
        <li><span class="parameter">time</span>
            <span class="types"><span class="type">uint</span></span>
         timestamp with millisecond granularity
        </li>
        <li><span class="parameter">key</span>
            <span class="types"><span class="type">uint</span></span>
         key that produced the event
        </li>
        <li><span class="parameter">state</span>
            <span class="types"><span class="type">uint</span></span>
         physical state of the key
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_keyboard:modifiers"></a>
    <strong>wl_keyboard:modifiers</strong>
    </dt>
    <dd>
    modifier and group state</p>

<p> Notifies clients that the modifier and/or group state has
 changed, and it should update its local state.
 The compositor may send this event without a surface of the client
 having keyboard focus, for example to tie modifier information to
 pointer focus instead. If a modifier event with pressed modifiers is sent
 without a prior enter event, the client can assume the modifier state is
 valid until it receives the next wl<em>keyboard.modifiers event. In order to
 reset the modifier state again, the compositor can send a
 wl</em>keyboard.modifiers event with no pressed modifiers.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the modifiers event
        </li>
        <li><span class="parameter">mods_depressed</span>
            <span class="types"><span class="type">uint</span></span>
         depressed modifiers
        </li>
        <li><span class="parameter">mods_latched</span>
            <span class="types"><span class="type">uint</span></span>
         latched modifiers
        </li>
        <li><span class="parameter">mods_locked</span>
            <span class="types"><span class="type">uint</span></span>
         locked modifiers
        </li>
        <li><span class="parameter">group</span>
            <span class="types"><span class="type">uint</span></span>
         keyboard layout
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_keyboard:repeat_info"></a>
    <strong>wl_keyboard:repeat_info</strong>
    </dt>
    <dd>
    repeat rate and delay</p>

<p> Informs the client about the keyboard's repeat rate and delay.
 This event is sent as soon as the wl<em>keyboard object has been created,
 and is guaranteed to be received by the client before any key press
 event.
 Negative values for either rate or delay are illegal. A rate of zero
 will disable any repeating (regardless of the value of delay).
 This event can be sent later on as well with a new value if necessary,
 so clients should continue listening for the event past the creation
 of wl</em>keyboard.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">rate</span>
            <span class="types"><span class="type">int</span></span>
         the rate of repeating keys in characters per second
        </li>
        <li><span class="parameter">delay</span>
            <span class="types"><span class="type">int</span></span>
         delay in milliseconds since key down until repeating starts
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_keyboard.KeymapFormat"></a>
    <strong>wl_keyboard.KeymapFormat</strong>
    </dt>
    <dd>
    keyboard mapping format  This specifies the format of the keymap provided to the
 client with the wl_keyboard.keymap event.


    <ul>
        <li><span class="parameter">NO_KEYMAP</span>
         0 no keymap; client must understand how to interpret the raw keycode
        </li>
        <li><span class="parameter">XKB_V1</span>
         1 libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_keyboard.KeyState"></a>
    <strong>wl_keyboard.KeyState</strong>
    </dt>
    <dd>
    physical key state  Describes the physical state of a key that produced the key event.


    <ul>
        <li><span class="parameter">RELEASED</span>
         0 key is not pressed
        </li>
        <li><span class="parameter">PRESSED</span>
         1 key is pressed
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_touch"></a>Class wl_touch </h2>

          <div class="section-description">
          touchscreen input device</p>

<p> The wl_touch interface represents a touchscreen
 associated with a seat.
 Touch interactions can consist of one or more contacts.
 For each contact, a series of events is generated, starting
 with a down event, followed by zero or more motion events,
 and ending with an up event. Events relating to the same
 contact point can be identified by the ID of the sequence.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_touch:release"></a>
    <strong>wl_touch:release ()</strong>
    </dt>
    <dd>
    release the touch object



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_touch</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_touch:down"></a>
    <strong>wl_touch:down</strong>
    </dt>
    <dd>
    touch down event and beginning of a touch sequence</p>

<p> A new touch point has appeared on the surface.  This touch point is
 assigned a unique ID. Future events from this touch point reference
 this ID. The ID ceases to be valid after a touch up event and may be
 reused in the future.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the touch down event
        </li>
        <li><span class="parameter">time</span>
            <span class="types"><span class="type">uint</span></span>
         timestamp with millisecond granularity
        </li>
        <li><span class="parameter">surface</span>
            <span class="types"><span class="type">wl_surface</span></span>
         surface touched
        </li>
        <li><span class="parameter">id</span>
            <span class="types"><span class="type">int</span></span>
         the unique ID of this touch point
        </li>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">fixed</span></span>
         surface-local x coordinate
        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">fixed</span></span>
         surface-local y coordinate
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_touch:up"></a>
    <strong>wl_touch:up</strong>
    </dt>
    <dd>
    end of a touch event sequence</p>

<p> The touch point has disappeared.  No further events will be sent for
 this touch point and the touch point's ID is released and may be
 reused in a future touch down event.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">serial</span>
            <span class="types"><span class="type">uint</span></span>
         serial number of the touch up event
        </li>
        <li><span class="parameter">time</span>
            <span class="types"><span class="type">uint</span></span>
         timestamp with millisecond granularity
        </li>
        <li><span class="parameter">id</span>
            <span class="types"><span class="type">int</span></span>
         the unique ID of this touch point
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_touch:motion"></a>
    <strong>wl_touch:motion</strong>
    </dt>
    <dd>
    update of touch point coordinates  A touch point has changed coordinates.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">time</span>
            <span class="types"><span class="type">uint</span></span>
         timestamp with millisecond granularity
        </li>
        <li><span class="parameter">id</span>
            <span class="types"><span class="type">int</span></span>
         the unique ID of this touch point
        </li>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">fixed</span></span>
         surface-local x coordinate
        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">fixed</span></span>
         surface-local y coordinate
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_touch:frame"></a>
    <strong>wl_touch:frame</strong>
    </dt>
    <dd>
    end of touch frame event</p>

<p> Indicates the end of a set of events that logically belong together.
 A client is expected to accumulate the data in all events within the
 frame before proceeding.
 A wl_touch.frame terminates at least one event but otherwise no
 guarantee is provided about the set of events within a frame. A client
 must assume that any state not updated in a frame is unchanged from the
 previously known state.







</dd>
    <dt>
    <a name = "wl_touch:cancel"></a>
    <strong>wl_touch:cancel</strong>
    </dt>
    <dd>
    touch session cancelled</p>

<p> Sent if the compositor decides the touch stream is a global
 gesture.  No further events are sent to the clients from that
 particular gesture. Touch cancellation applies to all touch points
 currently active on this client's surface. The client is
 responsible for finalizing the touch points, future touch points on
 this surface may reuse the touch point ID.







</dd>
    <dt>
    <a name = "wl_touch:shape"></a>
    <strong>wl_touch:shape</strong>
    </dt>
    <dd>
    update shape of touch point</p>

<p> Sent when a touchpoint has changed its shape.
 This event does not occur on its own. It is sent before a
 wl<em>touch.frame event and carries the new shape information for
 any previously reported, or new touch points of that frame.
 Other events describing the touch point such as wl</em>touch.down,
 wl<em>touch.motion or wl</em>touch.orientation may be sent within the
 same wl<em>touch.frame. A client should treat these events as a single
 logical touch point update. The order of wl</em>touch.shape,
 wl<em>touch.orientation and wl</em>touch.motion is not guaranteed.
 A wl<em>touch.down event is guaranteed to occur before the first
 wl</em>touch.shape event for this touch ID but both events may occur within
 the same wl<em>touch.frame.
 A touchpoint shape is approximated by an ellipse through the major and
 minor axis length. The major axis length describes the longer diameter
 of the ellipse, while the minor axis length describes the shorter
 diameter. Major and minor are orthogonal and both are specified in
 surface-local coordinates. The center of the ellipse is always at the
 touchpoint location as reported by wl</em>touch.down or wl_touch.move.
 This event is only sent by the compositor if the touch device supports
 shape reports. The client has to make reasonable assumptions about the
 shape if it did not receive this event.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>
            <span class="types"><span class="type">int</span></span>
         the unique ID of this touch point
        </li>
        <li><span class="parameter">major</span>
            <span class="types"><span class="type">fixed</span></span>
         length of the major axis in surface-local coordinates
        </li>
        <li><span class="parameter">minor</span>
            <span class="types"><span class="type">fixed</span></span>
         length of the minor axis in surface-local coordinates
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_touch:orientation"></a>
    <strong>wl_touch:orientation</strong>
    </dt>
    <dd>
    update orientation of touch point</p>

<p> Sent when a touchpoint has changed its orientation.
 This event does not occur on its own. It is sent before a
 wl<em>touch.frame event and carries the new shape information for
 any previously reported, or new touch points of that frame.
 Other events describing the touch point such as wl</em>touch.down,
 wl<em>touch.motion or wl</em>touch.shape may be sent within the
 same wl<em>touch.frame. A client should treat these events as a single
 logical touch point update. The order of wl</em>touch.shape,
 wl<em>touch.orientation and wl</em>touch.motion is not guaranteed.
 A wl<em>touch.down event is guaranteed to occur before the first
 wl</em>touch.orientation event for this touch ID but both events may occur
 within the same wl_touch.frame.
 The orientation describes the clockwise angle of a touchpoint's major
 axis to the positive surface y-axis and is normalized to the -180 to
 +180 degree range. The granularity of orientation depends on the touch
 device, some devices only support binary rotation values between 0 and
 90 degrees.
 This event is only sent by the compositor if the touch device supports
 orientation reports.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>
            <span class="types"><span class="type">int</span></span>
         the unique ID of this touch point
        </li>
        <li><span class="parameter">orientation</span>
            <span class="types"><span class="type">fixed</span></span>
         angle between major axis and positive surface y-axis in degrees
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_output"></a>Class wl_output </h2>

          <div class="section-description">
          compositor output region</p>

<p> An output describes part of the compositor geometry.   The
 compositor works in the 'compositor coordinate system' and an
 output corresponds to a rectangular area in that space that is
 actually visible.  This typically corresponds to a monitor that
 displays part of the compositor space.  This object is published
 as global during start up, or when a monitor is hotplugged.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_output:release"></a>
    <strong>wl_output:release ()</strong>
    </dt>
    <dd>
    release the output object  Using this request a client can tell the server that it is not going to
 use the output object anymore.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_output</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_output:geometry"></a>
    <strong>wl_output:geometry</strong>
    </dt>
    <dd>
    properties of the output</p>

<p> The geometry event describes geometric properties of the output.
 The event is sent when binding to the output object and whenever
 any of the properties change.
 The physical size can be set to zero if it doesn't make sense for this
 output (e.g. for projectors or virtual outputs).
 The geometry event will be followed by a done event (starting from
 version 2).
 Note: wl<em>output only advertises partial information about the output
 position and identification. Some compositors, for instance those not
 implementing a desktop-style output layout or those exposing virtual
 outputs, might fake this information. Instead of using x and y, clients
 should use xdg</em>output.logical_position. Instead of using make and model,
 clients should use name and description.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">int</span></span>
         x position within the global compositor space
        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">int</span></span>
         y position within the global compositor space
        </li>
        <li><span class="parameter">physical_width</span>
            <span class="types"><span class="type">int</span></span>
         width in millimeters of the output
        </li>
        <li><span class="parameter">physical_height</span>
            <span class="types"><span class="type">int</span></span>
         height in millimeters of the output
        </li>
        <li><span class="parameter">subpixel</span>
            <span class="types"><span class="type">int</span></span>
         subpixel orientation of the output
        </li>
        <li><span class="parameter">make</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.4/manual.html#6.4">string</a></span>
         textual description of the manufacturer
        </li>
        <li><span class="parameter">model</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.4/manual.html#6.4">string</a></span>
         textual description of the model
        </li>
        <li><span class="parameter">transform</span>
            <span class="types"><span class="type">int</span></span>
         transform that maps framebuffer to output
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_output:mode"></a>
    <strong>wl_output:mode</strong>
    </dt>
    <dd>
    advertise available modes for the output</p>

<p> The mode event describes an available mode for the output.
 The event is sent when binding to the output object and there
 will always be one mode, the current mode.  The event is sent
 again if an output changes mode, for the mode that is now
 current.  In other words, the current mode is always the last
 mode that was received with the current flag set.
 Non-current modes are deprecated. A compositor can decide to only
 advertise the current mode and never send other modes. Clients
 should not rely on non-current modes.
 The size of a mode is given in physical hardware units of
 the output device. This is not necessarily the same as
 the output size in the global compositor space. For instance,
 the output may be scaled, as described in wl<em>output.scale,
 or transformed, as described in wl</em>output.transform. Clients
 willing to retrieve the output size in the global compositor
 space should use xdg<em>output.logical</em>size instead.
 The vertical refresh rate can be set to zero if it doesn't make
 sense for this output (e.g. for virtual outputs).
 The mode event will be followed by a done event (starting from
 version 2).
 Clients should not use the refresh rate to schedule frames. Instead,
 they should use the wl_surface.frame event or the presentation-time
 protocol.
 Note: this information is not always meaningful for all outputs. Some
 compositors, such as those exposing virtual outputs, might fake the
 refresh rate or the size.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">flags</span>
            <span class="types"><span class="type">uint</span></span>
         bitfield of mode flags
        </li>
        <li><span class="parameter">width</span>
            <span class="types"><span class="type">int</span></span>
         width of the mode in hardware units
        </li>
        <li><span class="parameter">height</span>
            <span class="types"><span class="type">int</span></span>
         height of the mode in hardware units
        </li>
        <li><span class="parameter">refresh</span>
            <span class="types"><span class="type">int</span></span>
         vertical refresh rate in mHz
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_output:done"></a>
    <strong>wl_output:done</strong>
    </dt>
    <dd>
    sent all information about output</p>

<p> This event is sent after all other properties have been
 sent after binding to the output object and after any
 other property changes done after that.  This allows
 changes to the output properties to be seen as
 atomic, even if they happen via multiple events.







</dd>
    <dt>
    <a name = "wl_output:scale"></a>
    <strong>wl_output:scale</strong>
    </dt>
    <dd>
    output scaling properties</p>

<p> This event contains scaling geometry information
 that is not in the geometry event.  It may be sent after
 binding the output object or if the output scale changes
 later. If it is not sent, the client should assume a
 scale of 1.
 A scale larger than 1 means that the compositor will
 automatically scale surface buffers by this amount
 when rendering. This is used for very high resolution
 displays where applications rendering at the native
 resolution would be too small to be legible.
 It is intended that scaling aware clients track the
 current output of a surface, and if it is on a scaled
 output it should use wl<em>surface.set</em>buffer_scale with
 the scale of the output. That way the compositor can
 avoid scaling the surface, and the client can supply
 a higher detail image.
 The scale event will be followed by a done event.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">factor</span>
            <span class="types"><span class="type">int</span></span>
         scaling factor of output
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_output:name"></a>
    <strong>wl_output:name</strong>
    </dt>
    <dd>
    name of this output</p>

<p> Many compositors will assign user-friendly names to their outputs, show
 them to the user, allow the user to refer to an output, etc.  The client
 may wish to know this name as well to offer the user similar behaviors.
 The name is a UTF-8 string with no convention defined for its contents.
 Each name is unique among all wl<em>output globals. The name is only
 guaranteed to be unique for the compositor instance.
 The same output name is used for all clients for a given wl</em>output
 global. Thus, the name can be shared across processes to refer to a
 specific wl<em>output global.
 The name is not guaranteed to be persistent across sessions, thus cannot
 be used to reliably identify an output in e.g. configuration files.
 Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do
 not assume that the name is a reflection of an underlying DRM connector,
 X11 connection, etc.
 The name event is sent after binding the output object. This event is
 only sent once per output object, and the name does not change over the
 lifetime of the wl</em>output global.
 Compositors may re-use the same output name if the wl_output global is
 destroyed and re-created later. Compositors should avoid re-using the
 same name if possible.
 The name event will be followed by a done event.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">name</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.4/manual.html#6.4">string</a></span>
         output name
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_output:description"></a>
    <strong>wl_output:description</strong>
    </dt>
    <dd>
    human-readable description of this output</p>

<p> Many compositors can produce human-readable descriptions of their
 outputs.  The client may wish to know this description as well, e.g. for
 output selection purposes.
 The description is a UTF-8 string with no convention defined for its
 contents. The description is not guaranteed to be unique among all
 wl_output globals. Examples might include 'Foocorp 11" Display' or
 'Virtual X11 output via :1'.
 The description event is sent after binding the output object and
 whenever the description changes. The description is optional, and may
 not be sent at all.
 The description event will be followed by a done event.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">description</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.4/manual.html#6.4">string</a></span>
         output description
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_output.Subpixel"></a>
    <strong>wl_output.Subpixel</strong>
    </dt>
    <dd>
    subpixel geometry information  This enumeration describes how the physical
 pixels on an output are laid out.


    <ul>
        <li><span class="parameter">UNKNOWN</span>
         0 unknown geometry
        </li>
        <li><span class="parameter">NONE</span>
         1 no geometry
        </li>
        <li><span class="parameter">HORIZONTAL_RGB</span>
         2 horizontal RGB
        </li>
        <li><span class="parameter">HORIZONTAL_BGR</span>
         3 horizontal BGR
        </li>
        <li><span class="parameter">VERTICAL_RGB</span>
         4 vertical RGB
        </li>
        <li><span class="parameter">VERTICAL_BGR</span>
         5 vertical BGR
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_output.Transform"></a>
    <strong>wl_output.Transform</strong>
    </dt>
    <dd>
    transform from framebuffer to output</p>

<p> This describes the transform that a compositor will apply to a
 surface to compensate for the rotation or mirroring of an
 output device.
 The flipped values correspond to an initial flip around a
 vertical axis followed by rotation.
 The purpose is mainly to allow clients to render accordingly and
 tell the compositor, so that for fullscreen surfaces, the
 compositor will still be able to scan out directly from client
 surfaces.


    <ul>
        <li><span class="parameter">NORMAL</span>
         0 no transform
        </li>
        <li><span class="parameter">90</span>
         1 90 degrees counter-clockwise
        </li>
        <li><span class="parameter">180</span>
         2 180 degrees counter-clockwise
        </li>
        <li><span class="parameter">270</span>
         3 270 degrees counter-clockwise
        </li>
        <li><span class="parameter">FLIPPED</span>
         4 180 degree flip around a vertical axis
        </li>
        <li><span class="parameter">FLIPPED_90</span>
         5 flip and rotate 90 degrees counter-clockwise
        </li>
        <li><span class="parameter">FLIPPED_180</span>
         6 flip and rotate 180 degrees counter-clockwise
        </li>
        <li><span class="parameter">FLIPPED_270</span>
         7 flip and rotate 270 degrees counter-clockwise
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wl_output.Mode"></a>
    <strong>wl_output.Mode</strong>
    </dt>
    <dd>
    mode information</p>

<p> These flags describe properties of an output mode.
 They are used in the flags bitfield of the mode event.


    <ul>
        <li><span class="parameter">CURRENT</span>
         0x1 indicates this is the current mode
        </li>
        <li><span class="parameter">PREFERRED</span>
         0x2 indicates this is the preferred mode
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_region"></a>Class wl_region </h2>

          <div class="section-description">
          region interface</p>

<p> A region object describes an area.
 Region objects are used to describe the opaque and input
 regions of a surface.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_region:destroy"></a>
    <strong>wl_region:destroy ()</strong>
    </dt>
    <dd>
    destroy region</p>

<p> Destroy the region.   This will invalidate the object ID.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_region</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_region:add"></a>
    <strong>wl_region:add (x, y, width, height)</strong>
    </dt>
    <dd>
    add rectangle to region  Add the specified rectangle to the region.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">int</span></span>
         region-local x coordinate
        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">int</span></span>
         region-local y coordinate
        </li>
        <li><span class="parameter">width</span>
            <span class="types"><span class="type">int</span></span>
         rectangle width
        </li>
        <li><span class="parameter">height</span>
            <span class="types"><span class="type">int</span></span>
         rectangle height
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_region</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_region:subtract"></a>
    <strong>wl_region:subtract (x, y, width, height)</strong>
    </dt>
    <dd>
    subtract rectangle from region  Subtract the specified rectangle from the region.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">int</span></span>
         region-local x coordinate
        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">int</span></span>
         region-local y coordinate
        </li>
        <li><span class="parameter">width</span>
            <span class="types"><span class="type">int</span></span>
         rectangle width
        </li>
        <li><span class="parameter">height</span>
            <span class="types"><span class="type">int</span></span>
         rectangle height
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_region</span></span>
        self
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_subcompositor"></a>Class wl_subcompositor </h2>

          <div class="section-description">
          sub-surface compositing</p>

<p> The global interface exposing sub-surface compositing capabilities.
 A wl<em>surface, that has sub-surfaces associated, is called the
 parent surface. Sub-surfaces can be arbitrarily nested and create
 a tree of sub-surfaces.
 The root surface in a tree of sub-surfaces is the main
 surface. The main surface cannot be a sub-surface, because
 sub-surfaces must always have a parent.
 A main surface with its sub-surfaces forms a (compound) window.
 For window management purposes, this set of wl</em>surface objects is
 to be considered as a single window, and it should also behave as
 such.
 The aim of sub-surfaces is to offload some of the compositing work
 within a window from clients to the compositor. A prime example is
 a video player with decorations and video in separate wl_surface
 objects. This should allow the compositor to pass YUV video buffer
 processing to dedicated overlay hardware when possible.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_subcompositor:destroy"></a>
    <strong>wl_subcompositor:destroy ()</strong>
    </dt>
    <dd>
    unbind from the subcompositor interface</p>

<p> Informs the server that the client will not be using this
 protocol object anymore.  This does not affect any other
 objects, wl_subsurface objects included.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_subcompositor</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_subcompositor:get_subsurface"></a>
    <strong>wl_subcompositor:get_subsurface (surface, parent)</strong>
    </dt>
    <dd>
    give a surface the role sub-surface</p>

<p> Create a sub-surface interface for the given surface, and
 associate it with the given parent surface.  This turns a
 plain wl<em>surface into a sub-surface.
 The to-be sub-surface must not already have another role, and it
 must not have an existing wl</em>subsurface object. Otherwise the
 bad<em>surface protocol error is raised.
 Adding sub-surfaces to a parent is a double-buffered operation on the
 parent (see wl</em>surface.commit). The effect of adding a sub-surface
 becomes visible on the next time the state of the parent surface is
 applied.
 The parent surface must not be one of the child surface's descendants,
 and the parent must be different from the child surface, otherwise the
 bad<em>parent protocol error is raised.
 This request modifies the behaviour of wl</em>surface.commit request on
 the sub-surface, see the documentation on wl_subsurface interface.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">surface</span>
            <span class="types"><span class="type">wl_surface</span></span>
         the surface to be turned into a sub-surface
        </li>
        <li><span class="parameter">parent</span>
            <span class="types"><span class="type">wl_surface</span></span>
         the parent surface
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_subsurface</span></span>



    </ol>




</dd>
    <dt>
    <a name = "wl_subcompositor.Error"></a>
    <strong>wl_subcompositor.Error</strong>
    </dt>
    <dd>
    error


    <ul>
        <li><span class="parameter">BAD_SURFACE</span>
         0 the to-be sub-surface is invalid
        </li>
        <li><span class="parameter">BAD_PARENT</span>
         1 the to-be sub-surface parent is invalid
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_wl_subsurface"></a>Class wl_subsurface </h2>

          <div class="section-description">
          sub-surface interface to a wl_surface</p>

<p> An additional interface to a wl<em>surface object, which has been
 made a sub-surface.  A sub-surface has one parent surface. A
 sub-surface's size and position are not limited to that of the parent.
 Particularly, a sub-surface is not automatically clipped to its
 parent's area.
 A sub-surface becomes mapped, when a non-NULL wl</em>buffer is applied
 and the parent surface is mapped. The order of which one happens
 first is irrelevant. A sub-surface is hidden if the parent becomes
 hidden, or if a NULL wl<em>buffer is applied. These rules apply
 recursively through the tree of surfaces.
 The behaviour of a wl</em>surface.commit request on a sub-surface
 depends on the sub-surface's mode. The possible modes are
 synchronized and desynchronized, see methods
 wl<em>subsurface.set</em>sync and wl<em>subsurface.set</em>desync. Synchronized
 mode caches the wl<em>surface state to be applied when the parent's
 state gets applied, and desynchronized mode applies the pending
 wl</em>surface state directly. A sub-surface is initially in the
 synchronized mode.
 Sub-surfaces also have another kind of state, which is managed by
 wl<em>subsurface requests, as opposed to wl</em>surface requests. This
 state includes the sub-surface position relative to the parent
 surface (wl<em>subsurface.set</em>position), and the stacking order of
 the parent and its sub-surfaces (wl<em>subsurface.place</em>above and
 .place<em>below). This state is applied when the parent surface's
 wl</em>surface state is applied, regardless of the sub-surface's mode.
 As the exception, set<em>sync and set</em>desync are effective immediately.
 The main surface can be thought to be always in desynchronized mode,
 since it does not have a parent in the sub-surfaces sense.
 Even if a sub-surface is in desynchronized mode, it will behave as
 in synchronized mode, if its parent surface behaves as in
 synchronized mode. This rule is applied recursively throughout the
 tree of surfaces. This means, that one can set a sub-surface into
 synchronized mode, and then assume that all its child and grand-child
 sub-surfaces are synchronized, too, without explicitly setting them.
 Destroying a sub-surface takes effect immediately. If you need to
 synchronize the removal of a sub-surface to the parent surface update,
 unmap the sub-surface first by attaching a NULL wl<em>buffer, update parent,
 and then destroy the sub-surface.
 If the parent wl</em>surface object is destroyed, the sub-surface is
 unmapped.
          </div>
    <dl class="function">
    <dt>
    <a name = "wl_subsurface:destroy"></a>
    <strong>wl_subsurface:destroy ()</strong>
    </dt>
    <dd>
    remove sub-surface interface</p>

<p> The sub-surface interface is removed from the wl<em>surface object
 that was turned into a sub-surface with a
 wl</em>subcompositor.get<em>subsurface request.  The wl</em>surface's association
 to the parent is deleted. The wl_surface is unmapped immediately.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_subsurface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_subsurface:set_position"></a>
    <strong>wl_subsurface:set_position (x, y)</strong>
    </dt>
    <dd>
    reposition the sub-surface</p>

<p> This schedules a sub-surface position change.
 The sub-surface will be moved so that its origin (top left
 corner pixel) will be at the location x, y of the parent surface
 coordinate system. The coordinates are not restricted to the parent
 surface area. Negative values are allowed.
 The scheduled coordinates will take effect whenever the state of the
 parent surface is applied. When this happens depends on whether the
 parent surface is in synchronized mode or not. See
 wl<em>subsurface.set</em>sync and wl<em>subsurface.set</em>desync for details.
 If more than one set_position request is invoked by the client before
 the commit of the parent surface, the position of a new request always
 replaces the scheduled position from any previous request.
 The initial position is 0, 0.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
            <span class="types"><span class="type">int</span></span>
         x coordinate in the parent surface
        </li>
        <li><span class="parameter">y</span>
            <span class="types"><span class="type">int</span></span>
         y coordinate in the parent surface
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_subsurface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_subsurface:place_above"></a>
    <strong>wl_subsurface:place_above (sibling)</strong>
    </dt>
    <dd>
    restack the sub-surface</p>

<p> This sub-surface is taken from the stack, and put back just
 above the reference surface, changing the z-order of the sub-surfaces.
 The reference surface must be one of the sibling surfaces, or the
 parent surface. Using any other surface, including this sub-surface,
 will cause a protocol error.
 The z-order is double-buffered. Requests are handled in order and
 applied immediately to a pending state. The final pending state is
 copied to the active state the next time the state of the parent
 surface is applied. When this happens depends on whether the parent
 surface is in synchronized mode or not. See wl<em>subsurface.set</em>sync and
 wl<em>subsurface.set</em>desync for details.
 A new sub-surface is initially added as the top-most in the stack
 of its siblings and parent.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">sibling</span>
            <span class="types"><span class="type">wl_surface</span></span>
         the reference surface
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_subsurface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_subsurface:place_below"></a>
    <strong>wl_subsurface:place_below (sibling)</strong>
    </dt>
    <dd>
    restack the sub-surface</p>

<p> The sub-surface is placed just below the reference surface.
 See wl<em>subsurface.place</em>above.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">sibling</span>
            <span class="types"><span class="type">wl_surface</span></span>
         the reference surface
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_subsurface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_subsurface:set_sync"></a>
    <strong>wl_subsurface:set_sync ()</strong>
    </dt>
    <dd>
    set sub-surface to synchronized mode</p>

<p> Change the commit behaviour of the sub-surface to synchronized
 mode, also described as the parent dependent mode.
 In synchronized mode, wl<em>surface.commit on a sub-surface will
 accumulate the committed state in a cache, but the state will
 not be applied and hence will not change the compositor output.
 The cached state is applied to the sub-surface immediately after
 the parent surface's state is applied. This ensures atomic
 updates of the parent and all its synchronized sub-surfaces.
 Applying the cached state will invalidate the cache, so further
 parent surface commits do not (re-)apply old state.
 See wl</em>subsurface for the recursive effect of this mode.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_subsurface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_subsurface:set_desync"></a>
    <strong>wl_subsurface:set_desync ()</strong>
    </dt>
    <dd>
    set sub-surface to desynchronized mode</p>

<p> Change the commit behaviour of the sub-surface to desynchronized
 mode, also described as independent or freely running mode.
 In desynchronized mode, wl<em>surface.commit on a sub-surface will
 apply the pending state directly, without caching, as happens
 normally with a wl</em>surface. Calling wl<em>surface.commit on the
 parent surface has no effect on the sub-surface's wl</em>surface
 state. This mode allows a sub-surface to be updated on its own.
 If cached state exists when wl<em>surface.commit is called in
 desynchronized mode, the pending state is added to the cached
 state, and applied as a whole. This invalidates the cache.
 Note: even if a sub-surface is set to desynchronized, a parent
 sub-surface may override it to behave as synchronized. For details,
 see wl</em>subsurface.
 If a surface's parent surface behaves as desynchronized, then
 the cached state is applied on set_desync.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">wl_subsurface</span></span>
        self
    </ol>




</dd>
    <dt>
    <a name = "wl_subsurface.Error"></a>
    <strong>wl_subsurface.Error</strong>
    </dt>
    <dd>
    error


    <ul>
        <li><span class="parameter">BAD_SURFACE</span>
         0 wl_surface is not a sibling or the parent
        </li>
    </ul>





</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/lunarmodules/LDoc">LDoc 1.5.0</a></i>
<i style="float:right;">Last updated 2023-07-28 15:31:50 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
